var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"mcb_pmsm_foc_qep_f28379d","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'mcb_pmsm_foc_qep_f28379d'.\r\n *\r\n * Model version                  : 9.0\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Tue Dec 10 10:17:02 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"mcb_pmsm_foc_qep_f28379d.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"MW_target_hardware_resources.h\"\r\n\r\nvolatile int IsrOverrun = 0;\r\nboolean_T isRateRunning[2] = { 0, 0 };\r\n\r\nboolean_T need2runFlags[2] = { 0, 0 };\r\n\r\nvoid rt_OneStep(void)\r\n{\r\n  boolean_T eventFlags[2];\r\n\r\n  /* Check base rate for overrun */\r\n  if (isRateRunning[0]++) {\r\n    IsrOverrun = 1;\r\n    isRateRunning[0]--;                /* allow future iterations to succeed*/\r\n    return;\r\n  }\r\n\r\n  /*\r\n   * For a bare-board target (i.e., no operating system), the rates\r\n   * that execute this base step are buffered locally to allow for\r\n   * overlapping preemption.\r\n   */\r\n  mcb_pmsm_foc_qep_f28379d_SetEventsForThisBaseStep(eventFlags);\r\n  enableTimer0Interrupt();\r\n  mcb_pmsm_foc_qep_f28379d_step0();\r\n\r\n  /* Get model outputs here */\r\n  disableTimer0Interrupt();\r\n  isRateRunning[0]--;\r\n  if (eventFlags[1]) {\r\n    if (need2runFlags[1]++) {\r\n      IsrOverrun = 1;\r\n      need2runFlags[1]--;              /* allow future iterations to succeed*/\r\n      return;\r\n    }\r\n  }\r\n\r\n  if (need2runFlags[1]) {\r\n    if (isRateRunning[1]) {\r\n      /* Yield to higher priority*/\r\n      return;\r\n    }\r\n\r\n    isRateRunning[1]++;\r\n    enableTimer0Interrupt();\r\n\r\n    /* Step the model for subrate \"1\" */\r\n    switch (1)\r\n    {\r\n     case 1 :\r\n      mcb_pmsm_foc_qep_f28379d_step1();\r\n\r\n      /* Get model outputs here */\r\n      break;\r\n\r\n     default :\r\n      break;\r\n    }\r\n\r\n    disableTimer0Interrupt();\r\n    need2runFlags[1]--;\r\n    isRateRunning[1]--;\r\n  }\r\n}\r\n\r\nvolatile boolean_T stopRequested;\r\nvolatile boolean_T runModel;\r\nint main(void)\r\n{\r\n  float modelBaseRate = 0.0005;\r\n  float systemClock = 200;\r\n\r\n  /* Initialize variables */\r\n  stopRequested = false;\r\n  runModel = false;\r\n  HWI_TIC28x_EnablePeripheralInterrupt();\r\n  c2000_flash_init();\r\n  init_board();\r\n\r\n#if defined(MW_EXEC_PROFILER_ON) || (defined(MW_EXTMODE_RUNNING) && !defined(XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME))\r\n\r\n  hardwareTimer1Init();\r\n\r\n#endif\r\n\r\n  ;\r\n  rtmSetErrorStatus(mcb_pmsm_foc_qep_f28379d_M, 0);\r\n  mcb_pmsm_foc_qep_f28379d_initialize();\r\n  globalInterruptDisable();\r\n  configureTimer0(modelBaseRate, systemClock);\r\n  runModel =\r\n    rtmGetErrorStatus(mcb_pmsm_foc_qep_f28379d_M) == (NULL);\r\n  enableTimer0Interrupt();\r\n  config_ePWM_TBSync();\r\n  mcb_pmsm_foc_qep_f28379d_configure_interrupts();\r\n  globalInterruptEnable();\r\n  while (runModel) {\r\n    stopRequested = !(\r\n                      rtmGetErrorStatus(mcb_pmsm_foc_qep_f28379d_M) == (NULL));\r\n  }\r\n\r\n  mcb_pmsm_foc_qep_f28379d_unconfigure_interrupts();\r\n\r\n  /* Terminate model */\r\n  mcb_pmsm_foc_qep_f28379d_terminate();\r\n  HWI_TIC28x_DisablePeripheralInterrupt();\r\n  globalInterruptDisable();\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"mcb_pmsm_foc_qep_f28379d.c","type":"source","group":"model","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: mcb_pmsm_foc_qep_f28379d.c\r\n *\r\n * Code generated for Simulink model 'mcb_pmsm_foc_qep_f28379d'.\r\n *\r\n * Model version                  : 9.0\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Tue Dec 10 10:17:02 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"mcb_pmsm_foc_qep_f28379d.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"mcb_pmsm_foc_qep_f28379d_private.h\"\r\n#include <math.h>\r\n#include \"rt_nonfinite.h\"\r\n#include <string.h>\r\n\r\n/* Block signals (default storage) */\r\nB_mcb_pmsm_foc_qep_f28379d_T mcb_pmsm_foc_qep_f28379d_B;\r\n\r\n/* Block states (default storage) */\r\nDW_mcb_pmsm_foc_qep_f28379d_T mcb_pmsm_foc_qep_f28379d_DW;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_mcb_pmsm_foc_qep_f28_T mcb_pmsm_foc_qep_f28379d_M_;\r\nRT_MODEL_mcb_pmsm_foc_qep_f28_T *const mcb_pmsm_foc_qep_f28379d_M =\r\n  &mcb_pmsm_foc_qep_f28379d_M_;\r\nstatic void rate_monotonic_scheduler(void);\r\n\r\n#ifndef __TMS320C28XX_CLA__\r\n\r\nuint16_T MW_adcCInitFlag = 0;\r\n\r\n#endif\r\n\r\n#ifndef __TMS320C28XX_CLA__\r\n\r\nuint16_T MW_adcBInitFlag = 0;\r\n\r\n#endif\r\n\r\n/*\r\n * Set which subrates need to run this base step (base rate always runs).\r\n * This function must be called prior to calling the model step function\r\n * in order to remember which rates need to run this base step.  The\r\n * buffering of events allows for overlapping preemption.\r\n */\r\nvoid mcb_pmsm_foc_qep_f28379d_SetEventsForThisBaseStep(boolean_T *eventFlags)\r\n{\r\n  /* Task runs when its counter is zero, computed via rtmStepTask macro */\r\n  eventFlags[1] = ((boolean_T)rtmStepTask(mcb_pmsm_foc_qep_f28379d_M, 1));\r\n}\r\n\r\n/*\r\n *         This function updates active task flag for each subrate\r\n *         and rate transition flags for tasks that exchange data.\r\n *         The function assumes rate-monotonic multitasking scheduler.\r\n *         The function must be called at model base rate so that\r\n *         the generated code self-manages all its subrates and rate\r\n *         transition flags.\r\n */\r\nstatic void rate_monotonic_scheduler(void)\r\n{\r\n  /* Compute which subrates run during the next base time step.  Subrates\r\n   * are an integer multiple of the base rate counter.  Therefore, the subtask\r\n   * counter is reset when it reaches its limit (zero means run).\r\n   */\r\n  (mcb_pmsm_foc_qep_f28379d_M->Timing.TaskCounters.TID[1])++;\r\n  if ((mcb_pmsm_foc_qep_f28379d_M->Timing.TaskCounters.TID[1]) > 999) {/* Sample time: [0.5s, 0.0s] */\r\n    mcb_pmsm_foc_qep_f28379d_M->Timing.TaskCounters.TID[1] = 0;\r\n  }\r\n}\r\n\r\n/*\r\n * Output and update for atomic system:\r\n *    '<S19>/Two inputs CRL'\r\n *    '<S175>/Two inputs CRL'\r\n */\r\nvoid mcb_pmsm_foc_q_TwoinputsCRL(real32_T rtu_Ds, real32_T rtu_Qs, real32_T\r\n  rtu_sin, real32_T rtu_cos, B_TwoinputsCRL_mcb_pmsm_foc_q_T *localB)\r\n{\r\n  /* Product: '<S152>/qcos' */\r\n  localB->qcos = rtu_Qs * rtu_cos;\r\n\r\n  /* Product: '<S152>/dsin' */\r\n  localB->dsin = rtu_Ds * rtu_sin;\r\n\r\n  /* Sum: '<S152>/sum_beta' */\r\n  localB->sum_beta = localB->qcos + localB->dsin;\r\n\r\n  /* Product: '<S152>/dcos' */\r\n  localB->dcos = rtu_Ds * rtu_cos;\r\n\r\n  /* Product: '<S152>/qsin' */\r\n  localB->qsin = rtu_Qs * rtu_sin;\r\n\r\n  /* Sum: '<S152>/sum_alpha' */\r\n  localB->sum_alpha = localB->dcos - localB->qsin;\r\n\r\n  /* Switch: '<S153>/Switch' */\r\n  localB->Switch[0] = localB->sum_alpha;\r\n  localB->Switch[1] = localB->sum_beta;\r\n\r\n  /* AlgorithmDescriptorDelegate generated from: '<S152>/a16' */\r\n  localB->algDD_o1 = localB->Switch[0];\r\n\r\n  /* AlgorithmDescriptorDelegate generated from: '<S152>/a16' */\r\n  localB->algDD_o2 = localB->Switch[1];\r\n}\r\n\r\n/*\r\n * Output and update for action system:\r\n *    '<S158>/If Action Subsystem'\r\n *    '<S182>/If Action Subsystem'\r\n */\r\nvoid mcb_pmsm__IfActionSubsystem(real32_T rtu_In1, real32_T *rty_Out1,\r\n  B_IfActionSubsystem_mcb_pmsm__T *localB)\r\n{\r\n  /* DataTypeConversion: '<S161>/Convert_uint16' */\r\n  localB->Convert_uint16 = (int16_T)(real32_T)floor(rtu_In1);\r\n\r\n  /* DataTypeConversion: '<S161>/Convert_back' */\r\n  localB->Convert_back = localB->Convert_uint16;\r\n\r\n  /* Sum: '<S161>/Sum' */\r\n  *rty_Out1 = rtu_In1 - localB->Convert_back;\r\n}\r\n\r\n/*\r\n * Output and update for action system:\r\n *    '<S158>/If Action Subsystem1'\r\n *    '<S182>/If Action Subsystem1'\r\n */\r\nvoid mcb_pmsm_IfActionSubsystem1(real32_T rtu_In1, real32_T *rty_Out1,\r\n  B_IfActionSubsystem1_mcb_pmsm_T *localB)\r\n{\r\n  /* DataTypeConversion: '<S162>/Convert_uint16' */\r\n  localB->Convert_uint16 = (int16_T)rtu_In1;\r\n\r\n  /* DataTypeConversion: '<S162>/Convert_back' */\r\n  localB->Convert_back = localB->Convert_uint16;\r\n\r\n  /* Sum: '<S162>/Sum' */\r\n  *rty_Out1 = rtu_In1 - localB->Convert_back;\r\n}\r\n\r\n/* System initialize for function-call system: '<Root>/Current Control' */\r\nvoid mcb_pms_CurrentControl_Init(void)\r\n{\r\n  /* Start for S-Function (c280xqep): '<S190>/eQEP' */\r\n  config_QEP_eQEP1((uint32_T)65535U,(uint32_T)0, (uint32_T)0, (uint32_T)0,\r\n                   (uint16_T)0, (uint16_T)448, (uint16_T)8232, (uint16_T)32768,\r\n                   (uint16_T)119,(uint16_T)0);\r\n\r\n  /* Start for S-Function (c2802xadc): '<S190>/ADC_C_IN2' */\r\n  if (MW_adcCInitFlag == 0U) {\r\n    InitAdcC();\r\n    MW_adcCInitFlag = 1U;\r\n  }\r\n\r\n  config_ADCC_SOC0 ();\r\n\r\n  /* Start for S-Function (c2802xadc): '<S190>/ADC_B_IN2' */\r\n  if (MW_adcBInitFlag == 0U) {\r\n    InitAdcB();\r\n    MW_adcBInitFlag = 1U;\r\n  }\r\n\r\n  config_ADCB_SOC0 ();\r\n\r\n  /* Start for S-Function (c280xgpio_do): '<S223>/DRV830x Enable' */\r\n  EALLOW;\r\n  GpioCtrlRegs.GPDMUX2.all &= 0xFCFFFFFFU;\r\n  GpioCtrlRegs.GPDDIR.all |= 0x10000000U;\r\n  EDIS;\r\n\r\n  /* Start for S-Function (c2802xpwm): '<S223>/ePWM1' */\r\n  real32_T tbprdValue1 = (real32_T)EPwm1Regs.TBPRD;\r\n\r\n  /*** Initialize ePWM1 modules ***/\r\n  {\r\n    /*  -- Time Base Control Register\r\n       EPwm1Regs.TBCTL.bit.CTRMODE              = 2U;          -- Counter Mode\r\n       EPwm1Regs.TBCTL.bit.SYNCOSEL             = 1U;          -- Sync Output Select\r\n\r\n       EPwm1Regs.TBCTL.bit.PRDLD                = 0U;          -- Shadow select\r\n\r\n       EPwm1Regs.TBCTL2.bit.PRDLDSYNC           = 0U;          -- Shadow select\r\n\r\n       EPwm1Regs.TBCTL.bit.PHSEN                = 0U;          -- Phase Load Enable\r\n       EPwm1Regs.TBCTL.bit.PHSDIR               = 0U;          -- Phase Direction Bit\r\n       EPwm1Regs.TBCTL.bit.HSPCLKDIV            = 0U;          -- High Speed TBCLK Pre-scaler\r\n       EPwm1Regs.TBCTL.bit.CLKDIV               = 0U;          -- Time Base Clock Pre-scaler\r\n     */\r\n    EPwm1Regs.TBCTL.all = (EPwm1Regs.TBCTL.all & ~0x3FFFU) | 0x12U;\r\n    EPwm1Regs.TBCTL2.all = (EPwm1Regs.TBCTL2.all & ~0xC000U) | 0x0U;\r\n\r\n    /*-- Setup Time-Base (TB) Submodule --*/\r\n    EPwm1Regs.TBPRD = 5000U;           // Time Base Period Register\r\n\r\n    /* -- Time-Base Phase Register\r\n       EPwm1Regs.TBPHS.bit.TBPHS               = 0U;          -- Phase offset register\r\n     */\r\n    EPwm1Regs.TBPHS.all = (EPwm1Regs.TBPHS.all & ~0xFFFF0000U) | 0x0U;\r\n\r\n    // Time Base Counter Register\r\n    EPwm1Regs.TBCTR = 0x0000U;         /* Clear counter*/\r\n\r\n    /*-- Setup Counter_Compare (CC) Submodule --*/\r\n    /*\t-- Counter Compare Control Register\r\n\r\n       EPwm1Regs.CMPCTL.bit.LOADASYNC           = 0U;          -- Active Compare A Load SYNC Option\r\n       EPwm1Regs.CMPCTL.bit.LOADBSYNC           = 0U;          -- Active Compare B Load SYNC Option\r\n       EPwm1Regs.CMPCTL.bit.LOADAMODE           = 0U;          -- Active Compare A Load\r\n       EPwm1Regs.CMPCTL.bit.LOADBMODE           = 0U;          -- Active Compare B Load\r\n       EPwm1Regs.CMPCTL.bit.SHDWAMODE           = 0U;          -- Compare A Register Block Operating Mode\r\n       EPwm1Regs.CMPCTL.bit.SHDWBMODE           = 0U;          -- Compare B Register Block Operating Mode\r\n     */\r\n    EPwm1Regs.CMPCTL.all = (EPwm1Regs.CMPCTL.all & ~0x3C5FU) | 0x0U;\r\n\r\n    /* EPwm1Regs.CMPCTL2.bit.SHDWCMODE           = 0U;          -- Compare C Register Block Operating Mode\r\n       EPwm1Regs.CMPCTL2.bit.SHDWDMODE           = 0U;          -- Compare D Register Block Operating Mode\r\n       EPwm1Regs.CMPCTL2.bit.LOADCSYNC           = 0U;          -- Active Compare C Load SYNC Option\r\n       EPwm1Regs.CMPCTL2.bit.LOADDSYNC           = 0U;          -- Active Compare D Load SYNC Option\r\n       EPwm1Regs.CMPCTL2.bit.LOADCMODE           = 0U;          -- Active Compare C Load\r\n       EPwm1Regs.CMPCTL2.bit.LOADDMODE           = 0U;          -- Active Compare D Load\r\n     */\r\n    EPwm1Regs.CMPCTL2.all = (EPwm1Regs.CMPCTL2.all & ~0x3C5FU) | 0x0U;\r\n    EPwm1Regs.CMPA.bit.CMPA = 2501U;   // Counter Compare A Register\r\n    EPwm1Regs.CMPB.bit.CMPB = 2501U;   // Counter Compare B Register\r\n    EPwm1Regs.CMPC = 32000U;           // Counter Compare C Register\r\n    EPwm1Regs.CMPD = 32000U;           // Counter Compare D Register\r\n\r\n    /*-- Setup Action-Qualifier (AQ) Submodule --*/\r\n    EPwm1Regs.AQCTLA.all = 144U;\r\n                               // Action Qualifier Control Register For Output A\r\n    EPwm1Regs.AQCTLB.all = 2310U;\r\n                               // Action Qualifier Control Register For Output B\r\n\r\n    /*\t-- Action Qualifier Software Force Register\r\n       EPwm1Regs.AQSFRC.bit.RLDCSF              = 0U;          -- Reload from Shadow Options\r\n     */\r\n    EPwm1Regs.AQSFRC.all = (EPwm1Regs.AQSFRC.all & ~0xC0U) | 0x0U;\r\n\r\n    /*\t-- Action Qualifier Continuous S/W Force Register\r\n       EPwm1Regs.AQCSFRC.bit.CSFA               = 0U;          -- Continuous Software Force on output A\r\n       EPwm1Regs.AQCSFRC.bit.CSFB               = 0U;          -- Continuous Software Force on output B\r\n     */\r\n    EPwm1Regs.AQCSFRC.all = (EPwm1Regs.AQCSFRC.all & ~0xFU) | 0x0U;\r\n\r\n    /*-- Setup Dead-Band Generator (DB) Submodule --*/\r\n    /*\t-- Dead-Band Generator Control Register\r\n       EPwm1Regs.DBCTL.bit.OUT_MODE             = 3U;          -- Dead Band Output Mode Control\r\n       EPwm1Regs.DBCTL.bit.IN_MODE              = 0U;          -- Dead Band Input Select Mode Control\r\n       EPwm1Regs.DBCTL.bit.POLSEL               = 2U;          -- Polarity Select Control\r\n       EPwm1Regs.DBCTL.bit.HALFCYCLE            = 0U;          -- Half Cycle Clocking Enable\r\n       EPwm1Regs.DBCTL.bit.SHDWDBREDMODE        = 0U;          -- DBRED shadow mode\r\n       EPwm1Regs.DBCTL.bit.SHDWDBFEDMODE        = 0U;          -- DBFED shadow mode\r\n       EPwm1Regs.DBCTL.bit.LOADREDMODE          = 4U;        -- DBRED load\r\n       EPwm1Regs.DBCTL.bit.LOADFEDMODE          = 4U;        -- DBFED load\r\n     */\r\n    EPwm1Regs.DBCTL.all = (EPwm1Regs.DBCTL.all & ~0x8FFFU) | 0xBU;\r\n    EPwm1Regs.DBRED.bit.DBRED = (uint16_T)(15.0);\r\n                         // Dead-Band Generator Rising Edge Delay Count Register\r\n    EPwm1Regs.DBFED.bit.DBFED = (uint16_T)(15.0);\r\n                        // Dead-Band Generator Falling Edge Delay Count Register\r\n\r\n    /*-- Setup Event-Trigger (ET) Submodule --*/\r\n    /*\t-- Event Trigger Selection and Pre-Scale Register\r\n       EPwm1Regs.ETSEL.bit.SOCAEN               = 1U;          -- Start of Conversion A Enable\r\n       EPwm1Regs.ETSEL.bit.SOCASELCMP           = 0U;\r\n       EPwm1Regs.ETSEL.bit.SOCASEL              = 2U;          -- Start of Conversion A Select\r\n       EPwm1Regs.ETPS.bit.SOCPSSEL              = 1U;          -- EPWM1SOC Period Select\r\n       EPwm1Regs.ETSOCPS.bit.SOCAPRD2           = 1U;\r\n       EPwm1Regs.ETSEL.bit.SOCBEN               = 0U;          -- Start of Conversion B Enable\r\n       EPwm1Regs.ETSEL.bit.SOCBSELCMP           = 0U;\r\n       EPwm1Regs.ETSEL.bit.SOCBSEL              = 1U;          -- Start of Conversion A Select\r\n       EPwm1Regs.ETPS.bit.SOCPSSEL              = 1;          -- EPWM1SOCB Period Select\r\n       EPwm1Regs.ETSOCPS.bit.SOCBPRD2           = 1U;\r\n       EPwm1Regs.ETSEL.bit.INTEN                = 0U;          -- EPWM1INTn Enable\r\n       EPwm1Regs.ETSEL.bit.INTSELCMP            = 0U;\r\n       EPwm1Regs.ETSEL.bit.INTSEL               = 1U;          -- Start of Conversion A Select\r\n       EPwm1Regs.ETPS.bit.INTPSSEL              = 1U;          // EPWM1INTn Period Select\r\n       EPwm1Regs.ETINTPS.bit.INTPRD2            = 1U;\r\n     */\r\n    EPwm1Regs.ETSEL.all = (EPwm1Regs.ETSEL.all & ~0xFF7FU) | 0x1A01U;\r\n    EPwm1Regs.ETPS.all = (EPwm1Regs.ETPS.all & ~0x30U) | 0x30U;\r\n    EPwm1Regs.ETSOCPS.all = (EPwm1Regs.ETSOCPS.all & ~0xF0FU) | 0x101U;\r\n    EPwm1Regs.ETINTPS.all = (EPwm1Regs.ETINTPS.all & ~0xFU) | 0x1U;\r\n\r\n    /*-- Setup PWM-Chopper (PC) Submodule --*/\r\n    /*\t-- PWM Chopper Control Register\r\n       EPwm1Regs.PCCTL.bit.CHPEN                = 0U;          -- PWM chopping enable\r\n       EPwm1Regs.PCCTL.bit.CHPFREQ              = 0U;          -- Chopping clock frequency\r\n       EPwm1Regs.PCCTL.bit.OSHTWTH              = 0U;          -- One-shot pulse width\r\n       EPwm1Regs.PCCTL.bit.CHPDUTY              = 0U;          -- Chopping clock Duty cycle\r\n     */\r\n    EPwm1Regs.PCCTL.all = (EPwm1Regs.PCCTL.all & ~0x7FFU) | 0x0U;\r\n\r\n    /*-- Set up Trip-Zone (TZ) Submodule --*/\r\n    EALLOW;\r\n    EPwm1Regs.TZSEL.all = 0U;          // Trip Zone Select Register\r\n\r\n    /*\t-- Trip Zone Control Register\r\n       EPwm1Regs.TZCTL.bit.TZA                  = 3U;          -- TZ1 to TZ6 Trip Action On EPWM1A\r\n       EPwm1Regs.TZCTL.bit.TZB                  = 3U;          -- TZ1 to TZ6 Trip Action On EPWM1B\r\n       EPwm1Regs.TZCTL.bit.DCAEVT1              = 3U;          -- EPWM1A action on DCAEVT1\r\n       EPwm1Regs.TZCTL.bit.DCAEVT2              = 3U;          -- EPWM1A action on DCAEVT2\r\n       EPwm1Regs.TZCTL.bit.DCBEVT1              = 3U;          -- EPWM1B action on DCBEVT1\r\n       EPwm1Regs.TZCTL.bit.DCBEVT2              = 3U;          -- EPWM1B action on DCBEVT2\r\n     */\r\n    EPwm1Regs.TZCTL.all = (EPwm1Regs.TZCTL.all & ~0xFFFU) | 0xFFFU;\r\n\r\n    /*\t-- Trip Zone Enable Interrupt Register\r\n       EPwm1Regs.TZEINT.bit.OST                 = 0U;          -- Trip Zones One Shot Int Enable\r\n       EPwm1Regs.TZEINT.bit.CBC                 = 0U;          -- Trip Zones Cycle By Cycle Int Enable\r\n       EPwm1Regs.TZEINT.bit.DCAEVT1             = 0U;          -- Digital Compare A Event 1 Int Enable\r\n       EPwm1Regs.TZEINT.bit.DCAEVT2             = 0U;          -- Digital Compare A Event 2 Int Enable\r\n       EPwm1Regs.TZEINT.bit.DCBEVT1             = 0U;          -- Digital Compare B Event 1 Int Enable\r\n       EPwm1Regs.TZEINT.bit.DCBEVT2             = 0U;          -- Digital Compare B Event 2 Int Enable\r\n     */\r\n    EPwm1Regs.TZEINT.all = (EPwm1Regs.TZEINT.all & ~0x7EU) | 0x0U;\r\n\r\n    /*\t-- Digital Compare A Control Register\r\n       EPwm1Regs.DCACTL.bit.EVT1SYNCE           = 0U;          -- DCAEVT1 SYNC Enable\r\n       EPwm1Regs.DCACTL.bit.EVT1SOCE            = 1U;          -- DCAEVT1 SOC Enable\r\n       EPwm1Regs.DCACTL.bit.EVT1FRCSYNCSEL      = 0U;          -- DCAEVT1 Force Sync Signal\r\n       EPwm1Regs.DCACTL.bit.EVT1SRCSEL          = 0U;          -- DCAEVT1 Source Signal\r\n       EPwm1Regs.DCACTL.bit.EVT2FRCSYNCSEL      = 0U;          -- DCAEVT2 Force Sync Signal\r\n       EPwm1Regs.DCACTL.bit.EVT2SRCSEL          = 0U;          -- DCAEVT2 Source Signal\r\n     */\r\n    EPwm1Regs.DCACTL.all = (EPwm1Regs.DCACTL.all & ~0x30FU) | 0x4U;\r\n\r\n    /*\t-- Digital Compare B Control Register\r\n       EPwm1Regs.DCBCTL.bit.EVT1SYNCE           = 0U;          -- DCBEVT1 SYNC Enable\r\n       EPwm1Regs.DCBCTL.bit.EVT1SOCE            = 0U;          -- DCBEVT1 SOC Enable\r\n       EPwm1Regs.DCBCTL.bit.EVT1FRCSYNCSEL      = 0U;          -- DCBEVT1 Force Sync Signal\r\n       EPwm1Regs.DCBCTL.bit.EVT1SRCSEL          = 0U;          -- DCBEVT1 Source Signal\r\n       EPwm1Regs.DCBCTL.bit.EVT2FRCSYNCSEL      = 0U;          -- DCBEVT2 Force Sync Signal\r\n       EPwm1Regs.DCBCTL.bit.EVT2SRCSEL          = 0U;          -- DCBEVT2 Source Signal\r\n     */\r\n    EPwm1Regs.DCBCTL.all = (EPwm1Regs.DCBCTL.all & ~0x30FU) | 0x0U;\r\n\r\n    /*\t-- Digital Compare Trip Select Register\r\n       EPwm1Regs.DCTRIPSEL.bit.DCAHCOMPSEL      = 0U;          -- Digital Compare A High COMP Input Select\r\n\r\n       EPwm1Regs.DCTRIPSEL.bit.DCALCOMPSEL      = 1U;          -- Digital Compare A Low COMP Input Select\r\n       EPwm1Regs.DCTRIPSEL.bit.DCBHCOMPSEL      = 0U;          -- Digital Compare B High COMP Input Select\r\n       EPwm1Regs.DCTRIPSEL.bit.DCBLCOMPSEL      = 1U;          -- Digital Compare B Low COMP Input Select\r\n     */\r\n    EPwm1Regs.DCTRIPSEL.all = (EPwm1Regs.DCTRIPSEL.all & ~ 0xFFFFU) | 0x1010U;\r\n\r\n    /*\t-- Trip Zone Digital Comparator Select Register\r\n       EPwm1Regs.TZDCSEL.bit.DCAEVT1            = 0U;          -- Digital Compare Output A Event 1\r\n       EPwm1Regs.TZDCSEL.bit.DCAEVT2            = 0U;          -- Digital Compare Output A Event 2\r\n       EPwm1Regs.TZDCSEL.bit.DCBEVT1            = 0U;          -- Digital Compare Output B Event 1\r\n       EPwm1Regs.TZDCSEL.bit.DCBEVT2            = 0U;          -- Digital Compare Output B Event 2\r\n     */\r\n    EPwm1Regs.TZDCSEL.all = (EPwm1Regs.TZDCSEL.all & ~0xFFFU) | 0x0U;\r\n\r\n    /*\t-- Digital Compare Filter Control Register\r\n       EPwm1Regs.DCFCTL.bit.BLANKE              = 0U;          -- Blanking Enable/Disable\r\n       EPwm1Regs.DCFCTL.bit.PULSESEL            = 1U;          -- Pulse Select for Blanking & Capture Alignment\r\n       EPwm1Regs.DCFCTL.bit.BLANKINV            = 0U;          -- Blanking Window Inversion\r\n       EPwm1Regs.DCFCTL.bit.SRCSEL              = 0U;          -- Filter Block Signal Source Select\r\n     */\r\n    EPwm1Regs.DCFCTL.all = (EPwm1Regs.DCFCTL.all & ~0x3FU) | 0x10U;\r\n    EPwm1Regs.DCFOFFSET = 0U;          // Digital Compare Filter Offset Register\r\n    EPwm1Regs.DCFWINDOW = 0U;          // Digital Compare Filter Window Register\r\n\r\n    /*\t-- Digital Compare Capture Control Register\r\n       EPwm1Regs.DCCAPCTL.bit.CAPE              = 0U;          -- Counter Capture Enable\r\n     */\r\n    EPwm1Regs.DCCAPCTL.all = (EPwm1Regs.DCCAPCTL.all & ~0x1U) | 0x0U;\r\n\r\n    /*\t-- HRPWM Configuration Register\r\n       EPwm1Regs.HRCNFG.bit.SWAPAB              = 0U;          -- Swap EPWMA and EPWMB Outputs Bit\r\n       EPwm1Regs.HRCNFG.bit.SELOUTB             = 0U;          -- EPWMB Output Selection Bit\r\n     */\r\n    EPwm1Regs.HRCNFG.all = (EPwm1Regs.HRCNFG.all & ~0xA0U) | 0x0U;\r\n\r\n    /* Update the Link Registers with the link value for all the Compare values and TBPRD */\r\n    /* No error is thrown if the ePWM register exists in the model or not */\r\n    EPwm1Regs.EPWMXLINK.bit.TBPRDLINK = 0U;\r\n    EPwm1Regs.EPWMXLINK.bit.CMPALINK = 0U;\r\n    EPwm1Regs.EPWMXLINK.bit.CMPBLINK = 0U;\r\n    EPwm1Regs.EPWMXLINK.bit.CMPCLINK = 0U;\r\n    EPwm1Regs.EPWMXLINK.bit.CMPDLINK = 0U;\r\n\r\n    /* SYNCPER - Peripheral synchronization output event\r\n       EPwm1Regs.HRPCTL.bit.PWMSYNCSEL            = 0U;          -- EPWMSYNCPER selection\r\n       EPwm1Regs.HRPCTL.bit.PWMSYNCSELX           = 0U;          --  EPWMSYNCPER selection\r\n     */\r\n    EPwm1Regs.HRPCTL.all = (EPwm1Regs.HRPCTL.all & ~0x72U) | 0x0U;\r\n    EDIS;\r\n  }\r\n\r\n  /* Start for S-Function (c2802xpwm): '<S223>/ePWM2' */\r\n  real32_T tbprdValue2 = (real32_T)EPwm2Regs.TBPRD;\r\n\r\n  /*** Initialize ePWM2 modules ***/\r\n  {\r\n    /*  -- Time Base Control Register\r\n       EPwm2Regs.TBCTL.bit.CTRMODE              = 2U;          -- Counter Mode\r\n       EPwm2Regs.TBCTL.bit.SYNCOSEL             = 0U;          -- Sync Output Select\r\n\r\n       EPwm2Regs.TBCTL.bit.PRDLD                = 0U;          -- Shadow select\r\n\r\n       EPwm2Regs.TBCTL2.bit.PRDLDSYNC           = 0U;          -- Shadow select\r\n\r\n       EPwm2Regs.TBCTL.bit.PHSEN                = 1U;          -- Phase Load Enable\r\n       EPwm2Regs.TBCTL.bit.PHSDIR               = 1U;          -- Phase Direction Bit\r\n       EPwm2Regs.TBCTL.bit.HSPCLKDIV            = 0U;          -- High Speed TBCLK Pre-scaler\r\n       EPwm2Regs.TBCTL.bit.CLKDIV               = 0U;          -- Time Base Clock Pre-scaler\r\n     */\r\n    EPwm2Regs.TBCTL.all = (EPwm2Regs.TBCTL.all & ~0x3FFFU) | 0x2006U;\r\n    EPwm2Regs.TBCTL2.all = (EPwm2Regs.TBCTL2.all & ~0xC000U) | 0x0U;\r\n\r\n    /*-- Setup Time-Base (TB) Submodule --*/\r\n    EPwm2Regs.TBPRD = 5000U;           // Time Base Period Register\r\n\r\n    /* -- Time-Base Phase Register\r\n       EPwm2Regs.TBPHS.bit.TBPHS               = 0U;          -- Phase offset register\r\n     */\r\n    EPwm2Regs.TBPHS.all = (EPwm2Regs.TBPHS.all & ~0xFFFF0000U) | 0x0U;\r\n\r\n    // Time Base Counter Register\r\n    EPwm2Regs.TBCTR = 0x0000U;         /* Clear counter*/\r\n\r\n    /*-- Setup Counter_Compare (CC) Submodule --*/\r\n    /*\t-- Counter Compare Control Register\r\n\r\n       EPwm2Regs.CMPCTL.bit.LOADASYNC           = 0U;          -- Active Compare A Load SYNC Option\r\n       EPwm2Regs.CMPCTL.bit.LOADBSYNC           = 0U;          -- Active Compare B Load SYNC Option\r\n       EPwm2Regs.CMPCTL.bit.LOADAMODE           = 0U;          -- Active Compare A Load\r\n       EPwm2Regs.CMPCTL.bit.LOADBMODE           = 0U;          -- Active Compare B Load\r\n       EPwm2Regs.CMPCTL.bit.SHDWAMODE           = 0U;          -- Compare A Register Block Operating Mode\r\n       EPwm2Regs.CMPCTL.bit.SHDWBMODE           = 0U;          -- Compare B Register Block Operating Mode\r\n     */\r\n    EPwm2Regs.CMPCTL.all = (EPwm2Regs.CMPCTL.all & ~0x3C5FU) | 0x0U;\r\n\r\n    /* EPwm2Regs.CMPCTL2.bit.SHDWCMODE           = 0U;          -- Compare C Register Block Operating Mode\r\n       EPwm2Regs.CMPCTL2.bit.SHDWDMODE           = 0U;          -- Compare D Register Block Operating Mode\r\n       EPwm2Regs.CMPCTL2.bit.LOADCSYNC           = 0U;          -- Active Compare C Load SYNC Option\r\n       EPwm2Regs.CMPCTL2.bit.LOADDSYNC           = 0U;          -- Active Compare D Load SYNC Option\r\n       EPwm2Regs.CMPCTL2.bit.LOADCMODE           = 0U;          -- Active Compare C Load\r\n       EPwm2Regs.CMPCTL2.bit.LOADDMODE           = 0U;          -- Active Compare D Load\r\n     */\r\n    EPwm2Regs.CMPCTL2.all = (EPwm2Regs.CMPCTL2.all & ~0x3C5FU) | 0x0U;\r\n    EPwm2Regs.CMPA.bit.CMPA = 2501U;   // Counter Compare A Register\r\n    EPwm2Regs.CMPB.bit.CMPB = 2501U;   // Counter Compare B Register\r\n    EPwm2Regs.CMPC = 32000U;           // Counter Compare C Register\r\n    EPwm2Regs.CMPD = 32000U;           // Counter Compare D Register\r\n\r\n    /*-- Setup Action-Qualifier (AQ) Submodule --*/\r\n    EPwm2Regs.AQCTLA.all = 144U;\r\n                               // Action Qualifier Control Register For Output A\r\n    EPwm2Regs.AQCTLB.all = 2310U;\r\n                               // Action Qualifier Control Register For Output B\r\n\r\n    /*\t-- Action Qualifier Software Force Register\r\n       EPwm2Regs.AQSFRC.bit.RLDCSF              = 0U;          -- Reload from Shadow Options\r\n     */\r\n    EPwm2Regs.AQSFRC.all = (EPwm2Regs.AQSFRC.all & ~0xC0U) | 0x0U;\r\n\r\n    /*\t-- Action Qualifier Continuous S/W Force Register\r\n       EPwm2Regs.AQCSFRC.bit.CSFA               = 0U;          -- Continuous Software Force on output A\r\n       EPwm2Regs.AQCSFRC.bit.CSFB               = 0U;          -- Continuous Software Force on output B\r\n     */\r\n    EPwm2Regs.AQCSFRC.all = (EPwm2Regs.AQCSFRC.all & ~0xFU) | 0x0U;\r\n\r\n    /*-- Setup Dead-Band Generator (DB) Submodule --*/\r\n    /*\t-- Dead-Band Generator Control Register\r\n       EPwm2Regs.DBCTL.bit.OUT_MODE             = 3U;          -- Dead Band Output Mode Control\r\n       EPwm2Regs.DBCTL.bit.IN_MODE              = 0U;          -- Dead Band Input Select Mode Control\r\n       EPwm2Regs.DBCTL.bit.POLSEL               = 2U;          -- Polarity Select Control\r\n       EPwm2Regs.DBCTL.bit.HALFCYCLE            = 0U;          -- Half Cycle Clocking Enable\r\n       EPwm2Regs.DBCTL.bit.SHDWDBREDMODE        = 0U;          -- DBRED shadow mode\r\n       EPwm2Regs.DBCTL.bit.SHDWDBFEDMODE        = 0U;          -- DBFED shadow mode\r\n       EPwm2Regs.DBCTL.bit.LOADREDMODE          = 4U;        -- DBRED load\r\n       EPwm2Regs.DBCTL.bit.LOADFEDMODE          = 4U;        -- DBFED load\r\n     */\r\n    EPwm2Regs.DBCTL.all = (EPwm2Regs.DBCTL.all & ~0x8FFFU) | 0xBU;\r\n    EPwm2Regs.DBRED.bit.DBRED = (uint16_T)(15.0);\r\n                         // Dead-Band Generator Rising Edge Delay Count Register\r\n    EPwm2Regs.DBFED.bit.DBFED = (uint16_T)(15.0);\r\n                        // Dead-Band Generator Falling Edge Delay Count Register\r\n\r\n    /*-- Setup Event-Trigger (ET) Submodule --*/\r\n    /*\t-- Event Trigger Selection and Pre-Scale Register\r\n       EPwm2Regs.ETSEL.bit.SOCAEN               = 0U;          -- Start of Conversion A Enable\r\n       EPwm2Regs.ETSEL.bit.SOCASELCMP           = 0U;\r\n       EPwm2Regs.ETSEL.bit.SOCASEL              = 2U;          -- Start of Conversion A Select\r\n       EPwm2Regs.ETPS.bit.SOCPSSEL              = 1U;          -- EPWM2SOC Period Select\r\n       EPwm2Regs.ETSOCPS.bit.SOCAPRD2           = 1U;\r\n       EPwm2Regs.ETSEL.bit.SOCBEN               = 0U;          -- Start of Conversion B Enable\r\n       EPwm2Regs.ETSEL.bit.SOCBSELCMP           = 0U;\r\n       EPwm2Regs.ETSEL.bit.SOCBSEL              = 1U;          -- Start of Conversion A Select\r\n       EPwm2Regs.ETPS.bit.SOCPSSEL              = 1;          -- EPWM2SOCB Period Select\r\n       EPwm2Regs.ETSOCPS.bit.SOCBPRD2           = 1U;\r\n       EPwm2Regs.ETSEL.bit.INTEN                = 0U;          -- EPWM2INTn Enable\r\n       EPwm2Regs.ETSEL.bit.INTSELCMP            = 0U;\r\n       EPwm2Regs.ETSEL.bit.INTSEL               = 1U;          -- Start of Conversion A Select\r\n       EPwm2Regs.ETPS.bit.INTPSSEL              = 1U;          // EPWM2INTn Period Select\r\n       EPwm2Regs.ETINTPS.bit.INTPRD2            = 1U;\r\n     */\r\n    EPwm2Regs.ETSEL.all = (EPwm2Regs.ETSEL.all & ~0xFF7FU) | 0x1201U;\r\n    EPwm2Regs.ETPS.all = (EPwm2Regs.ETPS.all & ~0x30U) | 0x30U;\r\n    EPwm2Regs.ETSOCPS.all = (EPwm2Regs.ETSOCPS.all & ~0xF0FU) | 0x101U;\r\n    EPwm2Regs.ETINTPS.all = (EPwm2Regs.ETINTPS.all & ~0xFU) | 0x1U;\r\n\r\n    /*-- Setup PWM-Chopper (PC) Submodule --*/\r\n    /*\t-- PWM Chopper Control Register\r\n       EPwm2Regs.PCCTL.bit.CHPEN                = 0U;          -- PWM chopping enable\r\n       EPwm2Regs.PCCTL.bit.CHPFREQ              = 0U;          -- Chopping clock frequency\r\n       EPwm2Regs.PCCTL.bit.OSHTWTH              = 0U;          -- One-shot pulse width\r\n       EPwm2Regs.PCCTL.bit.CHPDUTY              = 0U;          -- Chopping clock Duty cycle\r\n     */\r\n    EPwm2Regs.PCCTL.all = (EPwm2Regs.PCCTL.all & ~0x7FFU) | 0x0U;\r\n\r\n    /*-- Set up Trip-Zone (TZ) Submodule --*/\r\n    EALLOW;\r\n    EPwm2Regs.TZSEL.all = 0U;          // Trip Zone Select Register\r\n\r\n    /*\t-- Trip Zone Control Register\r\n       EPwm2Regs.TZCTL.bit.TZA                  = 3U;          -- TZ1 to TZ6 Trip Action On EPWM2A\r\n       EPwm2Regs.TZCTL.bit.TZB                  = 3U;          -- TZ1 to TZ6 Trip Action On EPWM2B\r\n       EPwm2Regs.TZCTL.bit.DCAEVT1              = 3U;          -- EPWM2A action on DCAEVT1\r\n       EPwm2Regs.TZCTL.bit.DCAEVT2              = 3U;          -- EPWM2A action on DCAEVT2\r\n       EPwm2Regs.TZCTL.bit.DCBEVT1              = 3U;          -- EPWM2B action on DCBEVT1\r\n       EPwm2Regs.TZCTL.bit.DCBEVT2              = 3U;          -- EPWM2B action on DCBEVT2\r\n     */\r\n    EPwm2Regs.TZCTL.all = (EPwm2Regs.TZCTL.all & ~0xFFFU) | 0xFFFU;\r\n\r\n    /*\t-- Trip Zone Enable Interrupt Register\r\n       EPwm2Regs.TZEINT.bit.OST                 = 0U;          -- Trip Zones One Shot Int Enable\r\n       EPwm2Regs.TZEINT.bit.CBC                 = 0U;          -- Trip Zones Cycle By Cycle Int Enable\r\n       EPwm2Regs.TZEINT.bit.DCAEVT1             = 0U;          -- Digital Compare A Event 1 Int Enable\r\n       EPwm2Regs.TZEINT.bit.DCAEVT2             = 0U;          -- Digital Compare A Event 2 Int Enable\r\n       EPwm2Regs.TZEINT.bit.DCBEVT1             = 0U;          -- Digital Compare B Event 1 Int Enable\r\n       EPwm2Regs.TZEINT.bit.DCBEVT2             = 0U;          -- Digital Compare B Event 2 Int Enable\r\n     */\r\n    EPwm2Regs.TZEINT.all = (EPwm2Regs.TZEINT.all & ~0x7EU) | 0x0U;\r\n\r\n    /*\t-- Digital Compare A Control Register\r\n       EPwm2Regs.DCACTL.bit.EVT1SYNCE           = 0U;          -- DCAEVT1 SYNC Enable\r\n       EPwm2Regs.DCACTL.bit.EVT1SOCE            = 1U;          -- DCAEVT1 SOC Enable\r\n       EPwm2Regs.DCACTL.bit.EVT1FRCSYNCSEL      = 0U;          -- DCAEVT1 Force Sync Signal\r\n       EPwm2Regs.DCACTL.bit.EVT1SRCSEL          = 0U;          -- DCAEVT1 Source Signal\r\n       EPwm2Regs.DCACTL.bit.EVT2FRCSYNCSEL      = 0U;          -- DCAEVT2 Force Sync Signal\r\n       EPwm2Regs.DCACTL.bit.EVT2SRCSEL          = 0U;          -- DCAEVT2 Source Signal\r\n     */\r\n    EPwm2Regs.DCACTL.all = (EPwm2Regs.DCACTL.all & ~0x30FU) | 0x4U;\r\n\r\n    /*\t-- Digital Compare B Control Register\r\n       EPwm2Regs.DCBCTL.bit.EVT1SYNCE           = 0U;          -- DCBEVT1 SYNC Enable\r\n       EPwm2Regs.DCBCTL.bit.EVT1SOCE            = 0U;          -- DCBEVT1 SOC Enable\r\n       EPwm2Regs.DCBCTL.bit.EVT1FRCSYNCSEL      = 0U;          -- DCBEVT1 Force Sync Signal\r\n       EPwm2Regs.DCBCTL.bit.EVT1SRCSEL          = 0U;          -- DCBEVT1 Source Signal\r\n       EPwm2Regs.DCBCTL.bit.EVT2FRCSYNCSEL      = 0U;          -- DCBEVT2 Force Sync Signal\r\n       EPwm2Regs.DCBCTL.bit.EVT2SRCSEL          = 0U;          -- DCBEVT2 Source Signal\r\n     */\r\n    EPwm2Regs.DCBCTL.all = (EPwm2Regs.DCBCTL.all & ~0x30FU) | 0x0U;\r\n\r\n    /*\t-- Digital Compare Trip Select Register\r\n       EPwm2Regs.DCTRIPSEL.bit.DCAHCOMPSEL      = 0U;          -- Digital Compare A High COMP Input Select\r\n\r\n       EPwm2Regs.DCTRIPSEL.bit.DCALCOMPSEL      = 1U;          -- Digital Compare A Low COMP Input Select\r\n       EPwm2Regs.DCTRIPSEL.bit.DCBHCOMPSEL      = 0U;          -- Digital Compare B High COMP Input Select\r\n       EPwm2Regs.DCTRIPSEL.bit.DCBLCOMPSEL      = 1U;          -- Digital Compare B Low COMP Input Select\r\n     */\r\n    EPwm2Regs.DCTRIPSEL.all = (EPwm2Regs.DCTRIPSEL.all & ~ 0xFFFFU) | 0x1010U;\r\n\r\n    /*\t-- Trip Zone Digital Comparator Select Register\r\n       EPwm2Regs.TZDCSEL.bit.DCAEVT1            = 0U;          -- Digital Compare Output A Event 1\r\n       EPwm2Regs.TZDCSEL.bit.DCAEVT2            = 0U;          -- Digital Compare Output A Event 2\r\n       EPwm2Regs.TZDCSEL.bit.DCBEVT1            = 0U;          -- Digital Compare Output B Event 1\r\n       EPwm2Regs.TZDCSEL.bit.DCBEVT2            = 0U;          -- Digital Compare Output B Event 2\r\n     */\r\n    EPwm2Regs.TZDCSEL.all = (EPwm2Regs.TZDCSEL.all & ~0xFFFU) | 0x0U;\r\n\r\n    /*\t-- Digital Compare Filter Control Register\r\n       EPwm2Regs.DCFCTL.bit.BLANKE              = 0U;          -- Blanking Enable/Disable\r\n       EPwm2Regs.DCFCTL.bit.PULSESEL            = 1U;          -- Pulse Select for Blanking & Capture Alignment\r\n       EPwm2Regs.DCFCTL.bit.BLANKINV            = 0U;          -- Blanking Window Inversion\r\n       EPwm2Regs.DCFCTL.bit.SRCSEL              = 0U;          -- Filter Block Signal Source Select\r\n     */\r\n    EPwm2Regs.DCFCTL.all = (EPwm2Regs.DCFCTL.all & ~0x3FU) | 0x10U;\r\n    EPwm2Regs.DCFOFFSET = 0U;          // Digital Compare Filter Offset Register\r\n    EPwm2Regs.DCFWINDOW = 0U;          // Digital Compare Filter Window Register\r\n\r\n    /*\t-- Digital Compare Capture Control Register\r\n       EPwm2Regs.DCCAPCTL.bit.CAPE              = 0U;          -- Counter Capture Enable\r\n     */\r\n    EPwm2Regs.DCCAPCTL.all = (EPwm2Regs.DCCAPCTL.all & ~0x1U) | 0x0U;\r\n\r\n    /*\t-- HRPWM Configuration Register\r\n       EPwm2Regs.HRCNFG.bit.SWAPAB              = 0U;          -- Swap EPWMA and EPWMB Outputs Bit\r\n       EPwm2Regs.HRCNFG.bit.SELOUTB             = 0U;          -- EPWMB Output Selection Bit\r\n     */\r\n    EPwm2Regs.HRCNFG.all = (EPwm2Regs.HRCNFG.all & ~0xA0U) | 0x0U;\r\n\r\n    /* Update the Link Registers with the link value for all the Compare values and TBPRD */\r\n    /* No error is thrown if the ePWM register exists in the model or not */\r\n    EPwm2Regs.EPWMXLINK.bit.TBPRDLINK = 1U;\r\n    EPwm2Regs.EPWMXLINK.bit.CMPALINK = 1U;\r\n    EPwm2Regs.EPWMXLINK.bit.CMPBLINK = 1U;\r\n    EPwm2Regs.EPWMXLINK.bit.CMPCLINK = 1U;\r\n    EPwm2Regs.EPWMXLINK.bit.CMPDLINK = 1U;\r\n\r\n    /* SYNCPER - Peripheral synchronization output event\r\n       EPwm2Regs.HRPCTL.bit.PWMSYNCSEL            = 0U;          -- EPWMSYNCPER selection\r\n       EPwm2Regs.HRPCTL.bit.PWMSYNCSELX           = 0U;          --  EPWMSYNCPER selection\r\n     */\r\n    EPwm2Regs.HRPCTL.all = (EPwm2Regs.HRPCTL.all & ~0x72U) | 0x0U;\r\n    EDIS;\r\n  }\r\n\r\n  /* Start for S-Function (c2802xpwm): '<S223>/ePWM3' */\r\n  real32_T tbprdValue3 = (real32_T)EPwm3Regs.TBPRD;\r\n\r\n  /*** Initialize ePWM3 modules ***/\r\n  {\r\n    /*  -- Time Base Control Register\r\n       EPwm3Regs.TBCTL.bit.CTRMODE              = 2U;          -- Counter Mode\r\n       EPwm3Regs.TBCTL.bit.SYNCOSEL             = 0U;          -- Sync Output Select\r\n\r\n       EPwm3Regs.TBCTL.bit.PRDLD                = 0U;          -- Shadow select\r\n\r\n       EPwm3Regs.TBCTL2.bit.PRDLDSYNC           = 0U;          -- Shadow select\r\n\r\n       EPwm3Regs.TBCTL.bit.PHSEN                = 1U;          -- Phase Load Enable\r\n       EPwm3Regs.TBCTL.bit.PHSDIR               = 1U;          -- Phase Direction Bit\r\n       EPwm3Regs.TBCTL.bit.HSPCLKDIV            = 0U;          -- High Speed TBCLK Pre-scaler\r\n       EPwm3Regs.TBCTL.bit.CLKDIV               = 0U;          -- Time Base Clock Pre-scaler\r\n     */\r\n    EPwm3Regs.TBCTL.all = (EPwm3Regs.TBCTL.all & ~0x3FFFU) | 0x2006U;\r\n    EPwm3Regs.TBCTL2.all = (EPwm3Regs.TBCTL2.all & ~0xC000U) | 0x0U;\r\n\r\n    /*-- Setup Time-Base (TB) Submodule --*/\r\n    EPwm3Regs.TBPRD = 5000U;           // Time Base Period Register\r\n\r\n    /* -- Time-Base Phase Register\r\n       EPwm3Regs.TBPHS.bit.TBPHS               = 0U;          -- Phase offset register\r\n     */\r\n    EPwm3Regs.TBPHS.all = (EPwm3Regs.TBPHS.all & ~0xFFFF0000U) | 0x0U;\r\n\r\n    // Time Base Counter Register\r\n    EPwm3Regs.TBCTR = 0x0000U;         /* Clear counter*/\r\n\r\n    /*-- Setup Counter_Compare (CC) Submodule --*/\r\n    /*\t-- Counter Compare Control Register\r\n\r\n       EPwm3Regs.CMPCTL.bit.LOADASYNC           = 0U;          -- Active Compare A Load SYNC Option\r\n       EPwm3Regs.CMPCTL.bit.LOADBSYNC           = 0U;          -- Active Compare B Load SYNC Option\r\n       EPwm3Regs.CMPCTL.bit.LOADAMODE           = 0U;          -- Active Compare A Load\r\n       EPwm3Regs.CMPCTL.bit.LOADBMODE           = 0U;          -- Active Compare B Load\r\n       EPwm3Regs.CMPCTL.bit.SHDWAMODE           = 0U;          -- Compare A Register Block Operating Mode\r\n       EPwm3Regs.CMPCTL.bit.SHDWBMODE           = 0U;          -- Compare B Register Block Operating Mode\r\n     */\r\n    EPwm3Regs.CMPCTL.all = (EPwm3Regs.CMPCTL.all & ~0x3C5FU) | 0x0U;\r\n\r\n    /* EPwm3Regs.CMPCTL2.bit.SHDWCMODE           = 0U;          -- Compare C Register Block Operating Mode\r\n       EPwm3Regs.CMPCTL2.bit.SHDWDMODE           = 0U;          -- Compare D Register Block Operating Mode\r\n       EPwm3Regs.CMPCTL2.bit.LOADCSYNC           = 0U;          -- Active Compare C Load SYNC Option\r\n       EPwm3Regs.CMPCTL2.bit.LOADDSYNC           = 0U;          -- Active Compare D Load SYNC Option\r\n       EPwm3Regs.CMPCTL2.bit.LOADCMODE           = 0U;          -- Active Compare C Load\r\n       EPwm3Regs.CMPCTL2.bit.LOADDMODE           = 0U;          -- Active Compare D Load\r\n     */\r\n    EPwm3Regs.CMPCTL2.all = (EPwm3Regs.CMPCTL2.all & ~0x3C5FU) | 0x0U;\r\n    EPwm3Regs.CMPA.bit.CMPA = 2501U;   // Counter Compare A Register\r\n    EPwm3Regs.CMPB.bit.CMPB = 2501U;   // Counter Compare B Register\r\n    EPwm3Regs.CMPC = 32000U;           // Counter Compare C Register\r\n    EPwm3Regs.CMPD = 32000U;           // Counter Compare D Register\r\n\r\n    /*-- Setup Action-Qualifier (AQ) Submodule --*/\r\n    EPwm3Regs.AQCTLA.all = 144U;\r\n                               // Action Qualifier Control Register For Output A\r\n    EPwm3Regs.AQCTLB.all = 2310U;\r\n                               // Action Qualifier Control Register For Output B\r\n\r\n    /*\t-- Action Qualifier Software Force Register\r\n       EPwm3Regs.AQSFRC.bit.RLDCSF              = 0U;          -- Reload from Shadow Options\r\n     */\r\n    EPwm3Regs.AQSFRC.all = (EPwm3Regs.AQSFRC.all & ~0xC0U) | 0x0U;\r\n\r\n    /*\t-- Action Qualifier Continuous S/W Force Register\r\n       EPwm3Regs.AQCSFRC.bit.CSFA               = 0U;          -- Continuous Software Force on output A\r\n       EPwm3Regs.AQCSFRC.bit.CSFB               = 0U;          -- Continuous Software Force on output B\r\n     */\r\n    EPwm3Regs.AQCSFRC.all = (EPwm3Regs.AQCSFRC.all & ~0xFU) | 0x0U;\r\n\r\n    /*-- Setup Dead-Band Generator (DB) Submodule --*/\r\n    /*\t-- Dead-Band Generator Control Register\r\n       EPwm3Regs.DBCTL.bit.OUT_MODE             = 3U;          -- Dead Band Output Mode Control\r\n       EPwm3Regs.DBCTL.bit.IN_MODE              = 0U;          -- Dead Band Input Select Mode Control\r\n       EPwm3Regs.DBCTL.bit.POLSEL               = 2U;          -- Polarity Select Control\r\n       EPwm3Regs.DBCTL.bit.HALFCYCLE            = 0U;          -- Half Cycle Clocking Enable\r\n       EPwm3Regs.DBCTL.bit.SHDWDBREDMODE        = 0U;          -- DBRED shadow mode\r\n       EPwm3Regs.DBCTL.bit.SHDWDBFEDMODE        = 0U;          -- DBFED shadow mode\r\n       EPwm3Regs.DBCTL.bit.LOADREDMODE          = 4U;        -- DBRED load\r\n       EPwm3Regs.DBCTL.bit.LOADFEDMODE          = 4U;        -- DBFED load\r\n     */\r\n    EPwm3Regs.DBCTL.all = (EPwm3Regs.DBCTL.all & ~0x8FFFU) | 0xBU;\r\n    EPwm3Regs.DBRED.bit.DBRED = (uint16_T)(15.0);\r\n                         // Dead-Band Generator Rising Edge Delay Count Register\r\n    EPwm3Regs.DBFED.bit.DBFED = (uint16_T)(15.0);\r\n                        // Dead-Band Generator Falling Edge Delay Count Register\r\n\r\n    /*-- Setup Event-Trigger (ET) Submodule --*/\r\n    /*\t-- Event Trigger Selection and Pre-Scale Register\r\n       EPwm3Regs.ETSEL.bit.SOCAEN               = 0U;          -- Start of Conversion A Enable\r\n       EPwm3Regs.ETSEL.bit.SOCASELCMP           = 0U;\r\n       EPwm3Regs.ETSEL.bit.SOCASEL              = 2U;          -- Start of Conversion A Select\r\n       EPwm3Regs.ETPS.bit.SOCPSSEL              = 1U;          -- EPWM3SOC Period Select\r\n       EPwm3Regs.ETSOCPS.bit.SOCAPRD2           = 1U;\r\n       EPwm3Regs.ETSEL.bit.SOCBEN               = 0U;          -- Start of Conversion B Enable\r\n       EPwm3Regs.ETSEL.bit.SOCBSELCMP           = 0U;\r\n       EPwm3Regs.ETSEL.bit.SOCBSEL              = 1U;          -- Start of Conversion A Select\r\n       EPwm3Regs.ETPS.bit.SOCPSSEL              = 1;          -- EPWM3SOCB Period Select\r\n       EPwm3Regs.ETSOCPS.bit.SOCBPRD2           = 1U;\r\n       EPwm3Regs.ETSEL.bit.INTEN                = 0U;          -- EPWM3INTn Enable\r\n       EPwm3Regs.ETSEL.bit.INTSELCMP            = 0U;\r\n       EPwm3Regs.ETSEL.bit.INTSEL               = 1U;          -- Start of Conversion A Select\r\n       EPwm3Regs.ETPS.bit.INTPSSEL              = 1U;          // EPWM3INTn Period Select\r\n       EPwm3Regs.ETINTPS.bit.INTPRD2            = 1U;\r\n     */\r\n    EPwm3Regs.ETSEL.all = (EPwm3Regs.ETSEL.all & ~0xFF7FU) | 0x1201U;\r\n    EPwm3Regs.ETPS.all = (EPwm3Regs.ETPS.all & ~0x30U) | 0x30U;\r\n    EPwm3Regs.ETSOCPS.all = (EPwm3Regs.ETSOCPS.all & ~0xF0FU) | 0x101U;\r\n    EPwm3Regs.ETINTPS.all = (EPwm3Regs.ETINTPS.all & ~0xFU) | 0x1U;\r\n\r\n    /*-- Setup PWM-Chopper (PC) Submodule --*/\r\n    /*\t-- PWM Chopper Control Register\r\n       EPwm3Regs.PCCTL.bit.CHPEN                = 0U;          -- PWM chopping enable\r\n       EPwm3Regs.PCCTL.bit.CHPFREQ              = 0U;          -- Chopping clock frequency\r\n       EPwm3Regs.PCCTL.bit.OSHTWTH              = 0U;          -- One-shot pulse width\r\n       EPwm3Regs.PCCTL.bit.CHPDUTY              = 0U;          -- Chopping clock Duty cycle\r\n     */\r\n    EPwm3Regs.PCCTL.all = (EPwm3Regs.PCCTL.all & ~0x7FFU) | 0x0U;\r\n\r\n    /*-- Set up Trip-Zone (TZ) Submodule --*/\r\n    EALLOW;\r\n    EPwm3Regs.TZSEL.all = 0U;          // Trip Zone Select Register\r\n\r\n    /*\t-- Trip Zone Control Register\r\n       EPwm3Regs.TZCTL.bit.TZA                  = 3U;          -- TZ1 to TZ6 Trip Action On EPWM3A\r\n       EPwm3Regs.TZCTL.bit.TZB                  = 3U;          -- TZ1 to TZ6 Trip Action On EPWM3B\r\n       EPwm3Regs.TZCTL.bit.DCAEVT1              = 3U;          -- EPWM3A action on DCAEVT1\r\n       EPwm3Regs.TZCTL.bit.DCAEVT2              = 3U;          -- EPWM3A action on DCAEVT2\r\n       EPwm3Regs.TZCTL.bit.DCBEVT1              = 3U;          -- EPWM3B action on DCBEVT1\r\n       EPwm3Regs.TZCTL.bit.DCBEVT2              = 3U;          -- EPWM3B action on DCBEVT2\r\n     */\r\n    EPwm3Regs.TZCTL.all = (EPwm3Regs.TZCTL.all & ~0xFFFU) | 0xFFFU;\r\n\r\n    /*\t-- Trip Zone Enable Interrupt Register\r\n       EPwm3Regs.TZEINT.bit.OST                 = 0U;          -- Trip Zones One Shot Int Enable\r\n       EPwm3Regs.TZEINT.bit.CBC                 = 0U;          -- Trip Zones Cycle By Cycle Int Enable\r\n       EPwm3Regs.TZEINT.bit.DCAEVT1             = 0U;          -- Digital Compare A Event 1 Int Enable\r\n       EPwm3Regs.TZEINT.bit.DCAEVT2             = 0U;          -- Digital Compare A Event 2 Int Enable\r\n       EPwm3Regs.TZEINT.bit.DCBEVT1             = 0U;          -- Digital Compare B Event 1 Int Enable\r\n       EPwm3Regs.TZEINT.bit.DCBEVT2             = 0U;          -- Digital Compare B Event 2 Int Enable\r\n     */\r\n    EPwm3Regs.TZEINT.all = (EPwm3Regs.TZEINT.all & ~0x7EU) | 0x0U;\r\n\r\n    /*\t-- Digital Compare A Control Register\r\n       EPwm3Regs.DCACTL.bit.EVT1SYNCE           = 0U;          -- DCAEVT1 SYNC Enable\r\n       EPwm3Regs.DCACTL.bit.EVT1SOCE            = 1U;          -- DCAEVT1 SOC Enable\r\n       EPwm3Regs.DCACTL.bit.EVT1FRCSYNCSEL      = 0U;          -- DCAEVT1 Force Sync Signal\r\n       EPwm3Regs.DCACTL.bit.EVT1SRCSEL          = 0U;          -- DCAEVT1 Source Signal\r\n       EPwm3Regs.DCACTL.bit.EVT2FRCSYNCSEL      = 0U;          -- DCAEVT2 Force Sync Signal\r\n       EPwm3Regs.DCACTL.bit.EVT2SRCSEL          = 0U;          -- DCAEVT2 Source Signal\r\n     */\r\n    EPwm3Regs.DCACTL.all = (EPwm3Regs.DCACTL.all & ~0x30FU) | 0x4U;\r\n\r\n    /*\t-- Digital Compare B Control Register\r\n       EPwm3Regs.DCBCTL.bit.EVT1SYNCE           = 0U;          -- DCBEVT1 SYNC Enable\r\n       EPwm3Regs.DCBCTL.bit.EVT1SOCE            = 0U;          -- DCBEVT1 SOC Enable\r\n       EPwm3Regs.DCBCTL.bit.EVT1FRCSYNCSEL      = 0U;          -- DCBEVT1 Force Sync Signal\r\n       EPwm3Regs.DCBCTL.bit.EVT1SRCSEL          = 0U;          -- DCBEVT1 Source Signal\r\n       EPwm3Regs.DCBCTL.bit.EVT2FRCSYNCSEL      = 0U;          -- DCBEVT2 Force Sync Signal\r\n       EPwm3Regs.DCBCTL.bit.EVT2SRCSEL          = 0U;          -- DCBEVT2 Source Signal\r\n     */\r\n    EPwm3Regs.DCBCTL.all = (EPwm3Regs.DCBCTL.all & ~0x30FU) | 0x0U;\r\n\r\n    /*\t-- Digital Compare Trip Select Register\r\n       EPwm3Regs.DCTRIPSEL.bit.DCAHCOMPSEL      = 0U;          -- Digital Compare A High COMP Input Select\r\n\r\n       EPwm3Regs.DCTRIPSEL.bit.DCALCOMPSEL      = 1U;          -- Digital Compare A Low COMP Input Select\r\n       EPwm3Regs.DCTRIPSEL.bit.DCBHCOMPSEL      = 0U;          -- Digital Compare B High COMP Input Select\r\n       EPwm3Regs.DCTRIPSEL.bit.DCBLCOMPSEL      = 1U;          -- Digital Compare B Low COMP Input Select\r\n     */\r\n    EPwm3Regs.DCTRIPSEL.all = (EPwm3Regs.DCTRIPSEL.all & ~ 0xFFFFU) | 0x1010U;\r\n\r\n    /*\t-- Trip Zone Digital Comparator Select Register\r\n       EPwm3Regs.TZDCSEL.bit.DCAEVT1            = 0U;          -- Digital Compare Output A Event 1\r\n       EPwm3Regs.TZDCSEL.bit.DCAEVT2            = 0U;          -- Digital Compare Output A Event 2\r\n       EPwm3Regs.TZDCSEL.bit.DCBEVT1            = 0U;          -- Digital Compare Output B Event 1\r\n       EPwm3Regs.TZDCSEL.bit.DCBEVT2            = 0U;          -- Digital Compare Output B Event 2\r\n     */\r\n    EPwm3Regs.TZDCSEL.all = (EPwm3Regs.TZDCSEL.all & ~0xFFFU) | 0x0U;\r\n\r\n    /*\t-- Digital Compare Filter Control Register\r\n       EPwm3Regs.DCFCTL.bit.BLANKE              = 0U;          -- Blanking Enable/Disable\r\n       EPwm3Regs.DCFCTL.bit.PULSESEL            = 1U;          -- Pulse Select for Blanking & Capture Alignment\r\n       EPwm3Regs.DCFCTL.bit.BLANKINV            = 0U;          -- Blanking Window Inversion\r\n       EPwm3Regs.DCFCTL.bit.SRCSEL              = 0U;          -- Filter Block Signal Source Select\r\n     */\r\n    EPwm3Regs.DCFCTL.all = (EPwm3Regs.DCFCTL.all & ~0x3FU) | 0x10U;\r\n    EPwm3Regs.DCFOFFSET = 0U;          // Digital Compare Filter Offset Register\r\n    EPwm3Regs.DCFWINDOW = 0U;          // Digital Compare Filter Window Register\r\n\r\n    /*\t-- Digital Compare Capture Control Register\r\n       EPwm3Regs.DCCAPCTL.bit.CAPE              = 0U;          -- Counter Capture Enable\r\n     */\r\n    EPwm3Regs.DCCAPCTL.all = (EPwm3Regs.DCCAPCTL.all & ~0x1U) | 0x0U;\r\n\r\n    /*\t-- HRPWM Configuration Register\r\n       EPwm3Regs.HRCNFG.bit.SWAPAB              = 0U;          -- Swap EPWMA and EPWMB Outputs Bit\r\n       EPwm3Regs.HRCNFG.bit.SELOUTB             = 0U;          -- EPWMB Output Selection Bit\r\n     */\r\n    EPwm3Regs.HRCNFG.all = (EPwm3Regs.HRCNFG.all & ~0xA0U) | 0x0U;\r\n\r\n    /* Update the Link Registers with the link value for all the Compare values and TBPRD */\r\n    /* No error is thrown if the ePWM register exists in the model or not */\r\n    EPwm3Regs.EPWMXLINK.bit.TBPRDLINK = 2U;\r\n    EPwm3Regs.EPWMXLINK.bit.CMPALINK = 2U;\r\n    EPwm3Regs.EPWMXLINK.bit.CMPBLINK = 2U;\r\n    EPwm3Regs.EPWMXLINK.bit.CMPCLINK = 2U;\r\n    EPwm3Regs.EPWMXLINK.bit.CMPDLINK = 2U;\r\n\r\n    /* SYNCPER - Peripheral synchronization output event\r\n       EPwm3Regs.HRPCTL.bit.PWMSYNCSEL            = 0U;          -- EPWMSYNCPER selection\r\n       EPwm3Regs.HRPCTL.bit.PWMSYNCSELX           = 0U;          --  EPWMSYNCPER selection\r\n     */\r\n    EPwm3Regs.HRPCTL.all = (EPwm3Regs.HRPCTL.all & ~0x72U) | 0x0U;\r\n    EDIS;\r\n  }\r\n\r\n  /* InitializeConditions for Delay: '<S197>/Delay' */\r\n  mcb_pmsm_foc_qep_f28379d_DW.CircBufIdx = 0U;\r\n\r\n  /* SystemInitialize for Enabled SubSystem: '<S8>/Closed Loop Control' */\r\n  /* Start for Constant: '<S27>/Kp1' */\r\n  mcb_pmsm_foc_qep_f28379d_B.Kp1 = 0.0F;\r\n\r\n  /* Start for Constant: '<S26>/Ki1' */\r\n  mcb_pmsm_foc_qep_f28379d_B.Ki1 = 0.0F;\r\n\r\n  /* InitializeConditions for DiscreteIntegrator: '<S134>/Integrator' */\r\n  mcb_pmsm_foc_qep_f28379d_DW.Integrator_DSTATE = 0.0F;\r\n  mcb_pmsm_foc_qep_f28379d_DW.Integrator_PrevResetState = 0;\r\n\r\n  /* InitializeConditions for DiscreteIntegrator: '<S79>/Integrator' */\r\n  mcb_pmsm_foc_qep_f28379d_DW.Integrator_DSTATE_o = 0.0F;\r\n  mcb_pmsm_foc_qep_f28379d_DW.Integrator_PrevResetState_k = 0;\r\n\r\n  /* End of SystemInitialize for SubSystem: '<S8>/Closed Loop Control' */\r\n}\r\n\r\n/* System reset for function-call system: '<Root>/Current Control' */\r\nvoid mcb_pm_CurrentControl_Reset(void)\r\n{\r\n  /* InitializeConditions for Delay: '<S197>/Delay' */\r\n  mcb_pmsm_foc_qep_f28379d_DW.CircBufIdx = 0U;\r\n}\r\n\r\n/* Disable for function-call system: '<Root>/Current Control' */\r\n#pragma CODE_SECTION (mcb__CurrentControl_Disable, \"ramfuncs\")\r\n\r\nvoid mcb__CurrentControl_Disable(void)\r\n{\r\n  /* Disable for Enabled SubSystem: '<S8>/Open Loop Start-Up' */\r\n  if (mcb_pmsm_foc_qep_f28379d_DW.OpenLoopStartUp_MODE) {\r\n    /* Disable for DiscreteIntegrator: '<S173>/Ramp Generator' */\r\n    mcb_pmsm_foc_qep_f28379d_DW.RampGenerator_DSTATE =\r\n      mcb_pmsm_foc_qep_f28379d_B.Eps;\r\n    mcb_pmsm_foc_qep_f28379d_DW.OpenLoopStartUp_MODE = false;\r\n  }\r\n\r\n  /* End of Disable for SubSystem: '<S8>/Open Loop Start-Up' */\r\n}\r\n\r\n/* Output and update for function-call system: '<Root>/Current Control' */\r\n#pragma CODE_SECTION (mcb_pmsm_foc_CurrentControl, \"ramfuncs\")\r\n\r\nvoid mcb_pmsm_foc_CurrentControl(void)\r\n{\r\n  real32_T Bias;\r\n  real32_T u0_0;\r\n  uint32_T Sum_e;\r\n  int16_T s227_iter;\r\n  uint16_T u0;\r\n  uint16_T u1;\r\n\r\n  /* S-Function (c280xqep): '<S190>/eQEP' */\r\n  {\r\n    mcb_pmsm_foc_qep_f28379d_B.eQEP_o1 = EQep1Regs.QPOSCNT;/*eQEP Position Counter*/\r\n    mcb_pmsm_foc_qep_f28379d_B.eQEP_o2 = EQep1Regs.QPOSILAT;\r\n         /* The position-counter value is latched into this register on an IEL*/\r\n  }\r\n\r\n  /* Delay: '<S191>/Delay' */\r\n  mcb_pmsm_foc_qep_f28379d_B.Delay_p =\r\n    mcb_pmsm_foc_qep_f28379d_DW.Delay_DSTATE_m;\r\n\r\n  /* Logic: '<S191>/NOT' */\r\n  mcb_pmsm_foc_qep_f28379d_B.NOT_m = !mcb_pmsm_foc_qep_f28379d_B.Delay_p;\r\n\r\n  /* Outputs for Enabled SubSystem: '<S191>/IndexFinder' incorporates:\r\n   *  EnablePort: '<S194>/Enable'\r\n   */\r\n  if (mcb_pmsm_foc_qep_f28379d_B.NOT_m) {\r\n    /* Delay: '<S194>/Delay3' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Delay3 =\r\n      mcb_pmsm_foc_qep_f28379d_DW.Delay3_DSTATE;\r\n\r\n    /* RelationalOperator: '<S201>/Compare' incorporates:\r\n     *  Constant: '<S201>/Constant'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Compare = (mcb_pmsm_foc_qep_f28379d_B.Delay3 ==\r\n      0U);\r\n\r\n    /* RelationalOperator: '<S202>/Compare' incorporates:\r\n     *  Constant: '<S202>/Constant'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Compare_e = (mcb_pmsm_foc_qep_f28379d_B.eQEP_o2 >\r\n      0U);\r\n\r\n    /* Logic: '<S194>/AND' */\r\n    mcb_pmsm_foc_qep_f28379d_B.AND = (mcb_pmsm_foc_qep_f28379d_B.Compare &&\r\n      mcb_pmsm_foc_qep_f28379d_B.Compare_e);\r\n\r\n    /* Update for Delay: '<S194>/Delay3' */\r\n    mcb_pmsm_foc_qep_f28379d_DW.Delay3_DSTATE =\r\n      mcb_pmsm_foc_qep_f28379d_B.eQEP_o2;\r\n  }\r\n\r\n  /* End of Outputs for SubSystem: '<S191>/IndexFinder' */\r\n\r\n  /* DataStoreWrite: '<S8>/Data Store Write' */\r\n  mcb_pmsm_foc_qep_f28379d_DW.EnClosedLoop = mcb_pmsm_foc_qep_f28379d_B.AND;\r\n\r\n  /* DataStoreRead: '<S192>/Data Store Read1' */\r\n  mcb_pmsm_foc_qep_f28379d_B.DataStoreRead1 =\r\n    mcb_pmsm_foc_qep_f28379d_DW.IaOffset;\r\n\r\n  /* DataStoreRead: '<S192>/Data Store Read2' */\r\n  mcb_pmsm_foc_qep_f28379d_B.DataStoreRead2 =\r\n    mcb_pmsm_foc_qep_f28379d_DW.IbOffset;\r\n\r\n  /* S-Function (c2802xadc): '<S190>/ADC_C_IN2' */\r\n  {\r\n    /*  Internal Reference Voltage : Fixed scale 0 to 3.3 V range.  */\r\n    /*  External Reference Voltage : Allowable ranges of VREFHI(ADCINA0) = 3.3 and VREFLO(tied to ground) = 0  */\r\n    mcb_pmsm_foc_qep_f28379d_B.ADC_C_IN2 = (AdccResultRegs.ADCRESULT0);\r\n  }\r\n\r\n  /* S-Function (c2802xadc): '<S190>/ADC_B_IN2' */\r\n  {\r\n    /*  Internal Reference Voltage : Fixed scale 0 to 3.3 V range.  */\r\n    /*  External Reference Voltage : Allowable ranges of VREFHI(ADCINA0) = 3.3 and VREFLO(tied to ground) = 0  */\r\n    mcb_pmsm_foc_qep_f28379d_B.ADC_B_IN2 = (AdcbResultRegs.ADCRESULT0);\r\n  }\r\n\r\n  /* DataTypeConversion: '<S192>/Data Type Conversion' */\r\n  mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion_c[0] =\r\n    mcb_pmsm_foc_qep_f28379d_B.ADC_C_IN2;\r\n  mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion_c[1] =\r\n    mcb_pmsm_foc_qep_f28379d_B.ADC_B_IN2;\r\n\r\n  /* Sum: '<S192>/Add' */\r\n  mcb_pmsm_foc_qep_f28379d_B.Add_e[0] =\r\n    mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion_c[0] -\r\n    mcb_pmsm_foc_qep_f28379d_B.DataStoreRead1;\r\n  mcb_pmsm_foc_qep_f28379d_B.Add_e[1] =\r\n    mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion_c[1] -\r\n    mcb_pmsm_foc_qep_f28379d_B.DataStoreRead2;\r\n\r\n  /* Gain: '<S222>/Get ADC Voltage' */\r\n  Bias = 0.000732600747F * (real32_T)mcb_pmsm_foc_qep_f28379d_B.Add_e[0];\r\n  mcb_pmsm_foc_qep_f28379d_B.GetADCVoltage[0] = Bias;\r\n\r\n  /* Gain: '<S222>/Get Currents' */\r\n  Bias *= 14.2857141F;\r\n  mcb_pmsm_foc_qep_f28379d_B.GetCurrents[0] = Bias;\r\n\r\n  /* Gain: '<S222>/PU_Conversion' */\r\n  mcb_pmsm_foc_qep_f28379d_B.PU_Conversion[0] = 0.0466666669F * Bias;\r\n\r\n  /* Gain: '<S222>/Get ADC Voltage' */\r\n  Bias = 0.000732600747F * (real32_T)mcb_pmsm_foc_qep_f28379d_B.Add_e[1];\r\n  mcb_pmsm_foc_qep_f28379d_B.GetADCVoltage[1] = Bias;\r\n\r\n  /* Gain: '<S222>/Get Currents' */\r\n  Bias *= 14.2857141F;\r\n  mcb_pmsm_foc_qep_f28379d_B.GetCurrents[1] = Bias;\r\n\r\n  /* Gain: '<S222>/PU_Conversion' */\r\n  mcb_pmsm_foc_qep_f28379d_B.PU_Conversion[1] = 0.0466666669F * Bias;\r\n\r\n  /* Outputs for IfAction SubSystem: '<S196>/PositionNoReset' incorporates:\r\n   *  ActionPort: '<S212>/Action Port'\r\n   */\r\n  /* If: '<S196>/If1' incorporates:\r\n   *  Constant: '<S217>/Constant'\r\n   *  Merge: '<S196>/Merge'\r\n   *  MinMax: '<S212>/MinMax'\r\n   *  Sum: '<S212>/Sum3'\r\n   *  Sum: '<S212>/Sum7'\r\n   */\r\n  mcb_pmsm_foc_qep_f28379d_B.Sum3_a = mcb_pmsm_foc_qep_f28379d_B.eQEP_o1 -\r\n    mcb_pmsm_foc_qep_f28379d_B.eQEP_o2;\r\n  mcb_pmsm_foc_qep_f28379d_B.Sum7 = mcb_pmsm_foc_qep_f28379d_B.Sum3_a + 4000U;\r\n  u0 = mcb_pmsm_foc_qep_f28379d_B.Sum3_a;\r\n  u1 = mcb_pmsm_foc_qep_f28379d_B.Sum7;\r\n  if (u0 <= u1) {\r\n    u1 = u0;\r\n  }\r\n\r\n  mcb_pmsm_foc_qep_f28379d_B.Merge_h5 = u1;\r\n\r\n  /* End of If: '<S196>/If1' */\r\n  /* End of Outputs for SubSystem: '<S196>/PositionNoReset' */\r\n\r\n  /* DataTypeConversion: '<S215>/DTC' */\r\n  mcb_pmsm_foc_qep_f28379d_B.DTC = mcb_pmsm_foc_qep_f28379d_B.Merge_h5;\r\n\r\n  /* Product: '<S196>/Product' incorporates:\r\n   *  Constant: '<S218>/Constant'\r\n   */\r\n  mcb_pmsm_foc_qep_f28379d_B.Product = mcb_pmsm_foc_qep_f28379d_B.DTC * 0.00025F;\r\n\r\n  /* Switch: '<S204>/Switch' incorporates:\r\n   *  Constant: '<S11>/IndexOffset'\r\n   */\r\n  mcb_pmsm_foc_qep_f28379d_B.Switch = 0.0765F;\r\n\r\n  /* If: '<S205>/If' */\r\n  if (mcb_pmsm_foc_qep_f28379d_B.Product <= 0.0765F) {\r\n    /* Outputs for IfAction SubSystem: '<S205>/If Action Subsystem' incorporates:\r\n     *  ActionPort: '<S207>/Action Port'\r\n     */\r\n    /* Merge: '<S205>/Merge' incorporates:\r\n     *  Constant: '<S207>/Constant'\r\n     *  Sum: '<S207>/Add'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Merge = (mcb_pmsm_foc_qep_f28379d_B.Product +\r\n      1.0F) - 0.0765F;\r\n\r\n    /* End of Outputs for SubSystem: '<S205>/If Action Subsystem' */\r\n  } else {\r\n    /* Outputs for IfAction SubSystem: '<S205>/If Action Subsystem1' incorporates:\r\n     *  ActionPort: '<S208>/Action Port'\r\n     */\r\n    /* Merge: '<S205>/Merge' incorporates:\r\n     *  Sum: '<S208>/Add'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Merge = mcb_pmsm_foc_qep_f28379d_B.Product -\r\n      0.0765F;\r\n\r\n    /* End of Outputs for SubSystem: '<S205>/If Action Subsystem1' */\r\n  }\r\n\r\n  /* End of If: '<S205>/If' */\r\n\r\n  /* Gain: '<S210>/Number of pole pairs' */\r\n  mcb_pmsm_foc_qep_f28379d_B.Numberofpolepairs = 4.0F *\r\n    mcb_pmsm_foc_qep_f28379d_B.Merge;\r\n\r\n  /* Rounding: '<S206>/Floor' */\r\n  mcb_pmsm_foc_qep_f28379d_B.Floor = (real32_T)floor\r\n    (mcb_pmsm_foc_qep_f28379d_B.Numberofpolepairs);\r\n\r\n  /* Sum: '<S206>/Add' */\r\n  mcb_pmsm_foc_qep_f28379d_B.Add_c =\r\n    mcb_pmsm_foc_qep_f28379d_B.Numberofpolepairs -\r\n    mcb_pmsm_foc_qep_f28379d_B.Floor;\r\n\r\n  /* Outputs for Enabled SubSystem: '<S8>/Closed Loop Control' incorporates:\r\n   *  EnablePort: '<S15>/Enable'\r\n   */\r\n  if (mcb_pmsm_foc_qep_f28379d_B.AND) {\r\n    /* Outputs for Atomic SubSystem: '<S23>/Two phase CRL wrap' */\r\n    /* Sum: '<S24>/a_plus_2b' */\r\n    mcb_pmsm_foc_qep_f28379d_B.a_plus_2b =\r\n      (mcb_pmsm_foc_qep_f28379d_B.PU_Conversion[0] +\r\n       mcb_pmsm_foc_qep_f28379d_B.PU_Conversion[1]) +\r\n      mcb_pmsm_foc_qep_f28379d_B.PU_Conversion[1];\r\n\r\n    /* Gain: '<S24>/one_by_sqrt3' */\r\n    mcb_pmsm_foc_qep_f28379d_B.one_by_sqrt3 = 0.577350259F *\r\n      mcb_pmsm_foc_qep_f28379d_B.a_plus_2b;\r\n\r\n    /* AlgorithmDescriptorDelegate generated from: '<S24>/a16' */\r\n    mcb_pmsm_foc_qep_f28379d_B.algDD_o1_e =\r\n      mcb_pmsm_foc_qep_f28379d_B.PU_Conversion[0];\r\n\r\n    /* AlgorithmDescriptorDelegate generated from: '<S24>/a16' */\r\n    mcb_pmsm_foc_qep_f28379d_B.algDD_o2_h =\r\n      mcb_pmsm_foc_qep_f28379d_B.one_by_sqrt3;\r\n\r\n    /* End of Outputs for SubSystem: '<S23>/Two phase CRL wrap' */\r\n\r\n    /* Switch: '<S30>/Switch1' incorporates:\r\n     *  Constant: '<S30>/ChosenMethod'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch1_jb = 3U;\r\n\r\n    /* SignalConversion generated from: '<S15>/Idq_ref_PU' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Idq_ref_PU[0] = mcb_pmsm_foc_qep_f28379d_B.RT2[0];\r\n    mcb_pmsm_foc_qep_f28379d_B.Idq_ref_PU[1] = mcb_pmsm_foc_qep_f28379d_B.RT2[1];\r\n\r\n    /* RelationalOperator: '<S160>/Compare' incorporates:\r\n     *  Constant: '<S160>/Constant'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Compare_d = (mcb_pmsm_foc_qep_f28379d_B.Add_c <\r\n      0.0F);\r\n\r\n    /* DataTypeConversion: '<S158>/Data Type Conversion' */\r\n    mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion_p =\r\n      mcb_pmsm_foc_qep_f28379d_B.Compare_d;\r\n\r\n    /* If: '<S158>/If' */\r\n    if (mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion_p > 0U) {\r\n      /* Outputs for IfAction SubSystem: '<S158>/If Action Subsystem' incorporates:\r\n       *  ActionPort: '<S161>/Action Port'\r\n       */\r\n      mcb_pmsm__IfActionSubsystem(mcb_pmsm_foc_qep_f28379d_B.Add_c,\r\n        &mcb_pmsm_foc_qep_f28379d_B.Merge_b,\r\n        &mcb_pmsm_foc_qep_f28379d_B.IfActionSubsystem_m);\r\n\r\n      /* End of Outputs for SubSystem: '<S158>/If Action Subsystem' */\r\n    } else {\r\n      /* Outputs for IfAction SubSystem: '<S158>/If Action Subsystem1' incorporates:\r\n       *  ActionPort: '<S162>/Action Port'\r\n       */\r\n      mcb_pmsm_IfActionSubsystem1(mcb_pmsm_foc_qep_f28379d_B.Add_c,\r\n        &mcb_pmsm_foc_qep_f28379d_B.Merge_b,\r\n        &mcb_pmsm_foc_qep_f28379d_B.IfActionSubsystem1_m);\r\n\r\n      /* End of Outputs for SubSystem: '<S158>/If Action Subsystem1' */\r\n    }\r\n\r\n    /* End of If: '<S158>/If' */\r\n\r\n    /* Gain: '<S156>/indexing' */\r\n    mcb_pmsm_foc_qep_f28379d_B.indexing_n = 800.0F *\r\n      mcb_pmsm_foc_qep_f28379d_B.Merge_b;\r\n\r\n    /* DataTypeConversion: '<S156>/Get_Integer' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Get_Integer_l = (uint16_T)\r\n      mcb_pmsm_foc_qep_f28379d_B.indexing_n;\r\n\r\n    /* Sum: '<S156>/Sum' incorporates:\r\n     *  Constant: '<S156>/offset'\r\n     */\r\n    Sum_e = mcb_pmsm_foc_qep_f28379d_B.Get_Integer_l + 1UL;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum_e[0] = Sum_e;\r\n\r\n    /* Selector: '<S156>/Lookup' incorporates:\r\n     *  Constant: '<S156>/sine_table_values'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Lookup_p[0] =\r\n      mcb_pmsm_foc_qep_f28379d_ConstP.pooled5[(int16_T)Sum_e];\r\n\r\n    /* Sum: '<S156>/Sum' */\r\n    Sum_e = mcb_pmsm_foc_qep_f28379d_B.Get_Integer_l;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum_e[1] = Sum_e;\r\n\r\n    /* Selector: '<S156>/Lookup' incorporates:\r\n     *  Constant: '<S156>/sine_table_values'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Lookup_p[1] =\r\n      mcb_pmsm_foc_qep_f28379d_ConstP.pooled5[(int16_T)Sum_e];\r\n\r\n    /* Sum: '<S156>/Sum' incorporates:\r\n     *  Constant: '<S156>/offset'\r\n     */\r\n    Sum_e = mcb_pmsm_foc_qep_f28379d_B.Get_Integer_l + 201UL;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum_e[2] = Sum_e;\r\n\r\n    /* Selector: '<S156>/Lookup' incorporates:\r\n     *  Constant: '<S156>/sine_table_values'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Lookup_p[2] =\r\n      mcb_pmsm_foc_qep_f28379d_ConstP.pooled5[(int16_T)Sum_e];\r\n\r\n    /* Sum: '<S156>/Sum' incorporates:\r\n     *  Constant: '<S156>/offset'\r\n     */\r\n    Sum_e = mcb_pmsm_foc_qep_f28379d_B.Get_Integer_l + 200UL;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum_e[3] = Sum_e;\r\n\r\n    /* Selector: '<S156>/Lookup' incorporates:\r\n     *  Constant: '<S156>/sine_table_values'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Lookup_p[3] =\r\n      mcb_pmsm_foc_qep_f28379d_ConstP.pooled5[(int16_T)Sum_e];\r\n\r\n    /* Sum: '<S157>/Sum3' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum3_p = mcb_pmsm_foc_qep_f28379d_B.Lookup_p[0] -\r\n      mcb_pmsm_foc_qep_f28379d_B.Lookup_p[1];\r\n\r\n    /* DataTypeConversion: '<S156>/Data Type Conversion1' */\r\n    mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion1_h =\r\n      mcb_pmsm_foc_qep_f28379d_B.Get_Integer_l;\r\n\r\n    /* Sum: '<S156>/Sum2' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum2_j = mcb_pmsm_foc_qep_f28379d_B.indexing_n -\r\n      mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion1_h;\r\n\r\n    /* Product: '<S157>/Product' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Product_n = mcb_pmsm_foc_qep_f28379d_B.Sum3_p *\r\n      mcb_pmsm_foc_qep_f28379d_B.Sum2_j;\r\n\r\n    /* Sum: '<S157>/Sum4' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum4_l = mcb_pmsm_foc_qep_f28379d_B.Product_n +\r\n      mcb_pmsm_foc_qep_f28379d_B.Lookup_p[1];\r\n\r\n    /* Sum: '<S157>/Sum5' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum5_j = mcb_pmsm_foc_qep_f28379d_B.Lookup_p[2] -\r\n      mcb_pmsm_foc_qep_f28379d_B.Lookup_p[3];\r\n\r\n    /* Product: '<S157>/Product1' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Product1_g = mcb_pmsm_foc_qep_f28379d_B.Sum5_j *\r\n      mcb_pmsm_foc_qep_f28379d_B.Sum2_j;\r\n\r\n    /* Sum: '<S157>/Sum6' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum6_a = mcb_pmsm_foc_qep_f28379d_B.Product1_g +\r\n      mcb_pmsm_foc_qep_f28379d_B.Lookup_p[3];\r\n\r\n    /* Outputs for Atomic SubSystem: '<S20>/Two inputs CRL' */\r\n    /* Product: '<S154>/acos' */\r\n    mcb_pmsm_foc_qep_f28379d_B.acos_b = mcb_pmsm_foc_qep_f28379d_B.algDD_o1_e *\r\n      mcb_pmsm_foc_qep_f28379d_B.Sum6_a;\r\n\r\n    /* Product: '<S154>/bsin' */\r\n    mcb_pmsm_foc_qep_f28379d_B.bsin = mcb_pmsm_foc_qep_f28379d_B.algDD_o2_h *\r\n      mcb_pmsm_foc_qep_f28379d_B.Sum4_l;\r\n\r\n    /* Sum: '<S154>/sum_Ds' */\r\n    mcb_pmsm_foc_qep_f28379d_B.sum_Ds = mcb_pmsm_foc_qep_f28379d_B.acos_b +\r\n      mcb_pmsm_foc_qep_f28379d_B.bsin;\r\n\r\n    /* Product: '<S154>/bcos' */\r\n    mcb_pmsm_foc_qep_f28379d_B.bcos = mcb_pmsm_foc_qep_f28379d_B.algDD_o2_h *\r\n      mcb_pmsm_foc_qep_f28379d_B.Sum6_a;\r\n\r\n    /* Product: '<S154>/asin' */\r\n    mcb_pmsm_foc_qep_f28379d_B.asin_o = mcb_pmsm_foc_qep_f28379d_B.algDD_o1_e *\r\n      mcb_pmsm_foc_qep_f28379d_B.Sum4_l;\r\n\r\n    /* Sum: '<S154>/sum_Qs' */\r\n    mcb_pmsm_foc_qep_f28379d_B.sum_Qs = mcb_pmsm_foc_qep_f28379d_B.bcos -\r\n      mcb_pmsm_foc_qep_f28379d_B.asin_o;\r\n\r\n    /* Switch: '<S155>/Switch' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch_h[0] = mcb_pmsm_foc_qep_f28379d_B.sum_Ds;\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch_h[1] = mcb_pmsm_foc_qep_f28379d_B.sum_Qs;\r\n\r\n    /* AlgorithmDescriptorDelegate generated from: '<S154>/a16' */\r\n    mcb_pmsm_foc_qep_f28379d_B.algDD_o1 = mcb_pmsm_foc_qep_f28379d_B.Switch_h[0];\r\n\r\n    /* AlgorithmDescriptorDelegate generated from: '<S154>/a16' */\r\n    mcb_pmsm_foc_qep_f28379d_B.algDD_o2 = mcb_pmsm_foc_qep_f28379d_B.Switch_h[1];\r\n\r\n    /* End of Outputs for SubSystem: '<S20>/Two inputs CRL' */\r\n\r\n    /* Sum: '<S27>/Sum' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum_o = mcb_pmsm_foc_qep_f28379d_B.Idq_ref_PU[1]\r\n      - mcb_pmsm_foc_qep_f28379d_B.algDD_o2;\r\n\r\n    /* Product: '<S139>/PProd Out' incorporates:\r\n     *  Constant: '<S27>/Kp'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.PProdOut = mcb_pmsm_foc_qep_f28379d_B.Sum_o *\r\n      3.09294796F;\r\n\r\n    /* DataStoreRead: '<S27>/Data Store Read1' */\r\n    mcb_pmsm_foc_qep_f28379d_B.DataStoreRead1_b =\r\n      mcb_pmsm_foc_qep_f28379d_DW.Enable;\r\n\r\n    /* Logic: '<S27>/Logical Operator' */\r\n    mcb_pmsm_foc_qep_f28379d_B.LogicalOperator =\r\n      !mcb_pmsm_foc_qep_f28379d_B.DataStoreRead1_b;\r\n\r\n    /* Constant: '<S27>/Kp1' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Kp1 = 0.0F;\r\n\r\n    /* DiscreteIntegrator: '<S134>/Integrator' */\r\n    if (mcb_pmsm_foc_qep_f28379d_B.LogicalOperator ||\r\n        (mcb_pmsm_foc_qep_f28379d_DW.Integrator_PrevResetState != 0)) {\r\n      mcb_pmsm_foc_qep_f28379d_DW.Integrator_DSTATE = 0.0F;\r\n    }\r\n\r\n    /* DiscreteIntegrator: '<S134>/Integrator' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Integrator =\r\n      mcb_pmsm_foc_qep_f28379d_DW.Integrator_DSTATE;\r\n\r\n    /* Sum: '<S143>/Sum' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum_m = mcb_pmsm_foc_qep_f28379d_B.PProdOut +\r\n      mcb_pmsm_foc_qep_f28379d_B.Integrator;\r\n\r\n    /* Saturate: '<S141>/Saturation' */\r\n    u0_0 = mcb_pmsm_foc_qep_f28379d_B.Sum_m;\r\n    if (u0_0 > 1.0F) {\r\n      /* Saturate: '<S141>/Saturation' */\r\n      mcb_pmsm_foc_qep_f28379d_B.Saturation = 1.0F;\r\n    } else if (u0_0 < -1.0F) {\r\n      /* Saturate: '<S141>/Saturation' */\r\n      mcb_pmsm_foc_qep_f28379d_B.Saturation = -1.0F;\r\n    } else {\r\n      /* Saturate: '<S141>/Saturation' */\r\n      mcb_pmsm_foc_qep_f28379d_B.Saturation = u0_0;\r\n    }\r\n\r\n    /* End of Saturate: '<S141>/Saturation' */\r\n\r\n    /* Sum: '<S26>/Sum' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum_j = mcb_pmsm_foc_qep_f28379d_B.Idq_ref_PU[0]\r\n      - mcb_pmsm_foc_qep_f28379d_B.algDD_o1;\r\n\r\n    /* Product: '<S84>/PProd Out' incorporates:\r\n     *  Constant: '<S26>/Kp'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.PProdOut_g = mcb_pmsm_foc_qep_f28379d_B.Sum_j *\r\n      3.09294796F;\r\n\r\n    /* DataStoreRead: '<S26>/Data Store Read1' */\r\n    mcb_pmsm_foc_qep_f28379d_B.DataStoreRead1_m =\r\n      mcb_pmsm_foc_qep_f28379d_DW.Enable;\r\n\r\n    /* Logic: '<S26>/Logical Operator' */\r\n    mcb_pmsm_foc_qep_f28379d_B.LogicalOperator_a =\r\n      !mcb_pmsm_foc_qep_f28379d_B.DataStoreRead1_m;\r\n\r\n    /* Constant: '<S26>/Ki1' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Ki1 = 0.0F;\r\n\r\n    /* DiscreteIntegrator: '<S79>/Integrator' */\r\n    if (mcb_pmsm_foc_qep_f28379d_B.LogicalOperator_a ||\r\n        (mcb_pmsm_foc_qep_f28379d_DW.Integrator_PrevResetState_k != 0)) {\r\n      mcb_pmsm_foc_qep_f28379d_DW.Integrator_DSTATE_o = 0.0F;\r\n    }\r\n\r\n    /* DiscreteIntegrator: '<S79>/Integrator' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Integrator_f =\r\n      mcb_pmsm_foc_qep_f28379d_DW.Integrator_DSTATE_o;\r\n\r\n    /* Sum: '<S88>/Sum' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum_g = mcb_pmsm_foc_qep_f28379d_B.PProdOut_g +\r\n      mcb_pmsm_foc_qep_f28379d_B.Integrator_f;\r\n\r\n    /* Saturate: '<S86>/Saturation' */\r\n    u0_0 = mcb_pmsm_foc_qep_f28379d_B.Sum_g;\r\n    if (u0_0 > 1.0F) {\r\n      /* Saturate: '<S86>/Saturation' */\r\n      mcb_pmsm_foc_qep_f28379d_B.Saturation_f = 1.0F;\r\n    } else if (u0_0 < -1.0F) {\r\n      /* Saturate: '<S86>/Saturation' */\r\n      mcb_pmsm_foc_qep_f28379d_B.Saturation_f = -1.0F;\r\n    } else {\r\n      /* Saturate: '<S86>/Saturation' */\r\n      mcb_pmsm_foc_qep_f28379d_B.Saturation_f = u0_0;\r\n    }\r\n\r\n    /* End of Saturate: '<S86>/Saturation' */\r\n\r\n    /* Switch: '<S30>/Switch' incorporates:\r\n     *  Constant: '<S30>/Constant3'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch_n = 0.95F;\r\n\r\n    /* Product: '<S30>/Product' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Product_j = 0.9025F;\r\n\r\n    /* Product: '<S31>/Product' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Product_f =\r\n      mcb_pmsm_foc_qep_f28379d_B.Saturation_f *\r\n      mcb_pmsm_foc_qep_f28379d_B.Saturation_f;\r\n\r\n    /* Product: '<S31>/Product1' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Product1_gr =\r\n      mcb_pmsm_foc_qep_f28379d_B.Saturation *\r\n      mcb_pmsm_foc_qep_f28379d_B.Saturation;\r\n\r\n    /* Sum: '<S31>/Sum1' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum1 = mcb_pmsm_foc_qep_f28379d_B.Product_f +\r\n      mcb_pmsm_foc_qep_f28379d_B.Product1_gr;\r\n\r\n    /* Outputs for IfAction SubSystem: '<S25>/D-Q Equivalence' incorporates:\r\n     *  ActionPort: '<S28>/Action Port'\r\n     */\r\n    /* If: '<S25>/If' incorporates:\r\n     *  DataTypeConversion: '<S28>/Data Type Conversion'\r\n     *  RelationalOperator: '<S28>/Relational Operator'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.RelationalOperator_k =\r\n      (mcb_pmsm_foc_qep_f28379d_B.Sum1 > 0.9025F);\r\n    mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion_f =\r\n      mcb_pmsm_foc_qep_f28379d_B.RelationalOperator_k;\r\n\r\n    /* If: '<S28>/If' incorporates:\r\n     *  If: '<S25>/If'\r\n     */\r\n    if (mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion_f != 0U) {\r\n      /* Outputs for IfAction SubSystem: '<S28>/Limiter' incorporates:\r\n       *  ActionPort: '<S32>/Action Port'\r\n       */\r\n      /* Product: '<S32>/Product' */\r\n      mcb_pmsm_foc_qep_f28379d_B.Product_o[0] =\r\n        mcb_pmsm_foc_qep_f28379d_B.Saturation_f * 0.95F;\r\n      mcb_pmsm_foc_qep_f28379d_B.Product_o[1] =\r\n        mcb_pmsm_foc_qep_f28379d_B.Saturation * 0.95F;\r\n\r\n      /* Sqrt: '<S32>/Square Root' */\r\n      mcb_pmsm_foc_qep_f28379d_B.SquareRoot = (real32_T)sqrt\r\n        (mcb_pmsm_foc_qep_f28379d_B.Sum1);\r\n\r\n      /* Switch: '<S32>/Switch' */\r\n      if (mcb_pmsm_foc_qep_f28379d_B.SquareRoot != 0.0F) {\r\n        /* Switch: '<S32>/Switch' */\r\n        mcb_pmsm_foc_qep_f28379d_B.Switch_as =\r\n          mcb_pmsm_foc_qep_f28379d_B.SquareRoot;\r\n      } else {\r\n        /* Switch: '<S32>/Switch' incorporates:\r\n         *  Constant: '<S32>/Constant'\r\n         */\r\n        mcb_pmsm_foc_qep_f28379d_B.Switch_as = 1.0F;\r\n      }\r\n\r\n      /* End of Switch: '<S32>/Switch' */\r\n\r\n      /* Merge: '<S25>/Merge' incorporates:\r\n       *  Product: '<S32>/Divide'\r\n       */\r\n      mcb_pmsm_foc_qep_f28379d_B.Merge_i[0] =\r\n        mcb_pmsm_foc_qep_f28379d_B.Product_o[0] /\r\n        mcb_pmsm_foc_qep_f28379d_B.Switch_as;\r\n      mcb_pmsm_foc_qep_f28379d_B.Merge_i[1] =\r\n        mcb_pmsm_foc_qep_f28379d_B.Product_o[1] /\r\n        mcb_pmsm_foc_qep_f28379d_B.Switch_as;\r\n\r\n      /* End of Outputs for SubSystem: '<S28>/Limiter' */\r\n    } else {\r\n      /* Outputs for IfAction SubSystem: '<S28>/Passthrough' incorporates:\r\n       *  ActionPort: '<S33>/Action Port'\r\n       */\r\n      /* Merge: '<S25>/Merge' incorporates:\r\n       *  SignalConversion generated from: '<S33>/dqRef'\r\n       */\r\n      mcb_pmsm_foc_qep_f28379d_B.Merge_i[0] =\r\n        mcb_pmsm_foc_qep_f28379d_B.Saturation_f;\r\n      mcb_pmsm_foc_qep_f28379d_B.Merge_i[1] =\r\n        mcb_pmsm_foc_qep_f28379d_B.Saturation;\r\n\r\n      /* End of Outputs for SubSystem: '<S28>/Passthrough' */\r\n    }\r\n\r\n    /* End of If: '<S28>/If' */\r\n    /* End of Outputs for SubSystem: '<S25>/D-Q Equivalence' */\r\n\r\n    /* DeadZone: '<S71>/DeadZone' */\r\n    if (mcb_pmsm_foc_qep_f28379d_B.Sum_g > 1.0F) {\r\n      /* DeadZone: '<S71>/DeadZone' */\r\n      mcb_pmsm_foc_qep_f28379d_B.DeadZone = mcb_pmsm_foc_qep_f28379d_B.Sum_g -\r\n        1.0F;\r\n    } else if (mcb_pmsm_foc_qep_f28379d_B.Sum_g >= -1.0F) {\r\n      /* DeadZone: '<S71>/DeadZone' */\r\n      mcb_pmsm_foc_qep_f28379d_B.DeadZone = 0.0F;\r\n    } else {\r\n      /* DeadZone: '<S71>/DeadZone' */\r\n      mcb_pmsm_foc_qep_f28379d_B.DeadZone = mcb_pmsm_foc_qep_f28379d_B.Sum_g -\r\n        -1.0F;\r\n    }\r\n\r\n    /* End of DeadZone: '<S71>/DeadZone' */\r\n\r\n    /* RelationalOperator: '<S69>/Relational Operator' incorporates:\r\n     *  Constant: '<S69>/Clamping_zero'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.RelationalOperator =\r\n      (mcb_pmsm_foc_qep_f28379d_B.DeadZone != 0.0F);\r\n\r\n    /* RelationalOperator: '<S69>/fix for DT propagation issue' incorporates:\r\n     *  Constant: '<S69>/Clamping_zero'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.fixforDTpropagationissue =\r\n      (mcb_pmsm_foc_qep_f28379d_B.DeadZone > 0.0F);\r\n\r\n    /* Switch: '<S69>/Switch1' */\r\n    if (mcb_pmsm_foc_qep_f28379d_B.fixforDTpropagationissue) {\r\n      /* Switch: '<S69>/Switch1' incorporates:\r\n       *  Constant: '<S69>/Constant'\r\n       */\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch1_h = 1;\r\n    } else {\r\n      /* Switch: '<S69>/Switch1' incorporates:\r\n       *  Constant: '<S69>/Constant2'\r\n       */\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch1_h = -1;\r\n    }\r\n\r\n    /* End of Switch: '<S69>/Switch1' */\r\n\r\n    /* Product: '<S76>/IProd Out' incorporates:\r\n     *  Constant: '<S26>/Ki'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.IProdOut = mcb_pmsm_foc_qep_f28379d_B.Sum_j *\r\n      0.281716F;\r\n\r\n    /* RelationalOperator: '<S69>/fix for DT propagation issue1' incorporates:\r\n     *  Constant: '<S69>/Clamping_zero'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.fixforDTpropagationissue1 =\r\n      (mcb_pmsm_foc_qep_f28379d_B.IProdOut > 0.0F);\r\n\r\n    /* Switch: '<S69>/Switch2' */\r\n    if (mcb_pmsm_foc_qep_f28379d_B.fixforDTpropagationissue1) {\r\n      /* Switch: '<S69>/Switch2' incorporates:\r\n       *  Constant: '<S69>/Constant3'\r\n       */\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch2_l = 1;\r\n    } else {\r\n      /* Switch: '<S69>/Switch2' incorporates:\r\n       *  Constant: '<S69>/Constant4'\r\n       */\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch2_l = -1;\r\n    }\r\n\r\n    /* End of Switch: '<S69>/Switch2' */\r\n\r\n    /* RelationalOperator: '<S69>/Equal1' incorporates:\r\n     *  Switch: '<S69>/Switch1'\r\n     *  Switch: '<S69>/Switch2'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Equal1 = (mcb_pmsm_foc_qep_f28379d_B.Switch1_h ==\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch2_l);\r\n\r\n    /* Logic: '<S69>/AND3' */\r\n    mcb_pmsm_foc_qep_f28379d_B.AND3 =\r\n      (mcb_pmsm_foc_qep_f28379d_B.RelationalOperator &&\r\n       mcb_pmsm_foc_qep_f28379d_B.Equal1);\r\n\r\n    /* Switch: '<S69>/Switch' */\r\n    if (mcb_pmsm_foc_qep_f28379d_B.AND3) {\r\n      /* Switch: '<S69>/Switch' incorporates:\r\n       *  Constant: '<S69>/Constant1'\r\n       */\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch_f = 0.0F;\r\n    } else {\r\n      /* Switch: '<S69>/Switch' */\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch_f = mcb_pmsm_foc_qep_f28379d_B.IProdOut;\r\n    }\r\n\r\n    /* End of Switch: '<S69>/Switch' */\r\n\r\n    /* DeadZone: '<S126>/DeadZone' */\r\n    if (mcb_pmsm_foc_qep_f28379d_B.Sum_m > 1.0F) {\r\n      /* DeadZone: '<S126>/DeadZone' */\r\n      mcb_pmsm_foc_qep_f28379d_B.DeadZone_a = mcb_pmsm_foc_qep_f28379d_B.Sum_m -\r\n        1.0F;\r\n    } else if (mcb_pmsm_foc_qep_f28379d_B.Sum_m >= -1.0F) {\r\n      /* DeadZone: '<S126>/DeadZone' */\r\n      mcb_pmsm_foc_qep_f28379d_B.DeadZone_a = 0.0F;\r\n    } else {\r\n      /* DeadZone: '<S126>/DeadZone' */\r\n      mcb_pmsm_foc_qep_f28379d_B.DeadZone_a = mcb_pmsm_foc_qep_f28379d_B.Sum_m -\r\n        -1.0F;\r\n    }\r\n\r\n    /* End of DeadZone: '<S126>/DeadZone' */\r\n\r\n    /* RelationalOperator: '<S124>/Relational Operator' incorporates:\r\n     *  Constant: '<S124>/Clamping_zero'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.RelationalOperator_e =\r\n      (mcb_pmsm_foc_qep_f28379d_B.DeadZone_a != 0.0F);\r\n\r\n    /* RelationalOperator: '<S124>/fix for DT propagation issue' incorporates:\r\n     *  Constant: '<S124>/Clamping_zero'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.fixforDTpropagationissue_j =\r\n      (mcb_pmsm_foc_qep_f28379d_B.DeadZone_a > 0.0F);\r\n\r\n    /* Switch: '<S124>/Switch1' */\r\n    if (mcb_pmsm_foc_qep_f28379d_B.fixforDTpropagationissue_j) {\r\n      /* Switch: '<S124>/Switch1' incorporates:\r\n       *  Constant: '<S124>/Constant'\r\n       */\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch1_l = 1;\r\n    } else {\r\n      /* Switch: '<S124>/Switch1' incorporates:\r\n       *  Constant: '<S124>/Constant2'\r\n       */\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch1_l = -1;\r\n    }\r\n\r\n    /* End of Switch: '<S124>/Switch1' */\r\n\r\n    /* Product: '<S131>/IProd Out' incorporates:\r\n     *  Constant: '<S27>/Ki'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.IProdOut_b = mcb_pmsm_foc_qep_f28379d_B.Sum_o *\r\n      0.281716F;\r\n\r\n    /* RelationalOperator: '<S124>/fix for DT propagation issue1' incorporates:\r\n     *  Constant: '<S124>/Clamping_zero'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.fixforDTpropagationissue1_o =\r\n      (mcb_pmsm_foc_qep_f28379d_B.IProdOut_b > 0.0F);\r\n\r\n    /* Switch: '<S124>/Switch2' */\r\n    if (mcb_pmsm_foc_qep_f28379d_B.fixforDTpropagationissue1_o) {\r\n      /* Switch: '<S124>/Switch2' incorporates:\r\n       *  Constant: '<S124>/Constant3'\r\n       */\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch2_c = 1;\r\n    } else {\r\n      /* Switch: '<S124>/Switch2' incorporates:\r\n       *  Constant: '<S124>/Constant4'\r\n       */\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch2_c = -1;\r\n    }\r\n\r\n    /* End of Switch: '<S124>/Switch2' */\r\n\r\n    /* RelationalOperator: '<S124>/Equal1' incorporates:\r\n     *  Switch: '<S124>/Switch1'\r\n     *  Switch: '<S124>/Switch2'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Equal1_i = (mcb_pmsm_foc_qep_f28379d_B.Switch1_l ==\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch2_c);\r\n\r\n    /* Logic: '<S124>/AND3' */\r\n    mcb_pmsm_foc_qep_f28379d_B.AND3_n =\r\n      (mcb_pmsm_foc_qep_f28379d_B.RelationalOperator_e &&\r\n       mcb_pmsm_foc_qep_f28379d_B.Equal1_i);\r\n\r\n    /* Switch: '<S124>/Switch' */\r\n    if (mcb_pmsm_foc_qep_f28379d_B.AND3_n) {\r\n      /* Switch: '<S124>/Switch' incorporates:\r\n       *  Constant: '<S124>/Constant1'\r\n       */\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch_a = 0.0F;\r\n    } else {\r\n      /* Switch: '<S124>/Switch' */\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch_a =\r\n        mcb_pmsm_foc_qep_f28379d_B.IProdOut_b;\r\n    }\r\n\r\n    /* End of Switch: '<S124>/Switch' */\r\n\r\n    /* Outputs for Atomic SubSystem: '<S19>/Two inputs CRL' */\r\n    mcb_pmsm_foc_q_TwoinputsCRL(mcb_pmsm_foc_qep_f28379d_B.Merge_i[0],\r\n      mcb_pmsm_foc_qep_f28379d_B.Merge_i[1], mcb_pmsm_foc_qep_f28379d_B.Sum4_l,\r\n      mcb_pmsm_foc_qep_f28379d_B.Sum6_a,\r\n      &mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL);\r\n\r\n    /* End of Outputs for SubSystem: '<S19>/Two inputs CRL' */\r\n\r\n    /* Gain: '<S170>/one_by_two' */\r\n    mcb_pmsm_foc_qep_f28379d_B.one_by_two_l = 0.5F *\r\n      mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL.algDD_o1;\r\n\r\n    /* Gain: '<S170>/sqrt3_by_two' */\r\n    mcb_pmsm_foc_qep_f28379d_B.sqrt3_by_two_l = 0.866025388F *\r\n      mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL.algDD_o2;\r\n\r\n    /* Sum: '<S170>/add_b' */\r\n    mcb_pmsm_foc_qep_f28379d_B.add_b_e =\r\n      mcb_pmsm_foc_qep_f28379d_B.sqrt3_by_two_l -\r\n      mcb_pmsm_foc_qep_f28379d_B.one_by_two_l;\r\n\r\n    /* Sum: '<S170>/add_c' */\r\n    mcb_pmsm_foc_qep_f28379d_B.add_c_m = (0.0F -\r\n      mcb_pmsm_foc_qep_f28379d_B.one_by_two_l) -\r\n      mcb_pmsm_foc_qep_f28379d_B.sqrt3_by_two_l;\r\n\r\n    /* MinMax: '<S167>/Max' */\r\n    u0_0 = mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL.algDD_o1;\r\n    Bias = mcb_pmsm_foc_qep_f28379d_B.add_b_e;\r\n    if ((u0_0 >= Bias) || rtIsNaNF(Bias)) {\r\n      Bias = u0_0;\r\n    }\r\n\r\n    u0_0 = mcb_pmsm_foc_qep_f28379d_B.add_c_m;\r\n    if ((!(Bias >= u0_0)) && (!rtIsNaNF(u0_0))) {\r\n      Bias = u0_0;\r\n    }\r\n\r\n    /* MinMax: '<S167>/Max' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Max = Bias;\r\n\r\n    /* MinMax: '<S167>/Min' */\r\n    u0_0 = mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL.algDD_o1;\r\n    Bias = mcb_pmsm_foc_qep_f28379d_B.add_b_e;\r\n    if ((u0_0 <= Bias) || rtIsNaNF(Bias)) {\r\n      Bias = u0_0;\r\n    }\r\n\r\n    u0_0 = mcb_pmsm_foc_qep_f28379d_B.add_c_m;\r\n    if ((!(Bias <= u0_0)) && (!rtIsNaNF(u0_0))) {\r\n      Bias = u0_0;\r\n    }\r\n\r\n    /* MinMax: '<S167>/Min' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Min = Bias;\r\n\r\n    /* Sum: '<S167>/Add' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Add_n = mcb_pmsm_foc_qep_f28379d_B.Max +\r\n      mcb_pmsm_foc_qep_f28379d_B.Min;\r\n\r\n    /* Gain: '<S167>/one_by_two' */\r\n    mcb_pmsm_foc_qep_f28379d_B.one_by_two_lh = -0.5F *\r\n      mcb_pmsm_foc_qep_f28379d_B.Add_n;\r\n\r\n    /* Sum: '<S166>/Add1' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Add1_d = mcb_pmsm_foc_qep_f28379d_B.add_b_e +\r\n      mcb_pmsm_foc_qep_f28379d_B.one_by_two_lh;\r\n\r\n    /* Sum: '<S166>/Add2' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Add2 = mcb_pmsm_foc_qep_f28379d_B.one_by_two_lh +\r\n      mcb_pmsm_foc_qep_f28379d_B.add_c_m;\r\n\r\n    /* Sum: '<S166>/Add3' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Add3 =\r\n      mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL.algDD_o1 +\r\n      mcb_pmsm_foc_qep_f28379d_B.one_by_two_lh;\r\n\r\n    /* Gain: '<S166>/Gain' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Gain[0] = 1.15470052F *\r\n      mcb_pmsm_foc_qep_f28379d_B.Add3;\r\n    mcb_pmsm_foc_qep_f28379d_B.Gain[1] = 1.15470052F *\r\n      mcb_pmsm_foc_qep_f28379d_B.Add1_d;\r\n    mcb_pmsm_foc_qep_f28379d_B.Gain[2] = 1.15470052F *\r\n      mcb_pmsm_foc_qep_f28379d_B.Add2;\r\n\r\n    /* Update for DiscreteIntegrator: '<S134>/Integrator' */\r\n    mcb_pmsm_foc_qep_f28379d_DW.Integrator_DSTATE +=\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch_a;\r\n    mcb_pmsm_foc_qep_f28379d_DW.Integrator_PrevResetState = (int16_T)\r\n      mcb_pmsm_foc_qep_f28379d_B.LogicalOperator;\r\n\r\n    /* Update for DiscreteIntegrator: '<S79>/Integrator' */\r\n    mcb_pmsm_foc_qep_f28379d_DW.Integrator_DSTATE_o +=\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch_f;\r\n    mcb_pmsm_foc_qep_f28379d_DW.Integrator_PrevResetState_k = (int16_T)\r\n      mcb_pmsm_foc_qep_f28379d_B.LogicalOperator_a;\r\n  }\r\n\r\n  /* End of Outputs for SubSystem: '<S8>/Closed Loop Control' */\r\n\r\n  /* Logic: '<S8>/NOT' */\r\n  mcb_pmsm_foc_qep_f28379d_B.NOT_p = !mcb_pmsm_foc_qep_f28379d_B.AND;\r\n\r\n  /* Outputs for Enabled SubSystem: '<S8>/Open Loop Start-Up' incorporates:\r\n   *  EnablePort: '<S16>/Enable'\r\n   */\r\n  if (mcb_pmsm_foc_qep_f28379d_B.NOT_p) {\r\n    mcb_pmsm_foc_qep_f28379d_DW.OpenLoopStartUp_MODE = true;\r\n\r\n    /* Gain: '<S16>/rpm2freq' incorporates:\r\n     *  Constant: '<S16>/Speed_ref(rpm)'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.rpm2freq = 54.760006F;\r\n\r\n    /* DataStoreRead: '<S16>/Data Store Read1' */\r\n    mcb_pmsm_foc_qep_f28379d_B.DataStoreRead1_c =\r\n      mcb_pmsm_foc_qep_f28379d_DW.Enable;\r\n\r\n    /* Logic: '<S173>/NOT' */\r\n    mcb_pmsm_foc_qep_f28379d_B.NOT_b =\r\n      !mcb_pmsm_foc_qep_f28379d_B.DataStoreRead1_c;\r\n\r\n    /* DiscreteIntegrator: '<S173>/Ramp Generator' */\r\n    if (mcb_pmsm_foc_qep_f28379d_B.NOT_b) {\r\n      mcb_pmsm_foc_qep_f28379d_DW.RampGenerator_DSTATE = 0.0F;\r\n    }\r\n\r\n    /* DiscreteIntegrator: '<S173>/Ramp Generator' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Eps =\r\n      mcb_pmsm_foc_qep_f28379d_DW.RampGenerator_DSTATE;\r\n\r\n    /* Product: '<S16>/Product' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Product_k = 54.760006F *\r\n      mcb_pmsm_foc_qep_f28379d_B.Eps;\r\n\r\n    /* Abs: '<S16>/Abs' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Frequency = fabsf\r\n      (mcb_pmsm_foc_qep_f28379d_B.Product_k);\r\n\r\n    /* Gain: '<S16>/V-by-f' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Vbyf = 0.00365230092F *\r\n      mcb_pmsm_foc_qep_f28379d_B.Frequency;\r\n\r\n    /* Gain: '<S16>/Correction_Factor_sinePWM' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Correction_Factor_sinePWM = 1.15470052F *\r\n      mcb_pmsm_foc_qep_f28379d_B.Vbyf;\r\n\r\n    /* Saturate: '<S16>/Saturation' */\r\n    u0_0 = mcb_pmsm_foc_qep_f28379d_B.Correction_Factor_sinePWM;\r\n    if (u0_0 > 0.95F) {\r\n      /* Saturate: '<S16>/Saturation' */\r\n      mcb_pmsm_foc_qep_f28379d_B.Amplitude = 0.95F;\r\n    } else if (u0_0 < 0.15F) {\r\n      /* Saturate: '<S16>/Saturation' */\r\n      mcb_pmsm_foc_qep_f28379d_B.Amplitude = 0.15F;\r\n    } else {\r\n      /* Saturate: '<S16>/Saturation' */\r\n      mcb_pmsm_foc_qep_f28379d_B.Amplitude = u0_0;\r\n    }\r\n\r\n    /* End of Saturate: '<S16>/Saturation' */\r\n\r\n    /* UnaryMinus: '<S171>/Unary Minus' */\r\n    mcb_pmsm_foc_qep_f28379d_B.UnaryMinus =\r\n      -mcb_pmsm_foc_qep_f28379d_B.Amplitude;\r\n\r\n    /* Gain: '<S16>/position_increment' */\r\n    mcb_pmsm_foc_qep_f28379d_B.position_increment = 0.000314159261F *\r\n      mcb_pmsm_foc_qep_f28379d_B.Frequency;\r\n\r\n    /* Gain: '<S172>/scaleIn' */\r\n    mcb_pmsm_foc_qep_f28379d_B.scaleIn = 0.159154937F *\r\n      mcb_pmsm_foc_qep_f28379d_B.position_increment;\r\n\r\n    /* UnitDelay: '<S172>/Unit Delay' */\r\n    mcb_pmsm_foc_qep_f28379d_B.UnitDelay_d =\r\n      mcb_pmsm_foc_qep_f28379d_DW.UnitDelay_DSTATE_h;\r\n\r\n    /* Logic: '<S172>/NOT' incorporates:\r\n     *  Constant: '<S172>/Constant_Reset'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.NOT_o = true;\r\n\r\n    /* Outputs for Enabled SubSystem: '<S172>/Accumulate' incorporates:\r\n     *  EnablePort: '<S188>/Enable'\r\n     */\r\n    /* Delay: '<S188>/Delay' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Delay_o =\r\n      mcb_pmsm_foc_qep_f28379d_DW.Delay_DSTATE_j;\r\n\r\n    /* Outputs for Enabled SubSystem: '<S188>/Subsystem' incorporates:\r\n     *  EnablePort: '<S189>/Enable'\r\n     */\r\n    if (mcb_pmsm_foc_qep_f28379d_B.Delay_o) {\r\n      /* SignalConversion generated from: '<S189>/Input' */\r\n      mcb_pmsm_foc_qep_f28379d_B.Input = mcb_pmsm_foc_qep_f28379d_B.scaleIn;\r\n    }\r\n\r\n    /* End of Outputs for SubSystem: '<S188>/Subsystem' */\r\n\r\n    /* Sum: '<S188>/Add' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Add_m = mcb_pmsm_foc_qep_f28379d_B.Input +\r\n      mcb_pmsm_foc_qep_f28379d_B.UnitDelay_d;\r\n\r\n    /* DataTypeConversion: '<S188>/Data Type Conversion' */\r\n    mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion_flc = (int16_T)(real32_T)floor\r\n      (mcb_pmsm_foc_qep_f28379d_B.Add_m);\r\n\r\n    /* DataTypeConversion: '<S188>/Data Type Conversion1' */\r\n    mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion1_f =\r\n      mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion_flc;\r\n\r\n    /* Sum: '<S188>/Add1' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Add1_c = mcb_pmsm_foc_qep_f28379d_B.Add_m -\r\n      mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion1_f;\r\n\r\n    /* Update for Delay: '<S188>/Delay' incorporates:\r\n     *  Constant: '<S188>/Constant'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_DW.Delay_DSTATE_j = true;\r\n\r\n    /* End of Outputs for SubSystem: '<S172>/Accumulate' */\r\n\r\n    /* Gain: '<S172>/scaleOut' */\r\n    mcb_pmsm_foc_qep_f28379d_B.scaleOut = 6.28318548F *\r\n      mcb_pmsm_foc_qep_f28379d_B.Add1_c;\r\n\r\n    /* DataStoreRead: '<S16>/Data Store Read' */\r\n    mcb_pmsm_foc_qep_f28379d_B.DataStoreRead_p =\r\n      mcb_pmsm_foc_qep_f28379d_DW.SpeedRef;\r\n\r\n    /* Switch: '<S16>/Direction' */\r\n    if (mcb_pmsm_foc_qep_f28379d_B.DataStoreRead_p > 0.0F) {\r\n      /* Switch: '<S16>/Direction' */\r\n      mcb_pmsm_foc_qep_f28379d_B.Eps_g = mcb_pmsm_foc_qep_f28379d_B.scaleOut;\r\n    } else {\r\n      /* Sum: '<S16>/Sum' incorporates:\r\n       *  Constant: '<S16>/ '\r\n       */\r\n      mcb_pmsm_foc_qep_f28379d_B.Sum_f = 6.28318548F -\r\n        mcb_pmsm_foc_qep_f28379d_B.scaleOut;\r\n\r\n      /* Switch: '<S16>/Direction' */\r\n      mcb_pmsm_foc_qep_f28379d_B.Eps_g = mcb_pmsm_foc_qep_f28379d_B.Sum_f;\r\n    }\r\n\r\n    /* End of Switch: '<S16>/Direction' */\r\n\r\n    /* Gain: '<S182>/convert_pu' */\r\n    mcb_pmsm_foc_qep_f28379d_B.convert_pu = 0.159154937F *\r\n      mcb_pmsm_foc_qep_f28379d_B.Eps_g;\r\n\r\n    /* RelationalOperator: '<S184>/Compare' incorporates:\r\n     *  Constant: '<S184>/Constant'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Compare_n =\r\n      (mcb_pmsm_foc_qep_f28379d_B.convert_pu < 0.0F);\r\n\r\n    /* DataTypeConversion: '<S182>/Data Type Conversion' */\r\n    mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion_o =\r\n      mcb_pmsm_foc_qep_f28379d_B.Compare_n;\r\n\r\n    /* If: '<S182>/If' */\r\n    if (mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion_o > 0U) {\r\n      /* Outputs for IfAction SubSystem: '<S182>/If Action Subsystem' incorporates:\r\n       *  ActionPort: '<S185>/Action Port'\r\n       */\r\n      mcb_pmsm__IfActionSubsystem(mcb_pmsm_foc_qep_f28379d_B.convert_pu,\r\n        &mcb_pmsm_foc_qep_f28379d_B.Merge_h,\r\n        &mcb_pmsm_foc_qep_f28379d_B.IfActionSubsystem_o);\r\n\r\n      /* End of Outputs for SubSystem: '<S182>/If Action Subsystem' */\r\n    } else {\r\n      /* Outputs for IfAction SubSystem: '<S182>/If Action Subsystem1' incorporates:\r\n       *  ActionPort: '<S186>/Action Port'\r\n       */\r\n      mcb_pmsm_IfActionSubsystem1(mcb_pmsm_foc_qep_f28379d_B.convert_pu,\r\n        &mcb_pmsm_foc_qep_f28379d_B.Merge_h,\r\n        &mcb_pmsm_foc_qep_f28379d_B.IfActionSubsystem1_h);\r\n\r\n      /* End of Outputs for SubSystem: '<S182>/If Action Subsystem1' */\r\n    }\r\n\r\n    /* End of If: '<S182>/If' */\r\n\r\n    /* Gain: '<S180>/indexing' */\r\n    mcb_pmsm_foc_qep_f28379d_B.indexing = 800.0F *\r\n      mcb_pmsm_foc_qep_f28379d_B.Merge_h;\r\n\r\n    /* DataTypeConversion: '<S180>/Get_Integer' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Get_Integer = (uint16_T)\r\n      mcb_pmsm_foc_qep_f28379d_B.indexing;\r\n\r\n    /* Sum: '<S180>/Sum' incorporates:\r\n     *  Constant: '<S180>/offset'\r\n     */\r\n    Sum_e = mcb_pmsm_foc_qep_f28379d_B.Get_Integer + 1UL;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum[0] = Sum_e;\r\n\r\n    /* Selector: '<S180>/Lookup' incorporates:\r\n     *  Constant: '<S180>/sine_table_values'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Lookup[0] =\r\n      mcb_pmsm_foc_qep_f28379d_ConstP.pooled5[(int16_T)Sum_e];\r\n\r\n    /* Sum: '<S180>/Sum' */\r\n    Sum_e = mcb_pmsm_foc_qep_f28379d_B.Get_Integer;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum[1] = Sum_e;\r\n\r\n    /* Selector: '<S180>/Lookup' incorporates:\r\n     *  Constant: '<S180>/sine_table_values'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Lookup[1] =\r\n      mcb_pmsm_foc_qep_f28379d_ConstP.pooled5[(int16_T)Sum_e];\r\n\r\n    /* Sum: '<S180>/Sum' incorporates:\r\n     *  Constant: '<S180>/offset'\r\n     */\r\n    Sum_e = mcb_pmsm_foc_qep_f28379d_B.Get_Integer + 201UL;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum[2] = Sum_e;\r\n\r\n    /* Selector: '<S180>/Lookup' incorporates:\r\n     *  Constant: '<S180>/sine_table_values'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Lookup[2] =\r\n      mcb_pmsm_foc_qep_f28379d_ConstP.pooled5[(int16_T)Sum_e];\r\n\r\n    /* Sum: '<S180>/Sum' incorporates:\r\n     *  Constant: '<S180>/offset'\r\n     */\r\n    Sum_e = mcb_pmsm_foc_qep_f28379d_B.Get_Integer + 200UL;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum[3] = Sum_e;\r\n\r\n    /* Selector: '<S180>/Lookup' incorporates:\r\n     *  Constant: '<S180>/sine_table_values'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Lookup[3] =\r\n      mcb_pmsm_foc_qep_f28379d_ConstP.pooled5[(int16_T)Sum_e];\r\n\r\n    /* Sum: '<S181>/Sum3' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum3 = mcb_pmsm_foc_qep_f28379d_B.Lookup[0] -\r\n      mcb_pmsm_foc_qep_f28379d_B.Lookup[1];\r\n\r\n    /* DataTypeConversion: '<S180>/Data Type Conversion1' */\r\n    mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion1 =\r\n      mcb_pmsm_foc_qep_f28379d_B.Get_Integer;\r\n\r\n    /* Sum: '<S180>/Sum2' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum2 = mcb_pmsm_foc_qep_f28379d_B.indexing -\r\n      mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion1;\r\n\r\n    /* Product: '<S181>/Product' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Product_b = mcb_pmsm_foc_qep_f28379d_B.Sum3 *\r\n      mcb_pmsm_foc_qep_f28379d_B.Sum2;\r\n\r\n    /* Sum: '<S181>/Sum4' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum4 = mcb_pmsm_foc_qep_f28379d_B.Product_b +\r\n      mcb_pmsm_foc_qep_f28379d_B.Lookup[1];\r\n\r\n    /* Sum: '<S181>/Sum5' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum5 = mcb_pmsm_foc_qep_f28379d_B.Lookup[2] -\r\n      mcb_pmsm_foc_qep_f28379d_B.Lookup[3];\r\n\r\n    /* Product: '<S181>/Product1' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Product1_c = mcb_pmsm_foc_qep_f28379d_B.Sum5 *\r\n      mcb_pmsm_foc_qep_f28379d_B.Sum2;\r\n\r\n    /* Sum: '<S181>/Sum6' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum6 = mcb_pmsm_foc_qep_f28379d_B.Product1_c +\r\n      mcb_pmsm_foc_qep_f28379d_B.Lookup[3];\r\n\r\n    /* Outputs for Atomic SubSystem: '<S175>/Two inputs CRL' */\r\n    /* Constant: '<S171>/Constant' */\r\n    mcb_pmsm_foc_q_TwoinputsCRL(0.0F, mcb_pmsm_foc_qep_f28379d_B.UnaryMinus,\r\n      mcb_pmsm_foc_qep_f28379d_B.Sum4, mcb_pmsm_foc_qep_f28379d_B.Sum6,\r\n      &mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL_l);\r\n\r\n    /* End of Outputs for SubSystem: '<S175>/Two inputs CRL' */\r\n\r\n    /* Gain: '<S177>/Ka' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Ka =\r\n      mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL_l.algDD_o1;\r\n\r\n    /* Gain: '<S177>/one_by_two' */\r\n    mcb_pmsm_foc_qep_f28379d_B.one_by_two = 0.5F *\r\n      mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL_l.algDD_o1;\r\n\r\n    /* Gain: '<S177>/sqrt3_by_two' */\r\n    mcb_pmsm_foc_qep_f28379d_B.sqrt3_by_two = 0.866025388F *\r\n      mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL_l.algDD_o2;\r\n\r\n    /* Sum: '<S177>/add_b' */\r\n    mcb_pmsm_foc_qep_f28379d_B.add_b = mcb_pmsm_foc_qep_f28379d_B.sqrt3_by_two -\r\n      mcb_pmsm_foc_qep_f28379d_B.one_by_two;\r\n\r\n    /* Gain: '<S177>/Kb' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Kb = mcb_pmsm_foc_qep_f28379d_B.add_b;\r\n\r\n    /* Sum: '<S177>/add_c' */\r\n    mcb_pmsm_foc_qep_f28379d_B.add_c = (0.0F -\r\n      mcb_pmsm_foc_qep_f28379d_B.one_by_two) -\r\n      mcb_pmsm_foc_qep_f28379d_B.sqrt3_by_two;\r\n\r\n    /* Gain: '<S177>/Kc' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Kc = mcb_pmsm_foc_qep_f28379d_B.add_c;\r\n\r\n    /* Product: '<S173>/Divide' incorporates:\r\n     *  Constant: '<S16>/Ramp_Time (sec)'\r\n     *  Constant: '<S173>/One'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Divide = 0.333333343F;\r\n\r\n    /* Gain: '<S173>/Sample_Time' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Sample_Time = 1.66666669E-5F;\r\n\r\n    /* Update for DiscreteIntegrator: '<S173>/Ramp Generator' */\r\n    mcb_pmsm_foc_qep_f28379d_DW.RampGenerator_DSTATE += 1.66666669E-5F;\r\n    if (mcb_pmsm_foc_qep_f28379d_DW.RampGenerator_DSTATE > 1.0F) {\r\n      mcb_pmsm_foc_qep_f28379d_DW.RampGenerator_DSTATE = 1.0F;\r\n    } else if (mcb_pmsm_foc_qep_f28379d_DW.RampGenerator_DSTATE < 0.0F) {\r\n      mcb_pmsm_foc_qep_f28379d_DW.RampGenerator_DSTATE = 0.0F;\r\n    }\r\n\r\n    /* End of Update for DiscreteIntegrator: '<S173>/Ramp Generator' */\r\n\r\n    /* Update for UnitDelay: '<S172>/Unit Delay' */\r\n    mcb_pmsm_foc_qep_f28379d_DW.UnitDelay_DSTATE_h =\r\n      mcb_pmsm_foc_qep_f28379d_B.Add1_c;\r\n  } else if (mcb_pmsm_foc_qep_f28379d_DW.OpenLoopStartUp_MODE) {\r\n    /* Disable for DiscreteIntegrator: '<S173>/Ramp Generator' */\r\n    mcb_pmsm_foc_qep_f28379d_DW.RampGenerator_DSTATE =\r\n      mcb_pmsm_foc_qep_f28379d_B.Eps;\r\n    mcb_pmsm_foc_qep_f28379d_DW.OpenLoopStartUp_MODE = false;\r\n  }\r\n\r\n  /* End of Outputs for SubSystem: '<S8>/Open Loop Start-Up' */\r\n\r\n  /* UnitDelay: '<S229>/Output' */\r\n  mcb_pmsm_foc_qep_f28379d_B.Output = mcb_pmsm_foc_qep_f28379d_DW.Output_DSTATE;\r\n\r\n  /* DataStoreRead: '<S1>/Data Store Read' */\r\n  mcb_pmsm_foc_qep_f28379d_B.DataStoreRead =\r\n    mcb_pmsm_foc_qep_f28379d_DW.SpeedRef;\r\n\r\n  /* Gain: '<S197>/PositionToCount' */\r\n  mcb_pmsm_foc_qep_f28379d_B.PositionToCount = (uint32_T)(4.2949673E+9F *\r\n    mcb_pmsm_foc_qep_f28379d_B.Product);\r\n\r\n  /* Delay: '<S197>/Delay' */\r\n  mcb_pmsm_foc_qep_f28379d_B.Delay =\r\n    mcb_pmsm_foc_qep_f28379d_DW.Delay_DSTATE[mcb_pmsm_foc_qep_f28379d_DW.CircBufIdx];\r\n\r\n  /* Sum: '<S197>/SpeedCount' */\r\n  mcb_pmsm_foc_qep_f28379d_B.SpeedCount = (int32_T)\r\n    mcb_pmsm_foc_qep_f28379d_B.PositionToCount - (int32_T)\r\n    mcb_pmsm_foc_qep_f28379d_B.Delay;\r\n\r\n  /* DataTypeConversion: '<S220>/DTC' */\r\n  mcb_pmsm_foc_qep_f28379d_B.DTC_p = (real32_T)\r\n    mcb_pmsm_foc_qep_f28379d_B.SpeedCount;\r\n\r\n  /* Gain: '<S197>/SpeedGain' */\r\n  mcb_pmsm_foc_qep_f28379d_B.SpeedGain = 3.40147022E-9F *\r\n    mcb_pmsm_foc_qep_f28379d_B.DTC_p;\r\n\r\n  /* Switch: '<S193>/Switch1' incorporates:\r\n   *  Constant: '<S193>/FilterConstant'\r\n   *  Constant: '<S193>/OneMinusFilterConstant'\r\n   */\r\n  mcb_pmsm_foc_qep_f28379d_B.Switch1[0] = 0.01F;\r\n  mcb_pmsm_foc_qep_f28379d_B.Switch1[1] = 0.99F;\r\n\r\n  /* Product: '<S200>/Product' */\r\n  mcb_pmsm_foc_qep_f28379d_B.Product_m = mcb_pmsm_foc_qep_f28379d_B.SpeedGain *\r\n    0.01F;\r\n\r\n  /* UnitDelay: '<S200>/Unit Delay' */\r\n  mcb_pmsm_foc_qep_f28379d_B.UnitDelay =\r\n    mcb_pmsm_foc_qep_f28379d_DW.UnitDelay_DSTATE;\r\n\r\n  /* Product: '<S200>/Product1' */\r\n  mcb_pmsm_foc_qep_f28379d_B.Product1 = 0.99F *\r\n    mcb_pmsm_foc_qep_f28379d_B.UnitDelay;\r\n\r\n  /* Sum: '<S200>/Add1' */\r\n  mcb_pmsm_foc_qep_f28379d_B.Add1 = mcb_pmsm_foc_qep_f28379d_B.Product_m +\r\n    mcb_pmsm_foc_qep_f28379d_B.Product1;\r\n\r\n  /* SignalConversion generated from: '<S9>/Selector' */\r\n  mcb_pmsm_foc_qep_f28379d_B.TmpSignalConversionAtSelectorIn[0] =\r\n    mcb_pmsm_foc_qep_f28379d_B.DataStoreRead;\r\n  mcb_pmsm_foc_qep_f28379d_B.TmpSignalConversionAtSelectorIn[1] =\r\n    mcb_pmsm_foc_qep_f28379d_B.Add1;\r\n  mcb_pmsm_foc_qep_f28379d_B.TmpSignalConversionAtSelectorIn[2] =\r\n    mcb_pmsm_foc_qep_f28379d_B.PU_Conversion[0];\r\n  mcb_pmsm_foc_qep_f28379d_B.TmpSignalConversionAtSelectorIn[3] =\r\n    mcb_pmsm_foc_qep_f28379d_B.PU_Conversion[1];\r\n  mcb_pmsm_foc_qep_f28379d_B.TmpSignalConversionAtSelectorIn[4] =\r\n    mcb_pmsm_foc_qep_f28379d_B.Idq_ref_PU[0];\r\n  mcb_pmsm_foc_qep_f28379d_B.TmpSignalConversionAtSelectorIn[5] =\r\n    mcb_pmsm_foc_qep_f28379d_B.algDD_o1;\r\n  mcb_pmsm_foc_qep_f28379d_B.TmpSignalConversionAtSelectorIn[6] =\r\n    mcb_pmsm_foc_qep_f28379d_B.Idq_ref_PU[1];\r\n  mcb_pmsm_foc_qep_f28379d_B.TmpSignalConversionAtSelectorIn[7] =\r\n    mcb_pmsm_foc_qep_f28379d_B.algDD_o2;\r\n  mcb_pmsm_foc_qep_f28379d_B.TmpSignalConversionAtSelectorIn[8] =\r\n    mcb_pmsm_foc_qep_f28379d_B.Add_c;\r\n\r\n  /* DataStoreRead: '<S9>/Data Store Read' */\r\n  mcb_pmsm_foc_qep_f28379d_B.DataStoreRead_j =\r\n    mcb_pmsm_foc_qep_f28379d_DW.Debug_signals;\r\n\r\n  /* MultiPortSwitch: '<S9>/Multiport Switch' */\r\n  switch (mcb_pmsm_foc_qep_f28379d_B.DataStoreRead_j) {\r\n   case 1:\r\n    /* MultiPortSwitch: '<S9>/Multiport Switch' incorporates:\r\n     *  Constant: '<S9>/speed_control'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.MultiportSwitch[0] = 1U;\r\n    mcb_pmsm_foc_qep_f28379d_B.MultiportSwitch[1] = 2U;\r\n    break;\r\n\r\n   case 2:\r\n    /* MultiPortSwitch: '<S9>/Multiport Switch' incorporates:\r\n     *  Constant: '<S9>/Id_control'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.MultiportSwitch[0] = 5U;\r\n    mcb_pmsm_foc_qep_f28379d_B.MultiportSwitch[1] = 6U;\r\n    break;\r\n\r\n   case 3:\r\n    /* MultiPortSwitch: '<S9>/Multiport Switch' incorporates:\r\n     *  Constant: '<S9>/Iq_control'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.MultiportSwitch[0] = 7U;\r\n    mcb_pmsm_foc_qep_f28379d_B.MultiportSwitch[1] = 8U;\r\n    break;\r\n\r\n   case 4:\r\n    /* MultiPortSwitch: '<S9>/Multiport Switch' incorporates:\r\n     *  Constant: '<S9>/Iab'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.MultiportSwitch[0] = 3U;\r\n    mcb_pmsm_foc_qep_f28379d_B.MultiportSwitch[1] = 4U;\r\n    break;\r\n\r\n   default:\r\n    /* MultiPortSwitch: '<S9>/Multiport Switch' incorporates:\r\n     *  Constant: '<S9>/Ia_Pos'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.MultiportSwitch[0] = 3U;\r\n    mcb_pmsm_foc_qep_f28379d_B.MultiportSwitch[1] = 9U;\r\n    break;\r\n  }\r\n\r\n  /* End of MultiPortSwitch: '<S9>/Multiport Switch' */\r\n\r\n  /* Selector: '<S9>/Selector' */\r\n  mcb_pmsm_foc_qep_f28379d_B.Selector[0] =\r\n    mcb_pmsm_foc_qep_f28379d_B.TmpSignalConversionAtSelectorIn[(int16_T)\r\n    mcb_pmsm_foc_qep_f28379d_B.MultiportSwitch[0] - 1];\r\n  mcb_pmsm_foc_qep_f28379d_B.Selector[1] =\r\n    mcb_pmsm_foc_qep_f28379d_B.TmpSignalConversionAtSelectorIn[(int16_T)\r\n    mcb_pmsm_foc_qep_f28379d_B.MultiportSwitch[1] - 1];\r\n\r\n  /* S-Function (any2byte_svd): '<S228>/Byte Pack' */\r\n\r\n  /* Pack: <S228>/Byte Pack */\r\n  {\r\n    uint32_T MW_outputPortOffset = 0U;\r\n    uint16_T MW_inputPortWidth = 0U;\r\n\r\n    /* Packed output data type - uint32_T */\r\n    void* packData = &mcb_pmsm_foc_qep_f28379d_B.BytePack[0];\r\n\r\n    /* Packing the values of Input 1 */\r\n    /* Input data type - real32_T, size - 2 */\r\n    {\r\n      MW_inputPortWidth = (uint16_T)2 * sizeof(real32_T);\r\n      memcpy((void *)&(((uint16_T *)packData)[MW_outputPortOffset]), (void*)\r\n             &mcb_pmsm_foc_qep_f28379d_B.Selector[0], MW_inputPortWidth);\r\n    }\r\n  }\r\n\r\n  /* If: '<S226>/If' */\r\n  if (mcb_pmsm_foc_qep_f28379d_B.Output == 0U) {\r\n    /* Outputs for IfAction SubSystem: '<S226>/Start' incorporates:\r\n     *  ActionPort: '<S232>/Action Port'\r\n     */\r\n    /* Merge: '<S226>/Merge' incorporates:\r\n     *  Constant: '<S232>/Start'\r\n     *  SignalConversion generated from: '<S232>/Data_out'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.SCI_Tx_Data[0] = 1397969747UL;\r\n\r\n    /* SignalConversion generated from: '<S232>/Data' */\r\n    Sum_e = mcb_pmsm_foc_qep_f28379d_B.BytePack[0];\r\n\r\n    /* End of Outputs for SubSystem: '<S226>/Start' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Data_fw[0] = Sum_e;\r\n\r\n    /* Outputs for IfAction SubSystem: '<S226>/Start' incorporates:\r\n     *  ActionPort: '<S232>/Action Port'\r\n     */\r\n    /* Merge: '<S226>/Merge' incorporates:\r\n     *  SignalConversion generated from: '<S232>/Data_out'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.SCI_Tx_Data[1] = Sum_e;\r\n\r\n    /* SignalConversion generated from: '<S232>/Data' */\r\n    Sum_e = mcb_pmsm_foc_qep_f28379d_B.BytePack[1];\r\n\r\n    /* End of Outputs for SubSystem: '<S226>/Start' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Data_fw[1] = Sum_e;\r\n\r\n    /* Outputs for IfAction SubSystem: '<S226>/Start' incorporates:\r\n     *  ActionPort: '<S232>/Action Port'\r\n     */\r\n    /* Merge: '<S226>/Merge' incorporates:\r\n     *  SignalConversion generated from: '<S232>/Data_out'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.SCI_Tx_Data[2] = Sum_e;\r\n\r\n    /* Merge: '<S226>/Merge1' incorporates:\r\n     *  Bias: '<S232>/Bias'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.SCI_Tx_Iteration =\r\n      mcb_pmsm_foc_qep_f28379d_ConstB.Width + 1UL;\r\n\r\n    /* End of Outputs for SubSystem: '<S226>/Start' */\r\n  } else if (mcb_pmsm_foc_qep_f28379d_B.Output == 599U) {\r\n    /* Outputs for IfAction SubSystem: '<S226>/End' incorporates:\r\n     *  ActionPort: '<S231>/Action Port'\r\n     */\r\n    /* SignalConversion generated from: '<S231>/Data' */\r\n    Sum_e = mcb_pmsm_foc_qep_f28379d_B.BytePack[0];\r\n\r\n    /* End of Outputs for SubSystem: '<S226>/End' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Data_f[0] = Sum_e;\r\n\r\n    /* Outputs for IfAction SubSystem: '<S226>/End' incorporates:\r\n     *  ActionPort: '<S231>/Action Port'\r\n     */\r\n    /* Merge: '<S226>/Merge' incorporates:\r\n     *  SignalConversion generated from: '<S231>/Data_out'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.SCI_Tx_Data[0] = Sum_e;\r\n\r\n    /* SignalConversion generated from: '<S231>/Data' */\r\n    Sum_e = mcb_pmsm_foc_qep_f28379d_B.BytePack[1];\r\n\r\n    /* End of Outputs for SubSystem: '<S226>/End' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Data_f[1] = Sum_e;\r\n\r\n    /* Outputs for IfAction SubSystem: '<S226>/End' incorporates:\r\n     *  ActionPort: '<S231>/Action Port'\r\n     */\r\n    /* Merge: '<S226>/Merge' incorporates:\r\n     *  Constant: '<S231>/End'\r\n     *  SignalConversion generated from: '<S231>/Data_out'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.SCI_Tx_Data[1] = Sum_e;\r\n    mcb_pmsm_foc_qep_f28379d_B.SCI_Tx_Data[2] = 1162167621UL;\r\n\r\n    /* Merge: '<S226>/Merge1' incorporates:\r\n     *  Bias: '<S231>/Bias'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.SCI_Tx_Iteration =\r\n      mcb_pmsm_foc_qep_f28379d_ConstB.Width + 1UL;\r\n\r\n    /* End of Outputs for SubSystem: '<S226>/End' */\r\n  } else {\r\n    /* Outputs for IfAction SubSystem: '<S226>/Data' incorporates:\r\n     *  ActionPort: '<S230>/Action Port'\r\n     */\r\n    /* SignalConversion generated from: '<S230>/Data' */\r\n    Sum_e = mcb_pmsm_foc_qep_f28379d_B.BytePack[0];\r\n\r\n    /* End of Outputs for SubSystem: '<S226>/Data' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Data[0] = Sum_e;\r\n\r\n    /* Outputs for IfAction SubSystem: '<S226>/Data' incorporates:\r\n     *  ActionPort: '<S230>/Action Port'\r\n     */\r\n    /* Merge: '<S226>/Merge' incorporates:\r\n     *  SignalConversion generated from: '<S230>/Data_out'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.SCI_Tx_Data[0] = Sum_e;\r\n\r\n    /* SignalConversion generated from: '<S230>/Data' */\r\n    Sum_e = mcb_pmsm_foc_qep_f28379d_B.BytePack[1];\r\n\r\n    /* End of Outputs for SubSystem: '<S226>/Data' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Data[1] = Sum_e;\r\n\r\n    /* Outputs for IfAction SubSystem: '<S226>/Data' incorporates:\r\n     *  ActionPort: '<S230>/Action Port'\r\n     */\r\n    /* Merge: '<S226>/Merge' incorporates:\r\n     *  Constant: '<S230>/Dummy'\r\n     *  SignalConversion generated from: '<S230>/Data_out'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.SCI_Tx_Data[1] = Sum_e;\r\n    mcb_pmsm_foc_qep_f28379d_B.SCI_Tx_Data[2] = 0UL;\r\n\r\n    /* Merge: '<S226>/Merge1' incorporates:\r\n     *  SignalConversion generated from: '<S230>/Data_width'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.SCI_Tx_Iteration =\r\n      mcb_pmsm_foc_qep_f28379d_ConstB.Width;\r\n\r\n    /* End of Outputs for SubSystem: '<S226>/Data' */\r\n  }\r\n\r\n  /* End of If: '<S226>/If' */\r\n\r\n  /* Outputs for Iterator SubSystem: '<S224>/While Iterator Subsystem' incorporates:\r\n   *  WhileIterator: '<S227>/While Iterator'\r\n   */\r\n  s227_iter = 1;\r\n  do {\r\n    mcb_pmsm_foc_qep_f28379d_B.WhileIterator = s227_iter;\r\n    mcb_pmsm_foc_qep_f28379d_B.IndexVector =\r\n      mcb_pmsm_foc_qep_f28379d_B.SCI_Tx_Data[mcb_pmsm_foc_qep_f28379d_B.WhileIterator\r\n      - 1];\r\n\r\n    {\r\n      if (checkSCITransmitInProgressA != 1U) {\r\n        checkSCITransmitInProgressA = 1U;\r\n        int16_T errFlgHeader = NOERROR;\r\n        int16_T errFlgData = NOERROR;\r\n        int16_T errFlgTail = NOERROR;\r\n        errFlgData = scia_xmit((uchar_T*)&mcb_pmsm_foc_qep_f28379d_B.IndexVector,\r\n          4, 4);\r\n        checkSCITransmitInProgressA = 0U;\r\n      }\r\n    }\r\n\r\n    mcb_pmsm_foc_qep_f28379d_B.Add = mcb_pmsm_foc_qep_f28379d_B.SCI_Tx_Iteration\r\n      - (uint32_T)mcb_pmsm_foc_qep_f28379d_B.WhileIterator;\r\n    s227_iter++;\r\n  } while (mcb_pmsm_foc_qep_f28379d_B.Add != 0UL);\r\n\r\n  /* End of Outputs for SubSystem: '<S224>/While Iterator Subsystem' */\r\n\r\n  /* Sum: '<S233>/FixPt Sum1' incorporates:\r\n   *  Constant: '<S233>/FixPt Constant'\r\n   */\r\n  mcb_pmsm_foc_qep_f28379d_B.FixPtSum1 = mcb_pmsm_foc_qep_f28379d_B.Output + 1U;\r\n\r\n  /* Switch: '<S234>/FixPt Switch' */\r\n  if (mcb_pmsm_foc_qep_f28379d_B.FixPtSum1 > 599U) {\r\n    /* Switch: '<S234>/FixPt Switch' incorporates:\r\n     *  Constant: '<S234>/Constant'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.FixPtSwitch = 0U;\r\n  } else {\r\n    /* Switch: '<S234>/FixPt Switch' */\r\n    mcb_pmsm_foc_qep_f28379d_B.FixPtSwitch =\r\n      mcb_pmsm_foc_qep_f28379d_B.FixPtSum1;\r\n  }\r\n\r\n  /* End of Switch: '<S234>/FixPt Switch' */\r\n\r\n  /* DataStoreRead: '<S13>/Enable' */\r\n  mcb_pmsm_foc_qep_f28379d_B.PWM_En = mcb_pmsm_foc_qep_f28379d_DW.Enable;\r\n\r\n  /* DataTypeConversion: '<S13>/Data Type Conversion' */\r\n  mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion =\r\n    mcb_pmsm_foc_qep_f28379d_B.PWM_En;\r\n\r\n  /* Switch: '<S223>/Switch' */\r\n  mcb_pmsm_foc_qep_f28379d_B.Switch_g =\r\n    mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion;\r\n\r\n  /* S-Function (c280xgpio_do): '<S223>/DRV830x Enable' */\r\n  {\r\n    if (mcb_pmsm_foc_qep_f28379d_B.Switch_g) {\r\n      GpioDataRegs.GPDSET.bit.GPIO124 = 1U;\r\n    } else {\r\n      GpioDataRegs.GPDCLEAR.bit.GPIO124 = 1U;\r\n    }\r\n  }\r\n\r\n  /* Switch: '<S223>/Switch1' */\r\n  if (mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion >= 0.5F) {\r\n    /* Switch: '<S8>/Switch' */\r\n    if (mcb_pmsm_foc_qep_f28379d_B.AND) {\r\n      /* Switch: '<S8>/Switch' */\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch_b[0] = mcb_pmsm_foc_qep_f28379d_B.Gain[0];\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch_b[1] = mcb_pmsm_foc_qep_f28379d_B.Gain[1];\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch_b[2] = mcb_pmsm_foc_qep_f28379d_B.Gain[2];\r\n    } else {\r\n      /* Switch: '<S8>/Switch' */\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch_b[0] = mcb_pmsm_foc_qep_f28379d_B.Ka;\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch_b[1] = mcb_pmsm_foc_qep_f28379d_B.Kb;\r\n      mcb_pmsm_foc_qep_f28379d_B.Switch_b[2] = mcb_pmsm_foc_qep_f28379d_B.Kc;\r\n    }\r\n\r\n    /* End of Switch: '<S8>/Switch' */\r\n\r\n    /* Gain: '<S13>/One_by_Two' */\r\n    Bias = 0.5F * mcb_pmsm_foc_qep_f28379d_B.Switch_b[0];\r\n    mcb_pmsm_foc_qep_f28379d_B.One_by_Two[0] = Bias;\r\n\r\n    /* Sum: '<S13>/Sum' incorporates:\r\n     *  Constant: '<S13>/Constant'\r\n     */\r\n    Bias += 0.5F;\r\n    mcb_pmsm_foc_qep_f28379d_B.PWM_Duty_Cycles[0] = Bias;\r\n\r\n    /* Gain: '<S223>/Scale_to_PWM_Counter_PRD' */\r\n    u0 = (uint16_T)(5000.0F * Bias);\r\n    mcb_pmsm_foc_qep_f28379d_B.Scale_to_PWM_Counter_PRD[0] = u0;\r\n\r\n    /* Switch: '<S223>/Switch1' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch1_j[0] = u0;\r\n\r\n    /* Gain: '<S13>/One_by_Two' */\r\n    Bias = 0.5F * mcb_pmsm_foc_qep_f28379d_B.Switch_b[1];\r\n    mcb_pmsm_foc_qep_f28379d_B.One_by_Two[1] = Bias;\r\n\r\n    /* Sum: '<S13>/Sum' incorporates:\r\n     *  Constant: '<S13>/Constant'\r\n     */\r\n    Bias += 0.5F;\r\n    mcb_pmsm_foc_qep_f28379d_B.PWM_Duty_Cycles[1] = Bias;\r\n\r\n    /* Gain: '<S223>/Scale_to_PWM_Counter_PRD' */\r\n    u0 = (uint16_T)(5000.0F * Bias);\r\n    mcb_pmsm_foc_qep_f28379d_B.Scale_to_PWM_Counter_PRD[1] = u0;\r\n\r\n    /* Switch: '<S223>/Switch1' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch1_j[1] = u0;\r\n\r\n    /* Gain: '<S13>/One_by_Two' */\r\n    Bias = 0.5F * mcb_pmsm_foc_qep_f28379d_B.Switch_b[2];\r\n    mcb_pmsm_foc_qep_f28379d_B.One_by_Two[2] = Bias;\r\n\r\n    /* Sum: '<S13>/Sum' incorporates:\r\n     *  Constant: '<S13>/Constant'\r\n     */\r\n    Bias += 0.5F;\r\n    mcb_pmsm_foc_qep_f28379d_B.PWM_Duty_Cycles[2] = Bias;\r\n\r\n    /* Gain: '<S223>/Scale_to_PWM_Counter_PRD' */\r\n    u0 = (uint16_T)(5000.0F * Bias);\r\n    mcb_pmsm_foc_qep_f28379d_B.Scale_to_PWM_Counter_PRD[2] = u0;\r\n\r\n    /* Switch: '<S223>/Switch1' */\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch1_j[2] = u0;\r\n  } else {\r\n    /* Switch: '<S223>/Switch1' incorporates:\r\n     *  Constant: '<S223>/stop'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch1_j[0] = 0U;\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch1_j[1] = 0U;\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch1_j[2] = 0U;\r\n  }\r\n\r\n  /* End of Switch: '<S223>/Switch1' */\r\n\r\n  /* S-Function (c2802xpwm): '<S223>/ePWM1' */\r\n  uint16_T tbprdValue1Outputs = EPwm1Regs.TBPRD;\r\n\r\n  /*-- Update CMPA value for ePWM1 --*/\r\n  {\r\n    EPwm1Regs.CMPA.bit.CMPA = (uint16_T)(mcb_pmsm_foc_qep_f28379d_B.Switch1_j[0]);\r\n  }\r\n\r\n  /* S-Function (c2802xpwm): '<S223>/ePWM2' */\r\n  uint16_T tbprdValue2Outputs = EPwm2Regs.TBPRD;\r\n\r\n  /*-- Update CMPA value for ePWM2 --*/\r\n  {\r\n    EPwm2Regs.CMPA.bit.CMPA = (uint16_T)(mcb_pmsm_foc_qep_f28379d_B.Switch1_j[1]);\r\n  }\r\n\r\n  /* S-Function (c2802xpwm): '<S223>/ePWM3' */\r\n  uint16_T tbprdValue3Outputs = EPwm3Regs.TBPRD;\r\n\r\n  /*-- Update CMPA value for ePWM3 --*/\r\n  {\r\n    EPwm3Regs.CMPA.bit.CMPA = (uint16_T)(mcb_pmsm_foc_qep_f28379d_B.Switch1_j[2]);\r\n  }\r\n\r\n  /* Update for Delay: '<S191>/Delay' */\r\n  mcb_pmsm_foc_qep_f28379d_DW.Delay_DSTATE_m = mcb_pmsm_foc_qep_f28379d_B.AND;\r\n\r\n  /* Update for UnitDelay: '<S229>/Output' */\r\n  mcb_pmsm_foc_qep_f28379d_DW.Output_DSTATE =\r\n    mcb_pmsm_foc_qep_f28379d_B.FixPtSwitch;\r\n\r\n  /* Update for Delay: '<S197>/Delay' */\r\n  mcb_pmsm_foc_qep_f28379d_DW.Delay_DSTATE[mcb_pmsm_foc_qep_f28379d_DW.CircBufIdx]\r\n    = mcb_pmsm_foc_qep_f28379d_B.PositionToCount;\r\n  if (mcb_pmsm_foc_qep_f28379d_DW.CircBufIdx < 19U) {\r\n    mcb_pmsm_foc_qep_f28379d_DW.CircBufIdx++;\r\n  } else {\r\n    mcb_pmsm_foc_qep_f28379d_DW.CircBufIdx = 0U;\r\n  }\r\n\r\n  /* End of Update for Delay: '<S197>/Delay' */\r\n\r\n  /* Update for UnitDelay: '<S200>/Unit Delay' */\r\n  mcb_pmsm_foc_qep_f28379d_DW.UnitDelay_DSTATE = mcb_pmsm_foc_qep_f28379d_B.Add1;\r\n}\r\n\r\n/* System initialize for atomic system: */\r\nvoid mcb__SPIMasterTransfer_Init(DW_SPIMasterTransfer_mcb_pmsm_T *localDW)\r\n{\r\n  uint32_T SPIPinsLoc;\r\n\r\n  /* Start for MATLABSystem: '<S253>/SPI Master Transfer' */\r\n  localDW->obj.matlabCodegenIsDeleted = false;\r\n  localDW->objisempty = true;\r\n  localDW->obj.isInitialized = 1L;\r\n  SPIPinsLoc = MW_UNDEFINED_VALUE;\r\n  localDW->obj.MW_SPI_HANDLE = MW_SPI_Open(0UL, SPIPinsLoc, SPIPinsLoc,\r\n    SPIPinsLoc, MW_UNDEFINED_VALUE, true, 0U);\r\n  MW_SPI_SetFormat(localDW->obj.MW_SPI_HANDLE, 16U, MW_SPI_MODE_0,\r\n                   MW_SPI_MOST_SIGNIFICANT_BIT_FIRST);\r\n  localDW->obj.isSetupComplete = true;\r\n}\r\n\r\n/* Output and update for atomic system: */\r\nvoid mcb_pmsm__SPIMasterTransfer(uint16_T rtu_0, B_SPIMasterTransfer_mcb_pmsm__T\r\n  *localB, DW_SPIMasterTransfer_mcb_pmsm_T *localDW)\r\n{\r\n  uint16_T rdDataRaw;\r\n  uint16_T status;\r\n\r\n  /* MATLABSystem: '<S253>/SPI Master Transfer' */\r\n  MW_SPI_SetSlaveSelect(localDW->obj.MW_SPI_HANDLE, 0U, true);\r\n  status = MW_SPI_SetFormat(localDW->obj.MW_SPI_HANDLE, 16U, MW_SPI_MODE_0,\r\n    MW_SPI_MOST_SIGNIFICANT_BIT_FIRST);\r\n  if (status == 0U) {\r\n    MW_SPI_MasterWriteRead_8bits(localDW->obj.MW_SPI_HANDLE, &rtu_0, &rdDataRaw,\r\n      1UL);\r\n  }\r\n\r\n  /* MATLABSystem: '<S253>/SPI Master Transfer' */\r\n  localB->SPIMasterTransfer = rdDataRaw;\r\n}\r\n\r\n/* Termination for atomic system: */\r\nvoid mcb__SPIMasterTransfer_Term(DW_SPIMasterTransfer_mcb_pmsm_T *localDW)\r\n{\r\n  uint32_T SPIPinsLoc;\r\n\r\n  /* Terminate for MATLABSystem: '<S253>/SPI Master Transfer' */\r\n  if (!localDW->obj.matlabCodegenIsDeleted) {\r\n    localDW->obj.matlabCodegenIsDeleted = true;\r\n    if ((localDW->obj.isInitialized == 1L) && localDW->obj.isSetupComplete) {\r\n      SPIPinsLoc = MW_UNDEFINED_VALUE;\r\n      MW_SPI_Close(localDW->obj.MW_SPI_HANDLE, SPIPinsLoc, SPIPinsLoc,\r\n                   SPIPinsLoc, MW_UNDEFINED_VALUE);\r\n    }\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<S253>/SPI Master Transfer' */\r\n}\r\n\r\n/* System initialize for atomic system: '<Root>/Speed Control' */\r\nvoid mcb_pmsm__SpeedControl_Init(B_SpeedControl_mcb_pmsm_foc_q_T *localB,\r\n  DW_SpeedControl_mcb_pmsm_foc__T *localDW)\r\n{\r\n  /* Start for Constant: '<S263>/Ki2' */\r\n  localB->Ki2 = 0.0F;\r\n\r\n  /* InitializeConditions for DiscreteIntegrator: '<S303>/Integrator' */\r\n  localDW->Integrator_DSTATE = 0.0F;\r\n  localDW->Integrator_PrevResetState = 0;\r\n}\r\n\r\n/* Output and update for atomic system: '<Root>/Speed Control' */\r\nvoid mcb_pmsm_foc_q_SpeedControl(real32_T rtu_Speed_Ref_PU, real32_T\r\n  rtu_Speed_Meas_PU, const boolean_T *rtd_EnClosedLoop, const boolean_T\r\n  *rtd_Enable, B_SpeedControl_mcb_pmsm_foc_q_T *localB,\r\n  DW_SpeedControl_mcb_pmsm_foc__T *localDW)\r\n{\r\n  real32_T u0;\r\n\r\n  /* Constant: '<S7>/Id_ref' */\r\n  localB->Id_ref = 0.0F;\r\n\r\n  /* DataStoreRead: '<S263>/Data Store Read1' */\r\n  localB->DataStoreRead1 = *rtd_Enable;\r\n\r\n  /* DataStoreRead: '<S264>/Data Store Read' */\r\n  localB->DataStoreRead = *rtd_EnClosedLoop;\r\n\r\n  /* DataStoreRead: '<S264>/Data Store Read1' */\r\n  localB->DataStoreRead1_k = *rtd_Enable;\r\n\r\n  /* Logic: '<S264>/AND' */\r\n  localB->AND = (localB->DataStoreRead && localB->DataStoreRead1_k);\r\n\r\n  /* Switch: '<S264>/Switch' */\r\n  if (localB->AND) {\r\n    /* Switch: '<S264>/Switch' */\r\n    localB->Switch = rtu_Speed_Ref_PU;\r\n  } else {\r\n    /* Switch: '<S264>/Switch' */\r\n    localB->Switch = rtu_Speed_Meas_PU;\r\n  }\r\n\r\n  /* End of Switch: '<S264>/Switch' */\r\n\r\n  /* Switch: '<S266>/Switch1' incorporates:\r\n   *  Constant: '<S266>/FilterConstant'\r\n   *  Constant: '<S266>/OneMinusFilterConstant'\r\n   */\r\n  localB->Switch1[0] = 0.1F;\r\n  localB->Switch1[1] = 0.9F;\r\n\r\n  /* Product: '<S323>/Product' */\r\n  localB->Product = localB->Switch * 0.1F;\r\n\r\n  /* UnitDelay: '<S323>/Unit Delay' */\r\n  localB->UnitDelay = localDW->UnitDelay_DSTATE;\r\n\r\n  /* Product: '<S323>/Product1' */\r\n  localB->Product1 = 0.9F * localB->UnitDelay;\r\n\r\n  /* Sum: '<S323>/Add1' */\r\n  localB->Add1 = localB->Product + localB->Product1;\r\n\r\n  /* Sum: '<S263>/Sum' */\r\n  localB->Sum = localB->Add1 - rtu_Speed_Meas_PU;\r\n\r\n  /* Product: '<S308>/PProd Out' incorporates:\r\n   *  Constant: '<S263>/Kp1'\r\n   */\r\n  localB->PProdOut = localB->Sum * 0.918941498F;\r\n\r\n  /* Logic: '<S263>/Logical Operator' */\r\n  localB->LogicalOperator = !localB->DataStoreRead1;\r\n\r\n  /* Constant: '<S263>/Ki2' */\r\n  localB->Ki2 = 0.0F;\r\n\r\n  /* DiscreteIntegrator: '<S303>/Integrator' */\r\n  if (localB->LogicalOperator || (localDW->Integrator_PrevResetState != 0)) {\r\n    localDW->Integrator_DSTATE = 0.0F;\r\n  }\r\n\r\n  /* DiscreteIntegrator: '<S303>/Integrator' */\r\n  localB->Integrator = localDW->Integrator_DSTATE;\r\n\r\n  /* Sum: '<S312>/Sum' */\r\n  localB->Sum_c = localB->PProdOut + localB->Integrator;\r\n\r\n  /* DeadZone: '<S295>/DeadZone' */\r\n  if (localB->Sum_c > 1.0F) {\r\n    /* DeadZone: '<S295>/DeadZone' */\r\n    localB->DeadZone = localB->Sum_c - 1.0F;\r\n  } else if (localB->Sum_c >= -1.0F) {\r\n    /* DeadZone: '<S295>/DeadZone' */\r\n    localB->DeadZone = 0.0F;\r\n  } else {\r\n    /* DeadZone: '<S295>/DeadZone' */\r\n    localB->DeadZone = localB->Sum_c - -1.0F;\r\n  }\r\n\r\n  /* End of DeadZone: '<S295>/DeadZone' */\r\n\r\n  /* RelationalOperator: '<S293>/Relational Operator' incorporates:\r\n   *  Constant: '<S293>/Clamping_zero'\r\n   */\r\n  localB->RelationalOperator = (localB->DeadZone != 0.0F);\r\n\r\n  /* RelationalOperator: '<S293>/fix for DT propagation issue' incorporates:\r\n   *  Constant: '<S293>/Clamping_zero'\r\n   */\r\n  localB->fixforDTpropagationissue = (localB->DeadZone > 0.0F);\r\n\r\n  /* Switch: '<S293>/Switch1' */\r\n  if (localB->fixforDTpropagationissue) {\r\n    /* Switch: '<S293>/Switch1' incorporates:\r\n     *  Constant: '<S293>/Constant'\r\n     */\r\n    localB->Switch1_i = 1;\r\n  } else {\r\n    /* Switch: '<S293>/Switch1' incorporates:\r\n     *  Constant: '<S293>/Constant2'\r\n     */\r\n    localB->Switch1_i = -1;\r\n  }\r\n\r\n  /* End of Switch: '<S293>/Switch1' */\r\n\r\n  /* Product: '<S300>/IProd Out' incorporates:\r\n   *  Constant: '<S263>/Ki1'\r\n   */\r\n  localB->IProdOut = localB->Sum * 0.0121322013F;\r\n\r\n  /* RelationalOperator: '<S293>/fix for DT propagation issue1' incorporates:\r\n   *  Constant: '<S293>/Clamping_zero'\r\n   */\r\n  localB->fixforDTpropagationissue1 = (localB->IProdOut > 0.0F);\r\n\r\n  /* Switch: '<S293>/Switch2' */\r\n  if (localB->fixforDTpropagationissue1) {\r\n    /* Switch: '<S293>/Switch2' incorporates:\r\n     *  Constant: '<S293>/Constant3'\r\n     */\r\n    localB->Switch2 = 1;\r\n  } else {\r\n    /* Switch: '<S293>/Switch2' incorporates:\r\n     *  Constant: '<S293>/Constant4'\r\n     */\r\n    localB->Switch2 = -1;\r\n  }\r\n\r\n  /* End of Switch: '<S293>/Switch2' */\r\n\r\n  /* RelationalOperator: '<S293>/Equal1' incorporates:\r\n   *  Switch: '<S293>/Switch1'\r\n   *  Switch: '<S293>/Switch2'\r\n   */\r\n  localB->Equal1 = (localB->Switch1_i == localB->Switch2);\r\n\r\n  /* Logic: '<S293>/AND3' */\r\n  localB->AND3 = (localB->RelationalOperator && localB->Equal1);\r\n\r\n  /* Switch: '<S293>/Switch' */\r\n  if (localB->AND3) {\r\n    /* Switch: '<S293>/Switch' incorporates:\r\n     *  Constant: '<S293>/Constant1'\r\n     */\r\n    localB->Switch_d = 0.0F;\r\n  } else {\r\n    /* Switch: '<S293>/Switch' */\r\n    localB->Switch_d = localB->IProdOut;\r\n  }\r\n\r\n  /* End of Switch: '<S293>/Switch' */\r\n\r\n  /* Saturate: '<S310>/Saturation' */\r\n  u0 = localB->Sum_c;\r\n  if (u0 > 1.0F) {\r\n    /* Saturate: '<S310>/Saturation' */\r\n    localB->Saturation = 1.0F;\r\n  } else if (u0 < -1.0F) {\r\n    /* Saturate: '<S310>/Saturation' */\r\n    localB->Saturation = -1.0F;\r\n  } else {\r\n    /* Saturate: '<S310>/Saturation' */\r\n    localB->Saturation = u0;\r\n  }\r\n\r\n  /* End of Saturate: '<S310>/Saturation' */\r\n\r\n  /* Update for UnitDelay: '<S323>/Unit Delay' */\r\n  localDW->UnitDelay_DSTATE = localB->Add1;\r\n\r\n  /* Update for DiscreteIntegrator: '<S303>/Integrator' */\r\n  localDW->Integrator_DSTATE += localB->Switch_d;\r\n  localDW->Integrator_PrevResetState = (int16_T)localB->LogicalOperator;\r\n}\r\n\r\n/* Model step function for TID0 */\r\nvoid mcb_pmsm_foc_qep_f28379d_step0(void) /* Sample time: [0.0005s, 0.0s] */\r\n{\r\n  {                                    /* Sample time: [0.0005s, 0.0s] */\r\n    rate_monotonic_scheduler();\r\n  }\r\n\r\n  /* RateTransition: '<Root>/RT1' */\r\n  mcb_pmsm_foc_qep_f28379d_DW.RT1_semaphoreTaken =\r\n    mcb_pmsm_foc_qep_f28379d_DW.RT1_ActiveBufIdx;\r\n\r\n  /* RateTransition: '<Root>/RT1' */\r\n  mcb_pmsm_foc_qep_f28379d_B.RT1 =\r\n    mcb_pmsm_foc_qep_f28379d_DW.RT1_Buffer[mcb_pmsm_foc_qep_f28379d_DW.RT1_semaphoreTaken];\r\n\r\n  /* RateTransition: '<Root>/RT3' */\r\n  mcb_pmsm_foc_qep_f28379d_B.RT3 =\r\n    mcb_pmsm_foc_qep_f28379d_DW.RT3_Buffer[mcb_pmsm_foc_qep_f28379d_DW.RT3_ActiveBufIdx];\r\n\r\n  /* Outputs for Atomic SubSystem: '<Root>/Speed Control' */\r\n  mcb_pmsm_foc_q_SpeedControl(mcb_pmsm_foc_qep_f28379d_B.RT3,\r\n    mcb_pmsm_foc_qep_f28379d_B.RT1, &mcb_pmsm_foc_qep_f28379d_DW.EnClosedLoop,\r\n    &mcb_pmsm_foc_qep_f28379d_DW.Enable,\r\n    &mcb_pmsm_foc_qep_f28379d_B.SpeedControl,\r\n    &mcb_pmsm_foc_qep_f28379d_DW.SpeedControl);\r\n\r\n  /* End of Outputs for SubSystem: '<Root>/Speed Control' */\r\n\r\n  /* RateTransition: '<Root>/RT2' */\r\n  mcb_pmsm_foc_qep_f28379d_DW.RT2_Buffer\r\n    [(mcb_pmsm_foc_qep_f28379d_DW.RT2_ActiveBufIdx == 0) << 1U] =\r\n    mcb_pmsm_foc_qep_f28379d_B.SpeedControl.Id_ref;\r\n  mcb_pmsm_foc_qep_f28379d_DW.RT2_Buffer[1 +\r\n    ((mcb_pmsm_foc_qep_f28379d_DW.RT2_ActiveBufIdx == 0) << 1U)] =\r\n    mcb_pmsm_foc_qep_f28379d_B.SpeedControl.Saturation;\r\n  mcb_pmsm_foc_qep_f28379d_DW.RT2_ActiveBufIdx =\r\n    (mcb_pmsm_foc_qep_f28379d_DW.RT2_ActiveBufIdx == 0);\r\n}\r\n\r\n/* Model step function for TID1 */\r\nvoid mcb_pmsm_foc_qep_f28379d_step1(void) /* Sample time: [0.5s, 0.0s] */\r\n{\r\n  /* Outputs for Atomic SubSystem: '<Root>/Heartbeat LED' */\r\n  /* S-Function (c280xgpio_do): '<S255>/Digital Output' incorporates:\r\n   *  Constant: '<S4>/RED_LED'\r\n   */\r\n  {\r\n    GpioDataRegs.GPBTOGGLE.bit.GPIO34 = (uint16_T)((1U) != 0);\r\n  }\r\n\r\n  /* End of Outputs for SubSystem: '<Root>/Heartbeat LED' */\r\n}\r\n\r\n/* Model initialize function */\r\nvoid mcb_pmsm_foc_qep_f28379d_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n  /* initialize real-time model */\r\n  (void) memset((void *)mcb_pmsm_foc_qep_f28379d_M, 0,\r\n                sizeof(RT_MODEL_mcb_pmsm_foc_qep_f28_T));\r\n\r\n  /* block I/O */\r\n  (void) memset(((void *) &mcb_pmsm_foc_qep_f28379d_B), 0,\r\n                sizeof(B_mcb_pmsm_foc_qep_f28379d_T));\r\n\r\n  {\r\n    int16_T i;\r\n    for (i = 0; i < 9; i++) {\r\n      mcb_pmsm_foc_qep_f28379d_B.TmpSignalConversionAtSelectorIn[i] = 0.0F;\r\n    }\r\n\r\n    mcb_pmsm_foc_qep_f28379d_B.RT1 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.RT3 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.RT2[0] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.RT2[1] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.SCIReceive[0] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.SCIReceive[1] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.GetADCVoltage[0] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.GetADCVoltage[1] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.GetCurrents[0] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.GetCurrents[1] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.PU_Conversion[0] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.PU_Conversion[1] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.DTC = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Product = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Merge = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Numberofpolepairs = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Floor = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Add_c = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.DataStoreRead = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.DTC_p = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.SpeedGain = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch1[0] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch1[1] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Product_m = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.UnitDelay = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Product1 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Add1 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Selector[0] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Selector[1] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch_g = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch_b[0] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch_b[1] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch_b[2] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.One_by_Two[0] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.One_by_Two[1] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.One_by_Two[2] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.PWM_Duty_Cycles[0] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.PWM_Duty_Cycles[1] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.PWM_Duty_Cycles[2] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.rpm2freq = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Eps = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Product_k = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Frequency = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Vbyf = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Correction_Factor_sinePWM = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Amplitude = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.UnaryMinus = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.position_increment = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.scaleIn = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.UnitDelay_d = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.scaleOut = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.DataStoreRead_p = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Eps_g = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.convert_pu = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Merge_h = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.indexing = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Lookup[0] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Lookup[1] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Lookup[2] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Lookup[3] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum3 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion1 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum2 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Product_b = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum4 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum5 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Product1_c = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum6 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Ka = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.one_by_two = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.sqrt3_by_two = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.add_b = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Kb = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.add_c = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Kc = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Divide = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sample_Time = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum_f = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Add_m = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion1_f = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Add1_c = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Input = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Idq_ref_PU[0] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Idq_ref_PU[1] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Merge_b = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.indexing_n = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Lookup_p[0] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Lookup_p[1] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Lookup_p[2] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Lookup_p[3] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum3_p = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion1_h = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum2_j = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Product_n = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum4_l = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum5_j = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Product1_g = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum6_a = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum_o = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.PProdOut = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Kp1 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Integrator = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum_m = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Saturation = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum_j = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.PProdOut_g = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Ki1 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Integrator_f = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum_g = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Saturation_f = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch_n = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Product_j = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Product_f = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Product1_gr = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum1 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Merge_i[0] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Merge_i[1] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.DeadZone = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.IProdOut = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch_f = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.DeadZone_a = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.IProdOut_b = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch_a = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.one_by_two_l = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.sqrt3_by_two_l = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.add_b_e = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.add_c_m = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Max = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Min = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Add_n = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.one_by_two_lh = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Add1_d = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Add2 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Add3 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Gain[0] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Gain[1] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Gain[2] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.acos_b = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.bsin = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.sum_Ds = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.bcos = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.asin_o = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.sum_Qs = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch_h[0] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch_h[1] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.algDD_o1 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.algDD_o2 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Product_o[0] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Product_o[1] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.SquareRoot = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch_as = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch_j[0] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch_j[1] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch2 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Product_bf = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sum_jr = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Product2 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Merge_d = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Gain_b = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch_m = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch1_n = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Sqrt = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.Gain_l = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.a_plus_2b = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.one_by_sqrt3 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.algDD_o1_e = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.algDD_o2_h = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.SpeedControl.Id_ref = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.SpeedControl.Switch = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.SpeedControl.Switch1[0] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.SpeedControl.Switch1[1] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.SpeedControl.Product = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.SpeedControl.UnitDelay = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.SpeedControl.Product1 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.SpeedControl.Add1 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.SpeedControl.Sum = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.SpeedControl.PProdOut = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.SpeedControl.Ki2 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.SpeedControl.Integrator = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.SpeedControl.Sum_c = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.SpeedControl.DeadZone = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.SpeedControl.IProdOut = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.SpeedControl.Switch_d = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.SpeedControl.Saturation = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.IfActionSubsystem1_h.Convert_back = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.IfActionSubsystem_o.Convert_back = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL_l.qcos = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL_l.dsin = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL_l.sum_beta = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL_l.dcos = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL_l.qsin = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL_l.sum_alpha = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL_l.Switch[0] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL_l.Switch[1] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL_l.algDD_o1 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL_l.algDD_o2 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.IfActionSubsystem1_m.Convert_back = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.IfActionSubsystem_m.Convert_back = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL.qcos = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL.dsin = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL.sum_beta = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL.dcos = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL.qsin = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL.sum_alpha = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL.Switch[0] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL.Switch[1] = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL.algDD_o1 = 0.0F;\r\n    mcb_pmsm_foc_qep_f28379d_B.TwoinputsCRL.algDD_o2 = 0.0F;\r\n  }\r\n\r\n  /* states (dwork) */\r\n  (void) memset((void *)&mcb_pmsm_foc_qep_f28379d_DW, 0,\r\n                sizeof(DW_mcb_pmsm_foc_qep_f28379d_T));\r\n  mcb_pmsm_foc_qep_f28379d_DW.UnitDelay_DSTATE = 0.0F;\r\n  mcb_pmsm_foc_qep_f28379d_DW.RampGenerator_DSTATE = 0.0F;\r\n  mcb_pmsm_foc_qep_f28379d_DW.UnitDelay_DSTATE_h = 0.0F;\r\n  mcb_pmsm_foc_qep_f28379d_DW.Integrator_DSTATE = 0.0F;\r\n  mcb_pmsm_foc_qep_f28379d_DW.Integrator_DSTATE_o = 0.0F;\r\n  mcb_pmsm_foc_qep_f28379d_DW.RT1_Buffer[0] = 0.0F;\r\n  mcb_pmsm_foc_qep_f28379d_DW.RT1_Buffer[1] = 0.0F;\r\n  mcb_pmsm_foc_qep_f28379d_DW.RT3_Buffer[0] = 0.0F;\r\n  mcb_pmsm_foc_qep_f28379d_DW.RT3_Buffer[1] = 0.0F;\r\n  mcb_pmsm_foc_qep_f28379d_DW.RT2_Buffer[0] = 0.0F;\r\n  mcb_pmsm_foc_qep_f28379d_DW.RT2_Buffer[1] = 0.0F;\r\n  mcb_pmsm_foc_qep_f28379d_DW.RT2_Buffer[2] = 0.0F;\r\n  mcb_pmsm_foc_qep_f28379d_DW.RT2_Buffer[3] = 0.0F;\r\n  mcb_pmsm_foc_qep_f28379d_DW.SpeedRef = 0.0F;\r\n  mcb_pmsm_foc_qep_f28379d_DW.SpeedControl.UnitDelay_DSTATE = 0.0F;\r\n  mcb_pmsm_foc_qep_f28379d_DW.SpeedControl.Integrator_DSTATE = 0.0F;\r\n\r\n  {\r\n    uint16_T s247_iter;\r\n\r\n    /* Start for DataStoreMemory: '<Root>/Data Store Memory1' */\r\n    mcb_pmsm_foc_qep_f28379d_DW.IaOffset = 2295U;\r\n\r\n    /* Start for DataStoreMemory: '<Root>/Data Store Memory2' */\r\n    mcb_pmsm_foc_qep_f28379d_DW.IbOffset = 2286U;\r\n\r\n    /* Start for DataStoreMemory: '<Root>/Data Store Memory6' */\r\n    mcb_pmsm_foc_qep_f28379d_DW.Debug_signals = 5U;\r\n\r\n    /* SystemInitialize for S-Function (HardwareInterrupt_sfun): '<S239>/Hardware Interrupt' incorporates:\r\n     *  SubSystem: '<Root>/Current Control'\r\n     */\r\n    mcb_pms_CurrentControl_Init();\r\n\r\n    /* SystemInitialize for S-Function (HardwareInterrupt_sfun): '<S241>/Hardware Interrupt' incorporates:\r\n     *  SubSystem: '<Root>/Serial Receive'\r\n     */\r\n    /* System initialize for function-call system: '<Root>/Serial Receive' */\r\n\r\n    /* Start for S-Function (c28xsci_rx): '<S262>/SCI Receive' */\r\n\r\n    /* Initialize out port */\r\n    {\r\n      mcb_pmsm_foc_qep_f28379d_B.SCIReceive[0] = (real32_T)0.0;\r\n      mcb_pmsm_foc_qep_f28379d_B.SCIReceive[1] = (real32_T)0.0;\r\n    }\r\n\r\n    /*Configure Timer2 when blocking mode is enabled and Timeout is not inf*/\r\n    {\r\n      /* InitCpuTimers() - CPU Timers are also initialized in\r\n       * MW_c28xx_board.c in the generated code.\r\n       */\r\n      CpuTimer2Regs.PRD.all = 0xFFFFFFFFU;/* max Period*/\r\n      CpuTimer2Regs.TIM.all = 0xFFFFFFFFU;/* set Ctr*/\r\n      CpuTimer2Regs.TPR.all = 0x00U;   /* no prescaler    */\r\n      StartCpuTimer2();\r\n    }\r\n\r\n    /* SystemInitialize for Atomic SubSystem: '<Root>/Speed Control' */\r\n    mcb_pmsm__SpeedControl_Init(&mcb_pmsm_foc_qep_f28379d_B.SpeedControl,\r\n      &mcb_pmsm_foc_qep_f28379d_DW.SpeedControl);\r\n\r\n    /* End of SystemInitialize for SubSystem: '<Root>/Speed Control' */\r\n\r\n    /* SystemInitialize for Atomic SubSystem: '<Root>/Heartbeat LED' */\r\n    /* Start for S-Function (c280xgpio_do): '<S255>/Digital Output' */\r\n    EALLOW;\r\n    GpioCtrlRegs.GPBMUX1.all &= 0xFFFFFFCFU;\r\n    GpioCtrlRegs.GPBDIR.all |= 0x4U;\r\n    EDIS;\r\n\r\n    /* End of SystemInitialize for SubSystem: '<Root>/Heartbeat LED' */\r\n\r\n    /* SystemInitialize for Atomic SubSystem: '<Root>/Hardware Init' */\r\n    /* Start for S-Function (c280xgpio_do): '<S245>/Digital Output' */\r\n    EALLOW;\r\n    GpioCtrlRegs.GPDMUX2.all &= 0xFCFFFFFFU;\r\n    GpioCtrlRegs.GPDDIR.all |= 0x10000000U;\r\n    EDIS;\r\n\r\n    /* Start for S-Function (c280xgpio_do): '<S245>/Digital Output1' */\r\n    EALLOW;\r\n    GpioCtrlRegs.GPAMUX2.all &= 0xFFFFCFFFU;\r\n    GpioCtrlRegs.GPADIR.all |= 0x400000U;\r\n    EDIS;\r\n\r\n    /* SystemInitialize for Enabled SubSystem: '<S245>/ADC Gain setting' */\r\n    mcb__SPIMasterTransfer_Init(&mcb_pmsm_foc_qep_f28379d_DW.SPIMasterTransfer);\r\n    mcb__SPIMasterTransfer_Init(&mcb_pmsm_foc_qep_f28379d_DW.SPIMasterTransfer1);\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S245>/ADC Gain setting' */\r\n\r\n    /* SystemInitialize for Enabled SubSystem: '<S243>/Calculate ADC Offset ' */\r\n    /* SystemInitialize for Iterator SubSystem: '<S244>/For Iterator Subsystem' */\r\n    /* Start for S-Function (c2802xadc): '<S247>/ADC_A_IN0' */\r\n    if (MW_adcCInitFlag == 0U) {\r\n      InitAdcC();\r\n      MW_adcCInitFlag = 1U;\r\n    }\r\n\r\n    config_ADCC_SOC2 ();\r\n\r\n    /* Start for S-Function (c2802xadc): '<S247>/ADC_B_IN0' */\r\n    if (MW_adcBInitFlag == 0U) {\r\n      InitAdcB();\r\n      MW_adcBInitFlag = 1U;\r\n    }\r\n\r\n    config_ADCB_SOC2 ();\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S244>/For Iterator Subsystem' */\r\n    /* End of SystemInitialize for SubSystem: '<S243>/Calculate ADC Offset ' */\r\n    /* End of SystemInitialize for SubSystem: '<Root>/Hardware Init' */\r\n\r\n    /* Outputs for Atomic SubSystem: '<Root>/Hardware Init' */\r\n    /* Outputs for Enabled SubSystem: '<S245>/ADC Gain setting' incorporates:\r\n     *  EnablePort: '<S253>/Enable'\r\n     */\r\n    /* Constant: '<S3>/6PWM_Mode' */\r\n    mcb_pmsm__SPIMasterTransfer(14870U,\r\n      &mcb_pmsm_foc_qep_f28379d_B.SPIMasterTransfer,\r\n      &mcb_pmsm_foc_qep_f28379d_DW.SPIMasterTransfer);\r\n\r\n    /* Constant: '<S3>/ADC_Gain_Setting' */\r\n    mcb_pmsm__SPIMasterTransfer(20480U,\r\n      &mcb_pmsm_foc_qep_f28379d_B.SPIMasterTransfer1,\r\n      &mcb_pmsm_foc_qep_f28379d_DW.SPIMasterTransfer1);\r\n\r\n    /* End of Outputs for SubSystem: '<S245>/ADC Gain setting' */\r\n\r\n    /* Switch: '<S245>/Switch' incorporates:\r\n     *  Constant: '<S245>/Inverter Enable'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Switch_c = 1U;\r\n\r\n    /* S-Function (c280xgpio_do): '<S245>/Digital Output' */\r\n    {\r\n      if (mcb_pmsm_foc_qep_f28379d_B.Switch_c) {\r\n        GpioDataRegs.GPDSET.bit.GPIO124 = 1U;\r\n      } else {\r\n        GpioDataRegs.GPDCLEAR.bit.GPIO124 = 1U;\r\n      }\r\n    }\r\n\r\n    /* S-Function (c280xgpio_do): '<S245>/Digital Output1' incorporates:\r\n     *  Constant: '<S245>/RunTimeMeasurement'\r\n     */\r\n    {\r\n      if ((1U)) {\r\n        GpioDataRegs.GPASET.bit.GPIO22 = 1U;\r\n      } else {\r\n        GpioDataRegs.GPACLEAR.bit.GPIO22 = 1U;\r\n      }\r\n    }\r\n\r\n    /* Outputs for Enabled SubSystem: '<S243>/Calculate ADC Offset ' incorporates:\r\n     *  EnablePort: '<S244>/Enable'\r\n     */\r\n    /* Outputs for Iterator SubSystem: '<S244>/For Iterator Subsystem' incorporates:\r\n     *  ForIterator: '<S247>/For Iterator'\r\n     */\r\n    for (s247_iter = 1U; s247_iter < 17U; s247_iter++) {\r\n      /* Outputs for Iterator SubSystem: '<S244>/For Iterator Subsystem' incorporates:\r\n       *  ForIterator: '<S247>/For Iterator'\r\n       */\r\n      mcb_pmsm_foc_qep_f28379d_B.ForIterator = s247_iter;\r\n\r\n      /* S-Function (c2802xadc): '<S247>/ADC_A_IN0' */\r\n      {\r\n        /*  Internal Reference Voltage : Fixed scale 0 to 3.3 V range.  */\r\n        /*  External Reference Voltage : Allowable ranges of VREFHI(ADCINA0) = 3.3 and VREFLO(tied to ground) = 0  */\r\n        AdccRegs.ADCSOCFRC1.bit.SOC2 = 1U;\r\n\r\n        /* Wait for the period of Sampling window and EOC result to be latched after trigger */\r\n#ifndef __TMS320C28XX_CLA__\r\n\r\n        asm(\" RPT #75|| NOP\");\r\n\r\n#endif\r\n\r\n#ifdef __TMS320C28XX_CLA__\r\n\r\n        real32_T wait_index;\r\n        for (wait_index= 12; wait_index > 0; wait_index--)\r\n          __mnop();\r\n\r\n#endif\r\n\r\n        mcb_pmsm_foc_qep_f28379d_B.ADC_A_IN0 = (AdccResultRegs.ADCRESULT2);\r\n      }\r\n\r\n      /* S-Function (c2802xadc): '<S247>/ADC_B_IN0' */\r\n      {\r\n        /*  Internal Reference Voltage : Fixed scale 0 to 3.3 V range.  */\r\n        /*  External Reference Voltage : Allowable ranges of VREFHI(ADCINA0) = 3.3 and VREFLO(tied to ground) = 0  */\r\n        AdcbRegs.ADCSOCFRC1.bit.SOC2 = 1U;\r\n\r\n        /* Wait for the period of Sampling window and EOC result to be latched after trigger */\r\n#ifndef __TMS320C28XX_CLA__\r\n\r\n        asm(\" RPT #75|| NOP\");\r\n\r\n#endif\r\n\r\n#ifdef __TMS320C28XX_CLA__\r\n\r\n        real32_T wait_index;\r\n        for (wait_index= 12; wait_index > 0; wait_index--)\r\n          __mnop();\r\n\r\n#endif\r\n\r\n        mcb_pmsm_foc_qep_f28379d_B.ADC_B_IN0 = (AdcbResultRegs.ADCRESULT2);\r\n      }\r\n\r\n      /* If: '<S247>/If' */\r\n      if (mcb_pmsm_foc_qep_f28379d_B.ForIterator > 8U) {\r\n        /* Outputs for IfAction SubSystem: '<S247>/If Action Subsystem' incorporates:\r\n         *  ActionPort: '<S252>/Action Port'\r\n         */\r\n        /* Memory: '<S252>/Memory' */\r\n        mcb_pmsm_foc_qep_f28379d_B.Memory =\r\n          mcb_pmsm_foc_qep_f28379d_DW.Memory_PreviousInput;\r\n\r\n        /* Sum: '<S252>/Sum' */\r\n        mcb_pmsm_foc_qep_f28379d_B.Sum_h = mcb_pmsm_foc_qep_f28379d_B.ADC_A_IN0\r\n          + mcb_pmsm_foc_qep_f28379d_B.Memory;\r\n\r\n        /* Memory: '<S252>/Memory1' */\r\n        mcb_pmsm_foc_qep_f28379d_B.Memory1 =\r\n          mcb_pmsm_foc_qep_f28379d_DW.Memory1_PreviousInput;\r\n\r\n        /* Sum: '<S252>/Sum1' */\r\n        mcb_pmsm_foc_qep_f28379d_B.Sum1_j = mcb_pmsm_foc_qep_f28379d_B.ADC_B_IN0\r\n          + mcb_pmsm_foc_qep_f28379d_B.Memory1;\r\n\r\n        /* Update for Memory: '<S252>/Memory' */\r\n        mcb_pmsm_foc_qep_f28379d_DW.Memory_PreviousInput =\r\n          mcb_pmsm_foc_qep_f28379d_B.Sum_h;\r\n\r\n        /* Update for Memory: '<S252>/Memory1' */\r\n        mcb_pmsm_foc_qep_f28379d_DW.Memory1_PreviousInput =\r\n          mcb_pmsm_foc_qep_f28379d_B.Sum1_j;\r\n\r\n        /* End of Outputs for SubSystem: '<S247>/If Action Subsystem' */\r\n      }\r\n\r\n      /* End of If: '<S247>/If' */\r\n    }\r\n\r\n    /* End of Outputs for SubSystem: '<S244>/For Iterator Subsystem' */\r\n\r\n    /* Product: '<S244>/Divide' incorporates:\r\n     *  Constant: '<S244>/Constant'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Divide_o = (uint16_T)((real_T)\r\n      mcb_pmsm_foc_qep_f28379d_B.Sum_h / 8.0);\r\n\r\n    /* If: '<S244>/If' incorporates:\r\n     *  Constant: '<S244>/Constant1'\r\n     *  Constant: '<S244>/Constant2'\r\n     */\r\n    if ((mcb_pmsm_foc_qep_f28379d_B.Divide_o > 1500U) &&\r\n        (mcb_pmsm_foc_qep_f28379d_B.Divide_o < 2500U)) {\r\n      /* Outputs for IfAction SubSystem: '<S244>/If Action Subsystem' incorporates:\r\n       *  ActionPort: '<S248>/Action Port'\r\n       */\r\n      /* DataStoreWrite: '<S248>/Data Store Write1' */\r\n      mcb_pmsm_foc_qep_f28379d_DW.IaOffset = mcb_pmsm_foc_qep_f28379d_B.Divide_o;\r\n\r\n      /* End of Outputs for SubSystem: '<S244>/If Action Subsystem' */\r\n    } else {\r\n      /* Outputs for IfAction SubSystem: '<S244>/If Action Subsystem1' incorporates:\r\n       *  ActionPort: '<S249>/Action Port'\r\n       */\r\n      /* DataStoreWrite: '<S249>/Data Store Write1' incorporates:\r\n       *  Constant: '<S249>/Constant'\r\n       */\r\n      mcb_pmsm_foc_qep_f28379d_DW.IaOffset = 2295U;\r\n\r\n      /* End of Outputs for SubSystem: '<S244>/If Action Subsystem1' */\r\n    }\r\n\r\n    /* End of If: '<S244>/If' */\r\n\r\n    /* Product: '<S244>/Divide1' incorporates:\r\n     *  Constant: '<S244>/Constant'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.Divide1 = (uint16_T)((real_T)\r\n      mcb_pmsm_foc_qep_f28379d_B.Sum1_j / 8.0);\r\n\r\n    /* If: '<S244>/If1' incorporates:\r\n     *  Constant: '<S244>/Constant1'\r\n     *  Constant: '<S244>/Constant2'\r\n     */\r\n    if ((mcb_pmsm_foc_qep_f28379d_B.Divide1 > 1500U) &&\r\n        (mcb_pmsm_foc_qep_f28379d_B.Divide1 < 2500U)) {\r\n      /* Outputs for IfAction SubSystem: '<S244>/If Action Subsystem2' incorporates:\r\n       *  ActionPort: '<S250>/Action Port'\r\n       */\r\n      /* DataStoreWrite: '<S250>/Data Store Write2' */\r\n      mcb_pmsm_foc_qep_f28379d_DW.IbOffset = mcb_pmsm_foc_qep_f28379d_B.Divide1;\r\n\r\n      /* End of Outputs for SubSystem: '<S244>/If Action Subsystem2' */\r\n    } else {\r\n      /* Outputs for IfAction SubSystem: '<S244>/If Action Subsystem3' incorporates:\r\n       *  ActionPort: '<S251>/Action Port'\r\n       */\r\n      /* DataStoreWrite: '<S251>/Data Store Write2' incorporates:\r\n       *  Constant: '<S251>/Constant1'\r\n       */\r\n      mcb_pmsm_foc_qep_f28379d_DW.IbOffset = 2286U;\r\n\r\n      /* End of Outputs for SubSystem: '<S244>/If Action Subsystem3' */\r\n    }\r\n\r\n    /* End of If: '<S244>/If1' */\r\n    /* End of Outputs for SubSystem: '<S243>/Calculate ADC Offset ' */\r\n\r\n    /* Logic: '<S243>/NOT' incorporates:\r\n     *  Constant: '<S243>/ADC Calib Enable'\r\n     */\r\n    mcb_pmsm_foc_qep_f28379d_B.NOT = false;\r\n\r\n    /* Outputs for Enabled SubSystem: '<S243>/Default ADC Offset' incorporates:\r\n     *  EnablePort: '<S246>/Enable'\r\n     */\r\n    if (mcb_pmsm_foc_qep_f28379d_B.NOT) {\r\n      /* DataStoreWrite: '<S246>/Data Store Write1' incorporates:\r\n       *  Constant: '<S246>/Constant'\r\n       */\r\n      mcb_pmsm_foc_qep_f28379d_DW.IaOffset = 2295U;\r\n\r\n      /* DataStoreWrite: '<S246>/Data Store Write2' incorporates:\r\n       *  Constant: '<S246>/Constant1'\r\n       */\r\n      mcb_pmsm_foc_qep_f28379d_DW.IbOffset = 2286U;\r\n    }\r\n\r\n    /* End of Outputs for SubSystem: '<S243>/Default ADC Offset' */\r\n    /* End of Outputs for SubSystem: '<Root>/Hardware Init' */\r\n  }\r\n}\r\n\r\n/* Model terminate function */\r\nvoid mcb_pmsm_foc_qep_f28379d_terminate(void)\r\n{\r\n  /* Terminate for Atomic SubSystem: '<Root>/Hardware Init' */\r\n  /* Terminate for Enabled SubSystem: '<S245>/ADC Gain setting' */\r\n  mcb__SPIMasterTransfer_Term(&mcb_pmsm_foc_qep_f28379d_DW.SPIMasterTransfer);\r\n  mcb__SPIMasterTransfer_Term(&mcb_pmsm_foc_qep_f28379d_DW.SPIMasterTransfer1);\r\n\r\n  /* End of Terminate for SubSystem: '<S245>/ADC Gain setting' */\r\n  /* End of Terminate for SubSystem: '<Root>/Hardware Init' */\r\n}\r\n\r\nvoid mcb_pmsm_foc_qep_f28379d_configure_interrupts(void)\r\n{\r\n  /* Register interrupt service routine */\r\n  HWI_TIC28x_ConfigureIRQ(33,&ADCB1_INT,0);\r\n  HWI_TIC28x_EnableIRQ(33);\r\n\r\n  /* Register interrupt service routine */\r\n  HWI_TIC28x_ConfigureIRQ(96,&SCIA_RX_INT,2);\r\n  HWI_TIC28x_EnableIRQ(96);\r\n}\r\n\r\n/* Hardware Interrupt Block: '<S239>/Hardware Interrupt' */\r\ninterrupt void ADCB1_INT(void)\r\n{\r\n  volatile unsigned int PIEIER1_stack_save = PieCtrlRegs.PIEIER1.all;\r\n  volatile unsigned int PIEIER9_stack_save = PieCtrlRegs.PIEIER9.all;\r\n  PieCtrlRegs.PIEIER1.all &= ~66;\r\n                              /*disable group1 lower/equal priority interrupts*/\r\n  PieCtrlRegs.PIEIER9.all &= ~1;\r\n                              /*disable group9 lower/equal priority interrupts*/\r\n  asm(\" RPT #5 || NOP\");               /*wait 5 cycles        */\r\n  IFR &= ~257;    /*eventually disable lower/equal priority pending interrupts*/\r\n  PieCtrlRegs.PIEACK.all = 257;\r\n                   /*ACK to allow other interrupts from the same group to fire*/\r\n  IER |= 1;\r\n  EINT;\r\n\r\n  /* Event: Default Event */\r\n  if (1 == runModel) {\r\n    {\r\n      int16_T tmp;\r\n\r\n      /* RateTransition: '<Root>/RT2' */\r\n      tmp = mcb_pmsm_foc_qep_f28379d_DW.RT2_ActiveBufIdx << 1U;\r\n      mcb_pmsm_foc_qep_f28379d_B.RT2[0] =\r\n        mcb_pmsm_foc_qep_f28379d_DW.RT2_Buffer[tmp];\r\n      mcb_pmsm_foc_qep_f28379d_B.RT2[1] =\r\n        mcb_pmsm_foc_qep_f28379d_DW.RT2_Buffer[tmp + 1];\r\n\r\n      /* S-Function (HardwareInterrupt_sfun): '<S239>/Hardware Interrupt' */\r\n      mcb_pmsm_foc_CurrentControl();\r\n\r\n      /* End of Outputs for S-Function (HardwareInterrupt_sfun): '<S239>/Hardware Interrupt' */\r\n\r\n      /* RateTransition: '<Root>/RT1' */\r\n      mcb_pmsm_foc_qep_f28379d_DW.RT1_Buffer[mcb_pmsm_foc_qep_f28379d_DW.RT1_semaphoreTaken\r\n        == 0] = mcb_pmsm_foc_qep_f28379d_B.Add1;\r\n      mcb_pmsm_foc_qep_f28379d_DW.RT1_ActiveBufIdx =\r\n        (mcb_pmsm_foc_qep_f28379d_DW.RT1_semaphoreTaken == 0);\r\n    }\r\n  }\r\n\r\n  /* Clear occurred EOC event event */\r\n  AdcbRegs.ADCINTFLGCLR.bit.ADCINT1= 1;\r\n\r\n  /* Clear occurred Overflow event event */\r\n  AdcbRegs.ADCINTOVFCLR.bit.ADCINT1= 1;\r\n  DINT;\r\n  /* disable global interrupts during context switch, CPU will enable global interrupts after exiting ISR */\r\n  PieCtrlRegs.PIEIER1.all = PIEIER1_stack_save;\r\n                                   /*restore PIEIER register that was modified*/\r\n  PieCtrlRegs.PIEIER9.all = PIEIER9_stack_save;\r\n                                   /*restore PIEIER register that was modified*/\r\n  HWI_TIC28x_AcknowledgeIrq(33);\r\n}\r\n\r\n/* Hardware Interrupt Block: '<S241>/Hardware Interrupt' */\r\ninterrupt void SCIA_RX_INT(void)\r\n{\r\n  /* Event: Default Event */\r\n  if (1 == runModel) {\r\n    {\r\n      /* S-Function (HardwareInterrupt_sfun): '<S241>/Hardware Interrupt' */\r\n\r\n      /* Output and update for function-call system: '<Root>/Serial Receive' */\r\n\r\n      /* S-Function (c28xsci_rx): '<S262>/SCI Receive' */\r\n      {\r\n        int16_T i;\r\n        int16_T errFlg = NOERROR;\r\n        uint16_T isHeadReceived = 1U;\r\n\r\n        //get data as uint16 in recBuff\r\n        uint16_T recbuff[4];\r\n        for (i = 0; i < 4; i++) {\r\n          recbuff[i] = 0U;\r\n        }\r\n\r\n        errFlg = NOERROR;\r\n\r\n        /* Receiving data: For uint32 and uint16, rcvBuff will contain uint16 data */\r\n        if (isHeadReceived) {\r\n          errFlg = scia_rcv(recbuff, 8, 4);\r\n          asm(\" NOP\");\r\n          if ((errFlg == NOERROR) || (errFlg == PARTIALDATA)) {\r\n            memcpy( &mcb_pmsm_foc_qep_f28379d_B.SCIReceive[0], recbuff,4);\r\n          }\r\n        }\r\n      }\r\n\r\n      /* DataTypeConversion: '<S260>/Data Type Conversion2' */\r\n      mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion2 = (uint16_T)\r\n        mcb_pmsm_foc_qep_f28379d_B.SCIReceive[1];\r\n\r\n      /* S-Function (sfix_bitop): '<S259>/Bitwise Operator' */\r\n      mcb_pmsm_foc_qep_f28379d_B.BitwiseOperator =\r\n        mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion2 & 1U;\r\n\r\n      /* DataTypeConversion: '<S259>/Data Type Conversion3' */\r\n      mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion3 =\r\n        (mcb_pmsm_foc_qep_f28379d_B.BitwiseOperator != 0U);\r\n\r\n      /* DataStoreWrite: '<S6>/Data Store Write' */\r\n      mcb_pmsm_foc_qep_f28379d_DW.Enable =\r\n        mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion3;\r\n\r\n      /* DataStoreWrite: '<S6>/Data Store Write1' */\r\n      mcb_pmsm_foc_qep_f28379d_DW.SpeedRef =\r\n        mcb_pmsm_foc_qep_f28379d_B.SCIReceive[0];\r\n\r\n      /* S-Function (sfix_bitop): '<S259>/Bitwise Operator1' */\r\n      mcb_pmsm_foc_qep_f28379d_B.BitwiseOperator1 =\r\n        mcb_pmsm_foc_qep_f28379d_B.DataTypeConversion2 & 240U;\r\n\r\n      /* ArithShift: '<S259>/Shift Arithmetic1' incorporates:\r\n       *  S-Function (sfix_bitop): '<S259>/Bitwise Operator1'\r\n       */\r\n      mcb_pmsm_foc_qep_f28379d_B.ShiftArithmetic1 =\r\n        mcb_pmsm_foc_qep_f28379d_B.BitwiseOperator1 >> 4U;\r\n\r\n      /* DataStoreWrite: '<S6>/Data Store Write2' */\r\n      mcb_pmsm_foc_qep_f28379d_DW.Debug_signals =\r\n        mcb_pmsm_foc_qep_f28379d_B.ShiftArithmetic1;\r\n\r\n      /* End of Outputs for S-Function (HardwareInterrupt_sfun): '<S241>/Hardware Interrupt' */\r\n\r\n      /* RateTransition: '<Root>/RT3' */\r\n      mcb_pmsm_foc_qep_f28379d_DW.RT3_Buffer[mcb_pmsm_foc_qep_f28379d_DW.RT3_ActiveBufIdx\r\n        == 0] = mcb_pmsm_foc_qep_f28379d_B.SCIReceive[0];\r\n      mcb_pmsm_foc_qep_f28379d_DW.RT3_ActiveBufIdx =\r\n        (mcb_pmsm_foc_qep_f28379d_DW.RT3_ActiveBufIdx == 0);\r\n    }\r\n  }\r\n\r\n  /* Clear occurred Rx FIFO complete event */\r\n  EALLOW;\r\n  SciaRegs.SCIFFRX.bit.RXFFINTCLR= 1;\r\n  EDIS;\r\n\r\n  /* Clear occurred Rx FIFO overflow event */\r\n  EALLOW;\r\n  SciaRegs.SCIFFRX.bit.RXFFOVRCLR= 1;\r\n  EDIS;\r\n  HWI_TIC28x_AcknowledgeIrq(96);\r\n}\r\n\r\nvoid mcb_pmsm_foc_qep_f28379d_unconfigure_interrupts (void)\r\n{\r\n  HWI_TIC28x_DisableIRQ(33);\r\n  HWI_TIC28x_DisableIRQ(96);\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"mcb_pmsm_foc_qep_f28379d.h","type":"header","group":"model","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: mcb_pmsm_foc_qep_f28379d.h\r\n *\r\n * Code generated for Simulink model 'mcb_pmsm_foc_qep_f28379d'.\r\n *\r\n * Model version                  : 9.0\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Tue Dec 10 10:17:02 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef mcb_pmsm_foc_qep_f28379d_h_\r\n#define mcb_pmsm_foc_qep_f28379d_h_\r\n#ifndef mcb_pmsm_foc_qep_f28379d_COMMON_INCLUDES_\r\n#define mcb_pmsm_foc_qep_f28379d_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"c2000BoardSupport.h\"\r\n#include \"MW_f2837xD_includes.h\"\r\n#include \"string.h\"\r\n#include \"DSP28xx_SciUtil.h\"\r\n#include \"IQmathLib.h\"\r\n#include \"MW_SPI.h\"\r\n#endif                           /* mcb_pmsm_foc_qep_f28379d_COMMON_INCLUDES_ */\r\n\r\n#include \"MW_c2000ISR.h\"\r\n#include \"mcb_pmsm_foc_qep_f28379d_types.h\"\r\n#include <string.h>\r\n#include \"rt_nonfinite.h\"\r\n#include <stddef.h>\r\n#include \"MW_target_hardware_resources.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#ifndef rtmStepTask\r\n#define rtmStepTask(rtm, idx)          ((rtm)->Timing.TaskCounters.TID[(idx)] == 0)\r\n#endif\r\n\r\n#ifndef rtmTaskCounter\r\n#define rtmTaskCounter(rtm, idx)       ((rtm)->Timing.TaskCounters.TID[(idx)])\r\n#endif\r\n\r\nextern void init_SCI(void);\r\nextern void init_SCI_GPIO(void);\r\nextern void config_ePWMSyncSource(void);\r\nextern void config_ePWM_GPIO (void);\r\nextern void config_ePWM_TBSync (void);\r\nextern void config_ePWM_XBAR(void);\r\n\r\n/* Block signals for system '<S19>/Two inputs CRL' */\r\ntypedef struct {\r\n  real32_T qcos;                       /* '<S152>/qcos' */\r\n  real32_T dsin;                       /* '<S152>/dsin' */\r\n  real32_T sum_beta;                   /* '<S152>/sum_beta' */\r\n  real32_T dcos;                       /* '<S152>/dcos' */\r\n  real32_T qsin;                       /* '<S152>/qsin' */\r\n  real32_T sum_alpha;                  /* '<S152>/sum_alpha' */\r\n  real32_T Switch[2];                  /* '<S153>/Switch' */\r\n  real32_T algDD_o1;\r\n  real32_T algDD_o2;\r\n} B_TwoinputsCRL_mcb_pmsm_foc_q_T;\r\n\r\n/* Block signals for system '<S158>/If Action Subsystem' */\r\ntypedef struct {\r\n  real32_T Convert_back;               /* '<S161>/Convert_back' */\r\n  int16_T Convert_uint16;              /* '<S161>/Convert_uint16' */\r\n} B_IfActionSubsystem_mcb_pmsm__T;\r\n\r\n/* Block signals for system '<S158>/If Action Subsystem1' */\r\ntypedef struct {\r\n  real32_T Convert_back;               /* '<S162>/Convert_back' */\r\n  int16_T Convert_uint16;              /* '<S162>/Convert_uint16' */\r\n} B_IfActionSubsystem1_mcb_pmsm_T;\r\n\r\n/* Block signals for system '<S253>/SPI Master Transfer' */\r\ntypedef struct {\r\n  uint16_T SPIMasterTransfer;          /* '<S253>/SPI Master Transfer' */\r\n} B_SPIMasterTransfer_mcb_pmsm__T;\r\n\r\n/* Block states (default storage) for system '<S253>/SPI Master Transfer' */\r\ntypedef struct {\r\n  codertarget_tic2000_blocks_SP_T obj; /* '<S253>/SPI Master Transfer' */\r\n  boolean_T objisempty;                /* '<S253>/SPI Master Transfer' */\r\n} DW_SPIMasterTransfer_mcb_pmsm_T;\r\n\r\n/* Block signals for system '<Root>/Speed Control' */\r\ntypedef struct {\r\n  real32_T Id_ref;                     /* '<S7>/Id_ref' */\r\n  real32_T Switch;                     /* '<S264>/Switch' */\r\n  real32_T Switch1[2];                 /* '<S266>/Switch1' */\r\n  real32_T Product;                    /* '<S323>/Product' */\r\n  real32_T UnitDelay;                  /* '<S323>/Unit Delay' */\r\n  real32_T Product1;                   /* '<S323>/Product1' */\r\n  real32_T Add1;                       /* '<S323>/Add1' */\r\n  real32_T Sum;                        /* '<S263>/Sum' */\r\n  real32_T PProdOut;                   /* '<S308>/PProd Out' */\r\n  real32_T Ki2;                        /* '<S263>/Ki2' */\r\n  real32_T Integrator;                 /* '<S303>/Integrator' */\r\n  real32_T Sum_c;                      /* '<S312>/Sum' */\r\n  real32_T DeadZone;                   /* '<S295>/DeadZone' */\r\n  real32_T IProdOut;                   /* '<S300>/IProd Out' */\r\n  real32_T Switch_d;                   /* '<S293>/Switch' */\r\n  real32_T Saturation;                 /* '<S310>/Saturation' */\r\n  int16_T Switch1_i;                   /* '<S293>/Switch1' */\r\n  int16_T Switch2;                     /* '<S293>/Switch2' */\r\n  boolean_T DataStoreRead1;            /* '<S263>/Data Store Read1' */\r\n  boolean_T DataStoreRead;             /* '<S264>/Data Store Read' */\r\n  boolean_T DataStoreRead1_k;          /* '<S264>/Data Store Read1' */\r\n  boolean_T AND;                       /* '<S264>/AND' */\r\n  boolean_T LogicalOperator;           /* '<S263>/Logical Operator' */\r\n  boolean_T RelationalOperator;        /* '<S293>/Relational Operator' */\r\n  boolean_T fixforDTpropagationissue;/* '<S293>/fix for DT propagation issue' */\r\n  boolean_T fixforDTpropagationissue1;\r\n                                    /* '<S293>/fix for DT propagation issue1' */\r\n  boolean_T Equal1;                    /* '<S293>/Equal1' */\r\n  boolean_T AND3;                      /* '<S293>/AND3' */\r\n} B_SpeedControl_mcb_pmsm_foc_q_T;\r\n\r\n/* Block states (default storage) for system '<Root>/Speed Control' */\r\ntypedef struct {\r\n  real32_T UnitDelay_DSTATE;           /* '<S323>/Unit Delay' */\r\n  real32_T Integrator_DSTATE;          /* '<S303>/Integrator' */\r\n  int16_T Integrator_PrevResetState;   /* '<S303>/Integrator' */\r\n} DW_SpeedControl_mcb_pmsm_foc__T;\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  uint32_T PositionToCount;            /* '<S197>/PositionToCount' */\r\n  uint32_T Delay;                      /* '<S197>/Delay' */\r\n  uint32_T BytePack[2];                /* '<S228>/Byte Pack' */\r\n  uint32_T SCI_Tx_Data[3];             /* '<S226>/Merge' */\r\n  uint32_T SCI_Tx_Iteration;           /* '<S226>/Merge1' */\r\n  uint32_T IndexVector;                /* '<S227>/Index Vector' */\r\n  uint32_T Add;                        /* '<S227>/Add' */\r\n  uint32_T Data[2];                    /* '<S230>/Data' */\r\n  uint32_T Data_f[2];                  /* '<S231>/Data' */\r\n  uint32_T Data_fw[2];                 /* '<S232>/Data' */\r\n  uint32_T Sum[4];                     /* '<S180>/Sum' */\r\n  uint32_T Sum_e[4];                   /* '<S156>/Sum' */\r\n  real32_T RT1;                        /* '<Root>/RT1' */\r\n  real32_T RT3;                        /* '<Root>/RT3' */\r\n  real32_T RT2[2];                     /* '<Root>/RT2' */\r\n  real32_T SCIReceive[2];              /* '<S262>/SCI Receive' */\r\n  real32_T GetADCVoltage[2];           /* '<S222>/Get ADC Voltage' */\r\n  real32_T GetCurrents[2];             /* '<S222>/Get Currents' */\r\n  real32_T PU_Conversion[2];           /* '<S222>/PU_Conversion' */\r\n  real32_T DTC;                        /* '<S215>/DTC' */\r\n  real32_T Product;                    /* '<S196>/Product' */\r\n  real32_T Switch;                     /* '<S204>/Switch' */\r\n  real32_T Merge;                      /* '<S205>/Merge' */\r\n  real32_T Numberofpolepairs;          /* '<S210>/Number of pole pairs' */\r\n  real32_T Floor;                      /* '<S206>/Floor' */\r\n  real32_T Add_c;                      /* '<S206>/Add' */\r\n  real32_T DataStoreRead;              /* '<S1>/Data Store Read' */\r\n  real32_T DTC_p;                      /* '<S220>/DTC' */\r\n  real32_T SpeedGain;                  /* '<S197>/SpeedGain' */\r\n  real32_T Switch1[2];                 /* '<S193>/Switch1' */\r\n  real32_T Product_m;                  /* '<S200>/Product' */\r\n  real32_T UnitDelay;                  /* '<S200>/Unit Delay' */\r\n  real32_T Product1;                   /* '<S200>/Product1' */\r\n  real32_T Add1;                       /* '<S200>/Add1' */\r\n  real32_T TmpSignalConversionAtSelectorIn[9];\r\n  real32_T Selector[2];                /* '<S9>/Selector' */\r\n  real32_T DataTypeConversion;         /* '<S13>/Data Type Conversion' */\r\n  real32_T Switch_g;                   /* '<S223>/Switch' */\r\n  real32_T Switch_b[3];                /* '<S8>/Switch' */\r\n  real32_T One_by_Two[3];              /* '<S13>/One_by_Two' */\r\n  real32_T PWM_Duty_Cycles[3];         /* '<S13>/Sum' */\r\n  real32_T rpm2freq;                   /* '<S16>/rpm2freq' */\r\n  real32_T Eps;                        /* '<S173>/Ramp Generator' */\r\n  real32_T Product_k;                  /* '<S16>/Product' */\r\n  real32_T Frequency;                  /* '<S16>/Abs' */\r\n  real32_T Vbyf;                       /* '<S16>/V-by-f' */\r\n  real32_T Correction_Factor_sinePWM;  /* '<S16>/Correction_Factor_sinePWM' */\r\n  real32_T Amplitude;                  /* '<S16>/Saturation' */\r\n  real32_T UnaryMinus;                 /* '<S171>/Unary Minus' */\r\n  real32_T position_increment;         /* '<S16>/position_increment' */\r\n  real32_T scaleIn;                    /* '<S172>/scaleIn' */\r\n  real32_T UnitDelay_d;                /* '<S172>/Unit Delay' */\r\n  real32_T scaleOut;                   /* '<S172>/scaleOut' */\r\n  real32_T DataStoreRead_p;            /* '<S16>/Data Store Read' */\r\n  real32_T Eps_g;                      /* '<S16>/Direction' */\r\n  real32_T convert_pu;                 /* '<S182>/convert_pu' */\r\n  real32_T Merge_h;                    /* '<S182>/Merge' */\r\n  real32_T indexing;                   /* '<S180>/indexing' */\r\n  real32_T Lookup[4];                  /* '<S180>/Lookup' */\r\n  real32_T Sum3;                       /* '<S181>/Sum3' */\r\n  real32_T DataTypeConversion1;        /* '<S180>/Data Type Conversion1' */\r\n  real32_T Sum2;                       /* '<S180>/Sum2' */\r\n  real32_T Product_b;                  /* '<S181>/Product' */\r\n  real32_T Sum4;                       /* '<S181>/Sum4' */\r\n  real32_T Sum5;                       /* '<S181>/Sum5' */\r\n  real32_T Product1_c;                 /* '<S181>/Product1' */\r\n  real32_T Sum6;                       /* '<S181>/Sum6' */\r\n  real32_T Ka;                         /* '<S177>/Ka' */\r\n  real32_T one_by_two;                 /* '<S177>/one_by_two' */\r\n  real32_T sqrt3_by_two;               /* '<S177>/sqrt3_by_two' */\r\n  real32_T add_b;                      /* '<S177>/add_b' */\r\n  real32_T Kb;                         /* '<S177>/Kb' */\r\n  real32_T add_c;                      /* '<S177>/add_c' */\r\n  real32_T Kc;                         /* '<S177>/Kc' */\r\n  real32_T Divide;                     /* '<S173>/Divide' */\r\n  real32_T Sample_Time;                /* '<S173>/Sample_Time' */\r\n  real32_T Sum_f;                      /* '<S16>/Sum' */\r\n  real32_T Add_m;                      /* '<S188>/Add' */\r\n  real32_T DataTypeConversion1_f;      /* '<S188>/Data Type Conversion1' */\r\n  real32_T Add1_c;                     /* '<S188>/Add1' */\r\n  real32_T Input;                      /* '<S189>/Input' */\r\n  real32_T Idq_ref_PU[2];              /* '<S15>/Idq_ref_PU' */\r\n  real32_T Merge_b;                    /* '<S158>/Merge' */\r\n  real32_T indexing_n;                 /* '<S156>/indexing' */\r\n  real32_T Lookup_p[4];                /* '<S156>/Lookup' */\r\n  real32_T Sum3_p;                     /* '<S157>/Sum3' */\r\n  real32_T DataTypeConversion1_h;      /* '<S156>/Data Type Conversion1' */\r\n  real32_T Sum2_j;                     /* '<S156>/Sum2' */\r\n  real32_T Product_n;                  /* '<S157>/Product' */\r\n  real32_T Sum4_l;                     /* '<S157>/Sum4' */\r\n  real32_T Sum5_j;                     /* '<S157>/Sum5' */\r\n  real32_T Product1_g;                 /* '<S157>/Product1' */\r\n  real32_T Sum6_a;                     /* '<S157>/Sum6' */\r\n  real32_T Sum_o;                      /* '<S27>/Sum' */\r\n  real32_T PProdOut;                   /* '<S139>/PProd Out' */\r\n  real32_T Kp1;                        /* '<S27>/Kp1' */\r\n  real32_T Integrator;                 /* '<S134>/Integrator' */\r\n  real32_T Sum_m;                      /* '<S143>/Sum' */\r\n  real32_T Saturation;                 /* '<S141>/Saturation' */\r\n  real32_T Sum_j;                      /* '<S26>/Sum' */\r\n  real32_T PProdOut_g;                 /* '<S84>/PProd Out' */\r\n  real32_T Ki1;                        /* '<S26>/Ki1' */\r\n  real32_T Integrator_f;               /* '<S79>/Integrator' */\r\n  real32_T Sum_g;                      /* '<S88>/Sum' */\r\n  real32_T Saturation_f;               /* '<S86>/Saturation' */\r\n  real32_T Switch_n;                   /* '<S30>/Switch' */\r\n  real32_T Product_j;                  /* '<S30>/Product' */\r\n  real32_T Product_f;                  /* '<S31>/Product' */\r\n  real32_T Product1_gr;                /* '<S31>/Product1' */\r\n  real32_T Sum1;                       /* '<S31>/Sum1' */\r\n  real32_T Merge_i[2];                 /* '<S25>/Merge' */\r\n  real32_T DeadZone;                   /* '<S71>/DeadZone' */\r\n  real32_T IProdOut;                   /* '<S76>/IProd Out' */\r\n  real32_T Switch_f;                   /* '<S69>/Switch' */\r\n  real32_T DeadZone_a;                 /* '<S126>/DeadZone' */\r\n  real32_T IProdOut_b;                 /* '<S131>/IProd Out' */\r\n  real32_T Switch_a;                   /* '<S124>/Switch' */\r\n  real32_T one_by_two_l;               /* '<S170>/one_by_two' */\r\n  real32_T sqrt3_by_two_l;             /* '<S170>/sqrt3_by_two' */\r\n  real32_T add_b_e;                    /* '<S170>/add_b' */\r\n  real32_T add_c_m;                    /* '<S170>/add_c' */\r\n  real32_T Max;                        /* '<S167>/Max' */\r\n  real32_T Min;                        /* '<S167>/Min' */\r\n  real32_T Add_n;                      /* '<S167>/Add' */\r\n  real32_T one_by_two_lh;              /* '<S167>/one_by_two' */\r\n  real32_T Add1_d;                     /* '<S166>/Add1' */\r\n  real32_T Add2;                       /* '<S166>/Add2' */\r\n  real32_T Add3;                       /* '<S166>/Add3' */\r\n  real32_T Gain[3];                    /* '<S166>/Gain' */\r\n  real32_T acos_b;                     /* '<S154>/acos' */\r\n  real32_T bsin;                       /* '<S154>/bsin' */\r\n  real32_T sum_Ds;                     /* '<S154>/sum_Ds' */\r\n  real32_T bcos;                       /* '<S154>/bcos' */\r\n  real32_T asin_o;                     /* '<S154>/asin' */\r\n  real32_T sum_Qs;                     /* '<S154>/sum_Qs' */\r\n  real32_T Switch_h[2];                /* '<S155>/Switch' */\r\n  real32_T algDD_o1;\r\n  real32_T algDD_o2;\r\n  real32_T Product_o[2];               /* '<S32>/Product' */\r\n  real32_T SquareRoot;                 /* '<S32>/Square Root' */\r\n  real32_T Switch_as;                  /* '<S32>/Switch' */\r\n  real32_T Switch_j[2];                /* '<S29>/Switch' */\r\n  real32_T Switch2;                    /* '<S39>/Switch2' */\r\n  real32_T Product_bf;                 /* '<S38>/Product' */\r\n  real32_T Sum_jr;                     /* '<S38>/Sum' */\r\n  real32_T Product2;                   /* '<S38>/Product2' */\r\n  real32_T Merge_d;                    /* '<S38>/Merge' */\r\n  real32_T Gain_b;                     /* '<S38>/Gain' */\r\n  real32_T Switch_m;                   /* '<S39>/Switch' */\r\n  real32_T Switch1_n;                  /* '<S40>/Switch1' */\r\n  real32_T Sqrt;                       /* '<S40>/Sqrt' */\r\n  real32_T Gain_l;                     /* '<S40>/Gain' */\r\n  real32_T a_plus_2b;                  /* '<S24>/a_plus_2b' */\r\n  real32_T one_by_sqrt3;               /* '<S24>/one_by_sqrt3' */\r\n  real32_T algDD_o1_e;\r\n  real32_T algDD_o2_h;\r\n  int32_T DataTypeConversion_c[2];     /* '<S192>/Data Type Conversion' */\r\n  int32_T Add_e[2];                    /* '<S192>/Add' */\r\n  int32_T SpeedCount;                  /* '<S197>/SpeedCount' */\r\n  uint16_T Switch_c;                   /* '<S245>/Switch' */\r\n  uint16_T Divide_o;                   /* '<S244>/Divide' */\r\n  uint16_T Divide1;                    /* '<S244>/Divide1' */\r\n  uint16_T ForIterator;                /* '<S247>/For Iterator' */\r\n  uint16_T ADC_A_IN0;                  /* '<S247>/ADC_A_IN0' */\r\n  uint16_T ADC_B_IN0;                  /* '<S247>/ADC_B_IN0' */\r\n  uint16_T Memory;                     /* '<S252>/Memory' */\r\n  uint16_T Sum_h;                      /* '<S252>/Sum' */\r\n  uint16_T Memory1;                    /* '<S252>/Memory1' */\r\n  uint16_T Sum1_j;                     /* '<S252>/Sum1' */\r\n  uint16_T DataTypeConversion2;        /* '<S260>/Data Type Conversion2' */\r\n  uint16_T BitwiseOperator;            /* '<S259>/Bitwise Operator' */\r\n  uint16_T BitwiseOperator1;           /* '<S259>/Bitwise Operator1' */\r\n  uint16_T ShiftArithmetic1;           /* '<S259>/Shift Arithmetic1' */\r\n  uint16_T eQEP_o1;                    /* '<S190>/eQEP' */\r\n  uint16_T eQEP_o2;                    /* '<S190>/eQEP' */\r\n  uint16_T DataStoreRead1;             /* '<S192>/Data Store Read1' */\r\n  uint16_T DataStoreRead2;             /* '<S192>/Data Store Read2' */\r\n  uint16_T ADC_C_IN2;                  /* '<S190>/ADC_C_IN2' */\r\n  uint16_T ADC_B_IN2;                  /* '<S190>/ADC_B_IN2' */\r\n  uint16_T Merge_h5;                   /* '<S196>/Merge' */\r\n  uint16_T Output;                     /* '<S229>/Output' */\r\n  uint16_T DataStoreRead_j;            /* '<S9>/Data Store Read' */\r\n  uint16_T MultiportSwitch[2];         /* '<S9>/Multiport Switch' */\r\n  uint16_T FixPtSum1;                  /* '<S233>/FixPt Sum1' */\r\n  uint16_T FixPtSwitch;                /* '<S234>/FixPt Switch' */\r\n  uint16_T Switch1_j[3];               /* '<S223>/Switch1' */\r\n  uint16_T Scale_to_PWM_Counter_PRD[3];/* '<S223>/Scale_to_PWM_Counter_PRD' */\r\n  uint16_T Sum3_a;                     /* '<S212>/Sum3' */\r\n  uint16_T Sum7;                       /* '<S212>/Sum7' */\r\n  uint16_T Delay3;                     /* '<S194>/Delay3' */\r\n  uint16_T DataTypeConversion_o;       /* '<S182>/Data Type Conversion' */\r\n  uint16_T Get_Integer;                /* '<S180>/Get_Integer' */\r\n  uint16_T Switch1_jb;                 /* '<S30>/Switch1' */\r\n  uint16_T DataTypeConversion_p;       /* '<S158>/Data Type Conversion' */\r\n  uint16_T Get_Integer_l;              /* '<S156>/Get_Integer' */\r\n  uint16_T DataTypeConversion_f;       /* '<S28>/Data Type Conversion' */\r\n  uint16_T DataTypeConversion_fl;      /* '<S38>/Data Type Conversion' */\r\n  int16_T WhileIterator;               /* '<S227>/While Iterator' */\r\n  int16_T DataTypeConversion_flc;      /* '<S188>/Data Type Conversion' */\r\n  int16_T Switch1_h;                   /* '<S69>/Switch1' */\r\n  int16_T Switch2_l;                   /* '<S69>/Switch2' */\r\n  int16_T Switch1_l;                   /* '<S124>/Switch1' */\r\n  int16_T Switch2_c;                   /* '<S124>/Switch2' */\r\n  boolean_T NOT;                       /* '<S243>/NOT' */\r\n  boolean_T DataTypeConversion3;       /* '<S259>/Data Type Conversion3' */\r\n  boolean_T Delay_p;                   /* '<S191>/Delay' */\r\n  boolean_T NOT_m;                     /* '<S191>/NOT' */\r\n  boolean_T NOT_p;                     /* '<S8>/NOT' */\r\n  boolean_T PWM_En;                    /* '<S13>/Enable' */\r\n  boolean_T Compare;                   /* '<S201>/Compare' */\r\n  boolean_T Compare_e;                 /* '<S202>/Compare' */\r\n  boolean_T AND;                       /* '<S194>/AND' */\r\n  boolean_T DataStoreRead1_c;          /* '<S16>/Data Store Read1' */\r\n  boolean_T NOT_b;                     /* '<S173>/NOT' */\r\n  boolean_T NOT_o;                     /* '<S172>/NOT' */\r\n  boolean_T Compare_n;                 /* '<S184>/Compare' */\r\n  boolean_T Delay_o;                   /* '<S188>/Delay' */\r\n  boolean_T Compare_d;                 /* '<S160>/Compare' */\r\n  boolean_T DataStoreRead1_b;          /* '<S27>/Data Store Read1' */\r\n  boolean_T LogicalOperator;           /* '<S27>/Logical Operator' */\r\n  boolean_T DataStoreRead1_m;          /* '<S26>/Data Store Read1' */\r\n  boolean_T LogicalOperator_a;         /* '<S26>/Logical Operator' */\r\n  boolean_T RelationalOperator;        /* '<S69>/Relational Operator' */\r\n  boolean_T fixforDTpropagationissue; /* '<S69>/fix for DT propagation issue' */\r\n  boolean_T fixforDTpropagationissue1;\r\n                                     /* '<S69>/fix for DT propagation issue1' */\r\n  boolean_T Equal1;                    /* '<S69>/Equal1' */\r\n  boolean_T AND3;                      /* '<S69>/AND3' */\r\n  boolean_T RelationalOperator_e;      /* '<S124>/Relational Operator' */\r\n  boolean_T fixforDTpropagationissue_j;\r\n                                     /* '<S124>/fix for DT propagation issue' */\r\n  boolean_T fixforDTpropagationissue1_o;\r\n                                    /* '<S124>/fix for DT propagation issue1' */\r\n  boolean_T Equal1_i;                  /* '<S124>/Equal1' */\r\n  boolean_T AND3_n;                    /* '<S124>/AND3' */\r\n  boolean_T RelationalOperator_k;      /* '<S28>/Relational Operator' */\r\n  boolean_T Compare_k;                 /* '<S34>/Compare' */\r\n  boolean_T Compare_f;                 /* '<S35>/Compare' */\r\n  boolean_T LowerRelop1;               /* '<S39>/LowerRelop1' */\r\n  boolean_T RelationalOperator_l;      /* '<S38>/Relational Operator' */\r\n  boolean_T UpperRelop;                /* '<S39>/UpperRelop' */\r\n  B_SpeedControl_mcb_pmsm_foc_q_T SpeedControl;/* '<Root>/Speed Control' */\r\n  B_SPIMasterTransfer_mcb_pmsm__T SPIMasterTransfer1;/* '<S253>/SPI Master Transfer' */\r\n  B_SPIMasterTransfer_mcb_pmsm__T SPIMasterTransfer;/* '<S253>/SPI Master Transfer' */\r\n  B_IfActionSubsystem1_mcb_pmsm_T IfActionSubsystem1_h;/* '<S182>/If Action Subsystem1' */\r\n  B_IfActionSubsystem_mcb_pmsm__T IfActionSubsystem_o;/* '<S182>/If Action Subsystem' */\r\n  B_TwoinputsCRL_mcb_pmsm_foc_q_T TwoinputsCRL_l;/* '<S175>/Two inputs CRL' */\r\n  B_IfActionSubsystem1_mcb_pmsm_T IfActionSubsystem1_m;/* '<S158>/If Action Subsystem1' */\r\n  B_IfActionSubsystem_mcb_pmsm__T IfActionSubsystem_m;/* '<S158>/If Action Subsystem' */\r\n  B_TwoinputsCRL_mcb_pmsm_foc_q_T TwoinputsCRL;/* '<S19>/Two inputs CRL' */\r\n} B_mcb_pmsm_foc_qep_f28379d_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  real32_T UnitDelay_DSTATE;           /* '<S200>/Unit Delay' */\r\n  real32_T RampGenerator_DSTATE;       /* '<S173>/Ramp Generator' */\r\n  real32_T UnitDelay_DSTATE_h;         /* '<S172>/Unit Delay' */\r\n  real32_T Integrator_DSTATE;          /* '<S134>/Integrator' */\r\n  real32_T Integrator_DSTATE_o;        /* '<S79>/Integrator' */\r\n  uint32_T Delay_DSTATE[20];           /* '<S197>/Delay' */\r\n  volatile real32_T RT1_Buffer[2];     /* '<Root>/RT1' */\r\n  volatile real32_T RT3_Buffer[2];     /* '<Root>/RT3' */\r\n  volatile real32_T RT2_Buffer[4];     /* '<Root>/RT2' */\r\n  real32_T SpeedRef;                   /* '<Root>/Data Store Memory4' */\r\n  int32_T DigitalOutput_FRAC_LEN;      /* '<S255>/Digital Output' */\r\n  int32_T DigitalOutput_FRAC_LEN_e;    /* '<S245>/Digital Output' */\r\n  int32_T DigitalOutput1_FRAC_LEN;     /* '<S245>/Digital Output1' */\r\n  int32_T Add_DWORK1[2];               /* '<S192>/Add' */\r\n  int32_T SpeedCount_DWORK1;           /* '<S197>/SpeedCount' */\r\n  int32_T DRV830xEnable_FRAC_LEN;      /* '<S223>/DRV830x Enable' */\r\n  uint32_T Add_DWORK1_n;               /* '<S227>/Add' */\r\n  uint32_T Sum_DWORK1[4];              /* '<S180>/Sum' */\r\n  uint16_T Output_DSTATE;              /* '<S229>/Output' */\r\n  uint16_T Delay3_DSTATE;              /* '<S194>/Delay3' */\r\n  volatile int16_T RT1_ActiveBufIdx;   /* '<Root>/RT1' */\r\n  volatile int16_T RT1_semaphoreTaken; /* '<Root>/RT1' */\r\n  volatile int16_T RT3_ActiveBufIdx;   /* '<Root>/RT3' */\r\n  volatile int16_T RT2_ActiveBufIdx;   /* '<Root>/RT2' */\r\n  uint16_T IaOffset;                   /* '<Root>/Data Store Memory1' */\r\n  uint16_T IbOffset;                   /* '<Root>/Data Store Memory2' */\r\n  uint16_T Debug_signals;              /* '<Root>/Data Store Memory6' */\r\n  uint16_T Memory_PreviousInput;       /* '<S252>/Memory' */\r\n  uint16_T Memory1_PreviousInput;      /* '<S252>/Memory1' */\r\n  uint16_T CircBufIdx;                 /* '<S197>/Delay' */\r\n  boolean_T Delay_DSTATE_m;            /* '<S191>/Delay' */\r\n  boolean_T Delay_DSTATE_j;            /* '<S188>/Delay' */\r\n  int16_T Integrator_PrevResetState;   /* '<S134>/Integrator' */\r\n  int16_T Integrator_PrevResetState_k; /* '<S79>/Integrator' */\r\n  boolean_T Enable;                    /* '<Root>/Data Store Memory29' */\r\n  boolean_T EnClosedLoop;              /* '<Root>/Data Store Memory3' */\r\n  boolean_T OpenLoopStartUp_MODE;      /* '<S8>/Open Loop Start-Up' */\r\n  DW_SpeedControl_mcb_pmsm_foc__T SpeedControl;/* '<Root>/Speed Control' */\r\n  DW_SPIMasterTransfer_mcb_pmsm_T SPIMasterTransfer1;/* '<S253>/SPI Master Transfer' */\r\n  DW_SPIMasterTransfer_mcb_pmsm_T SPIMasterTransfer;/* '<S253>/SPI Master Transfer' */\r\n} DW_mcb_pmsm_foc_qep_f28379d_T;\r\n\r\n/* Invariant block signals (default storage) */\r\ntypedef struct {\r\n  const uint32_T Width;                /* '<S226>/Width' */\r\n} ConstB_mcb_pmsm_foc_qep_f2837_T;\r\n\r\n/* Constant parameters (default storage) */\r\ntypedef struct {\r\n  /* Pooled Parameter (Expression: )\r\n   * Referenced by:\r\n   *   '<S156>/sine_table_values'\r\n   *   '<S180>/sine_table_values'\r\n   */\r\n  real32_T pooled5[1002];\r\n} ConstP_mcb_pmsm_foc_qep_f2837_T;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_mcb_pmsm_foc_qep_f283_T {\r\n  const char_T * volatile errorStatus;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    struct {\r\n      uint16_T TID[2];\r\n    } TaskCounters;\r\n  } Timing;\r\n};\r\n\r\n/* Block signals (default storage) */\r\nextern B_mcb_pmsm_foc_qep_f28379d_T mcb_pmsm_foc_qep_f28379d_B;\r\n\r\n/* Block states (default storage) */\r\nextern DW_mcb_pmsm_foc_qep_f28379d_T mcb_pmsm_foc_qep_f28379d_DW;\r\nextern const ConstB_mcb_pmsm_foc_qep_f2837_T mcb_pmsm_foc_qep_f28379d_ConstB;/* constant block i/o */\r\n\r\n/* Constant parameters (default storage) */\r\nextern const ConstP_mcb_pmsm_foc_qep_f2837_T mcb_pmsm_foc_qep_f28379d_ConstP;\r\n\r\n/* External function called from main */\r\nextern void mcb_pmsm_foc_qep_f28379d_SetEventsForThisBaseStep(boolean_T\r\n  *eventFlags);\r\n\r\n/* Model entry point functions */\r\nextern void mcb_pmsm_foc_qep_f28379d_initialize(void);\r\nextern void mcb_pmsm_foc_qep_f28379d_step0(void);/* Sample time: [0.0005s, 0.0s] */\r\nextern void mcb_pmsm_foc_qep_f28379d_step1(void);/* Sample time: [0.5s, 0.0s] */\r\nextern void mcb_pmsm_foc_qep_f28379d_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_mcb_pmsm_foc_qep_f28_T *const mcb_pmsm_foc_qep_f28379d_M;\r\nextern volatile boolean_T stopRequested;\r\nextern volatile boolean_T runModel;\r\n\r\n#ifdef __cpluscplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  interrupt void ADCB1_INT(void);\r\n  interrupt void SCIA_RX_INT(void);\r\n  void mcb_pmsm_foc_qep_f28379d_configure_interrupts (void);\r\n  void mcb_pmsm_foc_qep_f28379d_unconfigure_interrupts (void);\r\n\r\n#ifdef __cpluscplus\r\n\r\n}\r\n\r\n#endif\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'mcb_pmsm_foc_qep_f28379d'\r\n * '<S1>'   : 'mcb_pmsm_foc_qep_f28379d/Current Control'\r\n * '<S2>'   : 'mcb_pmsm_foc_qep_f28379d/HW Interrupt'\r\n * '<S3>'   : 'mcb_pmsm_foc_qep_f28379d/Hardware Init'\r\n * '<S4>'   : 'mcb_pmsm_foc_qep_f28379d/Heartbeat LED'\r\n * '<S5>'   : 'mcb_pmsm_foc_qep_f28379d/Inverter and Motor - Plant Model'\r\n * '<S6>'   : 'mcb_pmsm_foc_qep_f28379d/Serial Receive'\r\n * '<S7>'   : 'mcb_pmsm_foc_qep_f28379d/Speed Control'\r\n * '<S8>'   : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System'\r\n * '<S9>'   : 'mcb_pmsm_foc_qep_f28379d/Current Control/Debug_signals'\r\n * '<S10>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/HW_Inputs'\r\n * '<S11>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling'\r\n * '<S12>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Inverter'\r\n * '<S13>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Output Scaling'\r\n * '<S14>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/SCI_Tx'\r\n * '<S15>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control'\r\n * '<S16>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Open Loop Start-Up'\r\n * '<S17>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Clarke Transform'\r\n * '<S18>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers'\r\n * '<S19>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Inverse Park Transform'\r\n * '<S20>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Park Transform'\r\n * '<S21>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Sine-Cosine Lookup'\r\n * '<S22>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Space Vector Generator'\r\n * '<S23>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Clarke Transform/Two phase input'\r\n * '<S24>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Clarke Transform/Two phase input/Two phase CRL wrap'\r\n * '<S25>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/DQ Limiter'\r\n * '<S26>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id'\r\n * '<S27>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq'\r\n * '<S28>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/DQ Limiter/D-Q Equivalence'\r\n * '<S29>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/DQ Limiter/D//Q Axis Priority'\r\n * '<S30>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/DQ Limiter/Inport//Dialog Selection'\r\n * '<S31>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/DQ Limiter/Magnitude_calc'\r\n * '<S32>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/DQ Limiter/D-Q Equivalence/Limiter'\r\n * '<S33>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/DQ Limiter/D-Q Equivalence/Passthrough'\r\n * '<S34>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/DQ Limiter/D//Q Axis Priority/Compare To Constant'\r\n * '<S35>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/DQ Limiter/D//Q Axis Priority/Compare To Constant1'\r\n * '<S36>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/DQ Limiter/D//Q Axis Priority/flipInputs'\r\n * '<S37>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/DQ Limiter/D//Q Axis Priority/flipInputs1'\r\n * '<S38>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/DQ Limiter/D//Q Axis Priority/limiter'\r\n * '<S39>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/DQ Limiter/D//Q Axis Priority/limiter/limitRef1'\r\n * '<S40>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/DQ Limiter/D//Q Axis Priority/limiter/limitRef2'\r\n * '<S41>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/DQ Limiter/D//Q Axis Priority/limiter/passThrough'\r\n * '<S42>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset'\r\n * '<S43>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Anti-windup'\r\n * '<S44>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/D Gain'\r\n * '<S45>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/External Derivative'\r\n * '<S46>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Filter'\r\n * '<S47>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Filter ICs'\r\n * '<S48>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/I Gain'\r\n * '<S49>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Ideal P Gain'\r\n * '<S50>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Ideal P Gain Fdbk'\r\n * '<S51>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Integrator'\r\n * '<S52>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Integrator ICs'\r\n * '<S53>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/N Copy'\r\n * '<S54>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/N Gain'\r\n * '<S55>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/P Copy'\r\n * '<S56>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Parallel P Gain'\r\n * '<S57>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Reset Signal'\r\n * '<S58>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Saturation'\r\n * '<S59>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Saturation Fdbk'\r\n * '<S60>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Sum'\r\n * '<S61>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Sum Fdbk'\r\n * '<S62>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Tracking Mode'\r\n * '<S63>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Tracking Mode Sum'\r\n * '<S64>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Tsamp - Integral'\r\n * '<S65>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Tsamp - Ngain'\r\n * '<S66>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/postSat Signal'\r\n * '<S67>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/preInt Signal'\r\n * '<S68>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/preSat Signal'\r\n * '<S69>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Anti-windup/Disc. Clamping Parallel'\r\n * '<S70>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n * '<S71>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\r\n * '<S72>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/D Gain/Disabled'\r\n * '<S73>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/External Derivative/Disabled'\r\n * '<S74>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Filter/Disabled'\r\n * '<S75>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Filter ICs/Disabled'\r\n * '<S76>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/I Gain/External Parameters'\r\n * '<S77>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Ideal P Gain/Passthrough'\r\n * '<S78>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Ideal P Gain Fdbk/Disabled'\r\n * '<S79>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Integrator/Discrete'\r\n * '<S80>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Integrator ICs/External IC'\r\n * '<S81>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/N Copy/Disabled wSignal Specification'\r\n * '<S82>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/N Gain/Disabled'\r\n * '<S83>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/P Copy/Disabled'\r\n * '<S84>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Parallel P Gain/External Parameters'\r\n * '<S85>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Reset Signal/External Reset'\r\n * '<S86>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Saturation/Enabled'\r\n * '<S87>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Saturation Fdbk/Disabled'\r\n * '<S88>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Sum/Sum_PI'\r\n * '<S89>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Sum Fdbk/Disabled'\r\n * '<S90>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Tracking Mode/Disabled'\r\n * '<S91>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Tracking Mode Sum/Passthrough'\r\n * '<S92>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Tsamp - Integral/TsSignalSpecification'\r\n * '<S93>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/Tsamp - Ngain/Passthrough'\r\n * '<S94>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/postSat Signal/Forward_Path'\r\n * '<S95>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/preInt Signal/Internal PreInt'\r\n * '<S96>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Id/Discrete PI Controller  with anti-windup & reset/preSat Signal/Forward_Path'\r\n * '<S97>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset'\r\n * '<S98>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Anti-windup'\r\n * '<S99>'  : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/D Gain'\r\n * '<S100>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/External Derivative'\r\n * '<S101>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Filter'\r\n * '<S102>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Filter ICs'\r\n * '<S103>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/I Gain'\r\n * '<S104>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Ideal P Gain'\r\n * '<S105>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Ideal P Gain Fdbk'\r\n * '<S106>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Integrator'\r\n * '<S107>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Integrator ICs'\r\n * '<S108>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/N Copy'\r\n * '<S109>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/N Gain'\r\n * '<S110>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/P Copy'\r\n * '<S111>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Parallel P Gain'\r\n * '<S112>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Reset Signal'\r\n * '<S113>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Saturation'\r\n * '<S114>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Saturation Fdbk'\r\n * '<S115>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Sum'\r\n * '<S116>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Sum Fdbk'\r\n * '<S117>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Tracking Mode'\r\n * '<S118>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Tracking Mode Sum'\r\n * '<S119>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Tsamp - Integral'\r\n * '<S120>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Tsamp - Ngain'\r\n * '<S121>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/postSat Signal'\r\n * '<S122>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/preInt Signal'\r\n * '<S123>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/preSat Signal'\r\n * '<S124>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Anti-windup/Disc. Clamping Parallel'\r\n * '<S125>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n * '<S126>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\r\n * '<S127>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/D Gain/Disabled'\r\n * '<S128>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/External Derivative/Disabled'\r\n * '<S129>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Filter/Disabled'\r\n * '<S130>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Filter ICs/Disabled'\r\n * '<S131>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/I Gain/External Parameters'\r\n * '<S132>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Ideal P Gain/Passthrough'\r\n * '<S133>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Ideal P Gain Fdbk/Disabled'\r\n * '<S134>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Integrator/Discrete'\r\n * '<S135>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Integrator ICs/External IC'\r\n * '<S136>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/N Copy/Disabled wSignal Specification'\r\n * '<S137>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/N Gain/Disabled'\r\n * '<S138>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/P Copy/Disabled'\r\n * '<S139>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Parallel P Gain/External Parameters'\r\n * '<S140>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Reset Signal/External Reset'\r\n * '<S141>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Saturation/Enabled'\r\n * '<S142>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Saturation Fdbk/Disabled'\r\n * '<S143>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Sum/Sum_PI'\r\n * '<S144>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Sum Fdbk/Disabled'\r\n * '<S145>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Tracking Mode/Disabled'\r\n * '<S146>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Tracking Mode Sum/Passthrough'\r\n * '<S147>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Tsamp - Integral/TsSignalSpecification'\r\n * '<S148>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/Tsamp - Ngain/Passthrough'\r\n * '<S149>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/postSat Signal/Forward_Path'\r\n * '<S150>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/preInt Signal/Internal PreInt'\r\n * '<S151>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Current_Controllers/PI_Controller_Iq/Discrete PI Controller  with anti-windup & reset/preSat Signal/Forward_Path'\r\n * '<S152>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Inverse Park Transform/Two inputs CRL'\r\n * '<S153>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Inverse Park Transform/Two inputs CRL/Switch_Axis'\r\n * '<S154>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Park Transform/Two inputs CRL'\r\n * '<S155>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Park Transform/Two inputs CRL/Switch_Axis'\r\n * '<S156>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Sine-Cosine Lookup/Sine-Cosine Lookup'\r\n * '<S157>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Sine-Cosine Lookup/Sine-Cosine Lookup/Interpolation'\r\n * '<S158>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Sine-Cosine Lookup/Sine-Cosine Lookup/WrapUp'\r\n * '<S159>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Sine-Cosine Lookup/Sine-Cosine Lookup/datatype'\r\n * '<S160>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Sine-Cosine Lookup/Sine-Cosine Lookup/WrapUp/Compare To Zero'\r\n * '<S161>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Sine-Cosine Lookup/Sine-Cosine Lookup/WrapUp/If Action Subsystem'\r\n * '<S162>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Sine-Cosine Lookup/Sine-Cosine Lookup/WrapUp/If Action Subsystem1'\r\n * '<S163>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Sine-Cosine Lookup/Sine-Cosine Lookup/datatype/datatype no change'\r\n * '<S164>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Space Vector Generator/Modulation method'\r\n * '<S165>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Space Vector Generator/Voltage Input'\r\n * '<S166>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Space Vector Generator/Modulation method/SVPWM'\r\n * '<S167>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Space Vector Generator/Modulation method/SVPWM/Half(Vmin+Vmax)'\r\n * '<S168>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Space Vector Generator/Voltage Input/Valphabeta'\r\n * '<S169>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Space Vector Generator/Voltage Input/Valphabeta/Inverse Clarke Transform'\r\n * '<S170>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Closed Loop Control/Space Vector Generator/Voltage Input/Valphabeta/Inverse Clarke Transform/Two phase input'\r\n * '<S171>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Open Loop Start-Up/3-Phase Sine Voltage Generator'\r\n * '<S172>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Open Loop Start-Up/Position Generator1'\r\n * '<S173>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Open Loop Start-Up/Ramp Generator'\r\n * '<S174>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Open Loop Start-Up/3-Phase Sine Voltage Generator/Inverse Clarke Transform'\r\n * '<S175>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Open Loop Start-Up/3-Phase Sine Voltage Generator/Inverse Park Transform'\r\n * '<S176>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Open Loop Start-Up/3-Phase Sine Voltage Generator/Sine-Cosine Lookup'\r\n * '<S177>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Open Loop Start-Up/3-Phase Sine Voltage Generator/Inverse Clarke Transform/Two phase input'\r\n * '<S178>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Open Loop Start-Up/3-Phase Sine Voltage Generator/Inverse Park Transform/Two inputs CRL'\r\n * '<S179>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Open Loop Start-Up/3-Phase Sine Voltage Generator/Inverse Park Transform/Two inputs CRL/Switch_Axis'\r\n * '<S180>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Open Loop Start-Up/3-Phase Sine Voltage Generator/Sine-Cosine Lookup/Sine-Cosine Lookup'\r\n * '<S181>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Open Loop Start-Up/3-Phase Sine Voltage Generator/Sine-Cosine Lookup/Sine-Cosine Lookup/Interpolation'\r\n * '<S182>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Open Loop Start-Up/3-Phase Sine Voltage Generator/Sine-Cosine Lookup/Sine-Cosine Lookup/WrapUp'\r\n * '<S183>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Open Loop Start-Up/3-Phase Sine Voltage Generator/Sine-Cosine Lookup/Sine-Cosine Lookup/datatype'\r\n * '<S184>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Open Loop Start-Up/3-Phase Sine Voltage Generator/Sine-Cosine Lookup/Sine-Cosine Lookup/WrapUp/Compare To Zero'\r\n * '<S185>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Open Loop Start-Up/3-Phase Sine Voltage Generator/Sine-Cosine Lookup/Sine-Cosine Lookup/WrapUp/If Action Subsystem'\r\n * '<S186>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Open Loop Start-Up/3-Phase Sine Voltage Generator/Sine-Cosine Lookup/Sine-Cosine Lookup/WrapUp/If Action Subsystem1'\r\n * '<S187>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Open Loop Start-Up/3-Phase Sine Voltage Generator/Sine-Cosine Lookup/Sine-Cosine Lookup/datatype/datatype no change'\r\n * '<S188>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Open Loop Start-Up/Position Generator1/Accumulate'\r\n * '<S189>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Control_System/Open Loop Start-Up/Position Generator1/Accumulate/Subsystem'\r\n * '<S190>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/HW_Inputs/Sensor Driver Blocks (codegen)'\r\n * '<S191>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed'\r\n * '<S192>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/Calculate Phase Currents'\r\n * '<S193>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/IIR Filter'\r\n * '<S194>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/IndexFinder'\r\n * '<S195>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/Mechanical to Electrical Position'\r\n * '<S196>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/Quadrature Decoder'\r\n * '<S197>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/Speed Measurement'\r\n * '<S198>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/IIR Filter/IIR Filter'\r\n * '<S199>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/IIR Filter/IIR Filter/Low-pass'\r\n * '<S200>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/IIR Filter/IIR Filter/Low-pass/IIR Low Pass Filter'\r\n * '<S201>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/IndexFinder/Compare To Constant'\r\n * '<S202>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/IndexFinder/Compare To Constant1'\r\n * '<S203>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/Mechanical to Electrical Position/MechToElec'\r\n * '<S204>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/Mechanical to Electrical Position/MechToElec/floating-point'\r\n * '<S205>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/Mechanical to Electrical Position/MechToElec/floating-point/Compensate Offset'\r\n * '<S206>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/Mechanical to Electrical Position/MechToElec/floating-point/Mech To Elec'\r\n * '<S207>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/Mechanical to Electrical Position/MechToElec/floating-point/Compensate Offset/If Action Subsystem'\r\n * '<S208>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/Mechanical to Electrical Position/MechToElec/floating-point/Compensate Offset/If Action Subsystem1'\r\n * '<S209>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/Mechanical to Electrical Position/MechToElec/floating-point/Mech To Elec/Variant Subsystem'\r\n * '<S210>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/Mechanical to Electrical Position/MechToElec/floating-point/Mech To Elec/Variant Subsystem/Dialog'\r\n * '<S211>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/Quadrature Decoder/DT_Handle'\r\n * '<S212>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/Quadrature Decoder/PositionNoReset'\r\n * '<S213>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/Quadrature Decoder/PositionResetAtIndex'\r\n * '<S214>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/Quadrature Decoder/Variant Subsystem'\r\n * '<S215>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/Quadrature Decoder/DT_Handle/floating-point'\r\n * '<S216>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/Quadrature Decoder/PositionNoReset/Variant Subsystem'\r\n * '<S217>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/Quadrature Decoder/PositionNoReset/Variant Subsystem/Dialog'\r\n * '<S218>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/Quadrature Decoder/Variant Subsystem/Dialog'\r\n * '<S219>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/Speed Measurement/DT_Handle'\r\n * '<S220>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/ Calculate Position and Speed/Speed Measurement/DT_Handle/floating-point'\r\n * '<S221>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/Calculate Phase Currents/Data_Type'\r\n * '<S222>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Input Scaling/Calculate Phase Currents/Data_Type/Data_Type_Float'\r\n * '<S223>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/Inverter/Code Generation'\r\n * '<S224>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/SCI_Tx/Code Generation'\r\n * '<S225>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/SCI_Tx/Code Generation/Data_Conditioning_Tx'\r\n * '<S226>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/SCI_Tx/Code Generation/Data_Logging'\r\n * '<S227>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/SCI_Tx/Code Generation/While Iterator Subsystem'\r\n * '<S228>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/SCI_Tx/Code Generation/Data_Conditioning_Tx/Data_Type_Float'\r\n * '<S229>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/SCI_Tx/Code Generation/Data_Logging/Counter Limited'\r\n * '<S230>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/SCI_Tx/Code Generation/Data_Logging/Data'\r\n * '<S231>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/SCI_Tx/Code Generation/Data_Logging/End'\r\n * '<S232>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/SCI_Tx/Code Generation/Data_Logging/Start'\r\n * '<S233>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/SCI_Tx/Code Generation/Data_Logging/Counter Limited/Increment Real World'\r\n * '<S234>' : 'mcb_pmsm_foc_qep_f28379d/Current Control/SCI_Tx/Code Generation/Data_Logging/Counter Limited/Wrap To Zero'\r\n * '<S235>' : 'mcb_pmsm_foc_qep_f28379d/HW Interrupt/Code generation'\r\n * '<S236>' : 'mcb_pmsm_foc_qep_f28379d/HW Interrupt/Code generation/HWI_ADCB1_INT'\r\n * '<S237>' : 'mcb_pmsm_foc_qep_f28379d/HW Interrupt/Code generation/HWI_SCIA_RX_INT'\r\n * '<S238>' : 'mcb_pmsm_foc_qep_f28379d/HW Interrupt/Code generation/HWI_ADCB1_INT/ECSoC'\r\n * '<S239>' : 'mcb_pmsm_foc_qep_f28379d/HW Interrupt/Code generation/HWI_ADCB1_INT/ECSoC/ECSimCodegen'\r\n * '<S240>' : 'mcb_pmsm_foc_qep_f28379d/HW Interrupt/Code generation/HWI_SCIA_RX_INT/ECSoC'\r\n * '<S241>' : 'mcb_pmsm_foc_qep_f28379d/HW Interrupt/Code generation/HWI_SCIA_RX_INT/ECSoC/ECSimCodegen'\r\n * '<S242>' : 'mcb_pmsm_foc_qep_f28379d/Hardware Init/Variant Subsystem'\r\n * '<S243>' : 'mcb_pmsm_foc_qep_f28379d/Hardware Init/Variant Subsystem/Code Generation'\r\n * '<S244>' : 'mcb_pmsm_foc_qep_f28379d/Hardware Init/Variant Subsystem/Code Generation/Calculate ADC Offset '\r\n * '<S245>' : 'mcb_pmsm_foc_qep_f28379d/Hardware Init/Variant Subsystem/Code Generation/DRV Enable'\r\n * '<S246>' : 'mcb_pmsm_foc_qep_f28379d/Hardware Init/Variant Subsystem/Code Generation/Default ADC Offset'\r\n * '<S247>' : 'mcb_pmsm_foc_qep_f28379d/Hardware Init/Variant Subsystem/Code Generation/Calculate ADC Offset /For Iterator Subsystem'\r\n * '<S248>' : 'mcb_pmsm_foc_qep_f28379d/Hardware Init/Variant Subsystem/Code Generation/Calculate ADC Offset /If Action Subsystem'\r\n * '<S249>' : 'mcb_pmsm_foc_qep_f28379d/Hardware Init/Variant Subsystem/Code Generation/Calculate ADC Offset /If Action Subsystem1'\r\n * '<S250>' : 'mcb_pmsm_foc_qep_f28379d/Hardware Init/Variant Subsystem/Code Generation/Calculate ADC Offset /If Action Subsystem2'\r\n * '<S251>' : 'mcb_pmsm_foc_qep_f28379d/Hardware Init/Variant Subsystem/Code Generation/Calculate ADC Offset /If Action Subsystem3'\r\n * '<S252>' : 'mcb_pmsm_foc_qep_f28379d/Hardware Init/Variant Subsystem/Code Generation/Calculate ADC Offset /For Iterator Subsystem/If Action Subsystem'\r\n * '<S253>' : 'mcb_pmsm_foc_qep_f28379d/Hardware Init/Variant Subsystem/Code Generation/DRV Enable/ADC Gain setting'\r\n * '<S254>' : 'mcb_pmsm_foc_qep_f28379d/Heartbeat LED/Heartbeat LED'\r\n * '<S255>' : 'mcb_pmsm_foc_qep_f28379d/Heartbeat LED/Heartbeat LED/Code generation'\r\n * '<S256>' : 'mcb_pmsm_foc_qep_f28379d/Inverter and Motor - Plant Model/Codegeneration'\r\n * '<S257>' : 'mcb_pmsm_foc_qep_f28379d/Serial Receive/Data_Conditioning_Rx'\r\n * '<S258>' : 'mcb_pmsm_foc_qep_f28379d/Serial Receive/SCI_Rx'\r\n * '<S259>' : 'mcb_pmsm_foc_qep_f28379d/Serial Receive/unParse'\r\n * '<S260>' : 'mcb_pmsm_foc_qep_f28379d/Serial Receive/Data_Conditioning_Rx/Data_Type_Float'\r\n * '<S261>' : 'mcb_pmsm_foc_qep_f28379d/Serial Receive/SCI_Rx/Code Generation'\r\n * '<S262>' : 'mcb_pmsm_foc_qep_f28379d/Serial Receive/SCI_Rx/Code Generation/Data_Type_Float'\r\n * '<S263>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed'\r\n * '<S264>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/Speed_Ref_Selector'\r\n * '<S265>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset'\r\n * '<S266>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Zero_Cancellation'\r\n * '<S267>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Anti-windup'\r\n * '<S268>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/D Gain'\r\n * '<S269>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/External Derivative'\r\n * '<S270>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Filter'\r\n * '<S271>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Filter ICs'\r\n * '<S272>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/I Gain'\r\n * '<S273>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Ideal P Gain'\r\n * '<S274>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Ideal P Gain Fdbk'\r\n * '<S275>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Integrator'\r\n * '<S276>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Integrator ICs'\r\n * '<S277>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/N Copy'\r\n * '<S278>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/N Gain'\r\n * '<S279>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/P Copy'\r\n * '<S280>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Parallel P Gain'\r\n * '<S281>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Reset Signal'\r\n * '<S282>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Saturation'\r\n * '<S283>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Saturation Fdbk'\r\n * '<S284>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Sum'\r\n * '<S285>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Sum Fdbk'\r\n * '<S286>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Tracking Mode'\r\n * '<S287>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Tracking Mode Sum'\r\n * '<S288>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Tsamp - Integral'\r\n * '<S289>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Tsamp - Ngain'\r\n * '<S290>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/postSat Signal'\r\n * '<S291>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/preInt Signal'\r\n * '<S292>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/preSat Signal'\r\n * '<S293>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Anti-windup/Disc. Clamping Parallel'\r\n * '<S294>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n * '<S295>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\r\n * '<S296>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/D Gain/Disabled'\r\n * '<S297>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/External Derivative/Disabled'\r\n * '<S298>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Filter/Disabled'\r\n * '<S299>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Filter ICs/Disabled'\r\n * '<S300>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/I Gain/External Parameters'\r\n * '<S301>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Ideal P Gain/Passthrough'\r\n * '<S302>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Ideal P Gain Fdbk/Disabled'\r\n * '<S303>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Integrator/Discrete'\r\n * '<S304>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Integrator ICs/External IC'\r\n * '<S305>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/N Copy/Disabled wSignal Specification'\r\n * '<S306>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/N Gain/Disabled'\r\n * '<S307>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/P Copy/Disabled'\r\n * '<S308>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Parallel P Gain/External Parameters'\r\n * '<S309>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Reset Signal/External Reset'\r\n * '<S310>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Saturation/Enabled'\r\n * '<S311>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Saturation Fdbk/Disabled'\r\n * '<S312>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Sum/Sum_PI'\r\n * '<S313>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Sum Fdbk/Disabled'\r\n * '<S314>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Tracking Mode/Disabled'\r\n * '<S315>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Tracking Mode Sum/Passthrough'\r\n * '<S316>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Tsamp - Integral/TsSignalSpecification'\r\n * '<S317>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/Tsamp - Ngain/Passthrough'\r\n * '<S318>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/postSat Signal/Forward_Path'\r\n * '<S319>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/preInt Signal/Internal PreInt'\r\n * '<S320>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Discrete PI Controller  with anti-windup & reset/preSat Signal/Forward_Path'\r\n * '<S321>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Zero_Cancellation/IIR Filter'\r\n * '<S322>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Zero_Cancellation/IIR Filter/Low-pass'\r\n * '<S323>' : 'mcb_pmsm_foc_qep_f28379d/Speed Control/PI_Controller_Speed/Zero_Cancellation/IIR Filter/Low-pass/IIR Low Pass Filter'\r\n */\r\n#endif                                 /* mcb_pmsm_foc_qep_f28379d_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"mcb_pmsm_foc_qep_f28379d_private.h","type":"header","group":"model","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: mcb_pmsm_foc_qep_f28379d_private.h\r\n *\r\n * Code generated for Simulink model 'mcb_pmsm_foc_qep_f28379d'.\r\n *\r\n * Model version                  : 9.0\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Tue Dec 10 10:17:02 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef mcb_pmsm_foc_qep_f28379d_private_h_\r\n#define mcb_pmsm_foc_qep_f28379d_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"mcb_pmsm_foc_qep_f28379d.h\"\r\n#include \"mcb_pmsm_foc_qep_f28379d_types.h\"\r\n\r\nvoid config_QEP_eQEP1(uint32_T pcmaximumvalue, uint32_T pcInitialvalue, uint32_T\r\n                      unittimerperiod, uint32_T comparevalue, uint16_T\r\n                      watchdogtimer, uint16_T qdecctl, uint16_T qepctl, uint16_T\r\n                      qposctl, uint16_T qcapctl, uint16_T qeint);\r\n\r\n#ifndef UCHAR_MAX\r\n#include <limits.h>\r\n#endif\r\n\r\n#if ( UCHAR_MAX != (0xFFFFU) ) || ( SCHAR_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized uchar/char. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized ushort/short. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( UINT_MAX != (0xFFFFU) ) || ( INT_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized uint/int. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( ULONG_MAX != (0xFFFFFFFFUL) ) || ( LONG_MAX != (0x7FFFFFFFL) )\r\n#error Code was generated for compiler with different sized ulong/long. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n/* Skipping ulong_long/long_long check: insufficient preprocessor integer range. */\r\nvoid InitAdcC (void);\r\nvoid config_ADCC_SOC0 (void);\r\nvoid InitAdcB (void);\r\nvoid config_ADCB_SOC0 (void);\r\nvoid config_ADCC_SOC2 (void);\r\nvoid config_ADCB_SOC2 (void);\r\nextern uint16_T MW_adcCInitFlag;\r\nextern uint16_T MW_adcBInitFlag;\r\nextern void mcb_pmsm_foc_q_TwoinputsCRL(real32_T rtu_Ds, real32_T rtu_Qs,\r\n  real32_T rtu_sin, real32_T rtu_cos, B_TwoinputsCRL_mcb_pmsm_foc_q_T *localB);\r\nextern void mcb_pmsm__IfActionSubsystem(real32_T rtu_In1, real32_T *rty_Out1,\r\n  B_IfActionSubsystem_mcb_pmsm__T *localB);\r\nextern void mcb_pmsm_IfActionSubsystem1(real32_T rtu_In1, real32_T *rty_Out1,\r\n  B_IfActionSubsystem1_mcb_pmsm_T *localB);\r\nextern void mcb__SPIMasterTransfer_Init(DW_SPIMasterTransfer_mcb_pmsm_T *localDW);\r\nextern void mcb_pmsm__SPIMasterTransfer(uint16_T rtu_0,\r\n  B_SPIMasterTransfer_mcb_pmsm__T *localB, DW_SPIMasterTransfer_mcb_pmsm_T\r\n  *localDW);\r\nextern void mcb_pmsm__SpeedControl_Init(B_SpeedControl_mcb_pmsm_foc_q_T *localB,\r\n  DW_SpeedControl_mcb_pmsm_foc__T *localDW);\r\nextern void mcb_pmsm_foc_q_SpeedControl(real32_T rtu_Speed_Ref_PU, real32_T\r\n  rtu_Speed_Meas_PU, const boolean_T *rtd_EnClosedLoop, const boolean_T\r\n  *rtd_Enable, B_SpeedControl_mcb_pmsm_foc_q_T *localB,\r\n  DW_SpeedControl_mcb_pmsm_foc__T *localDW);\r\nextern void mcb_pms_CurrentControl_Init(void);\r\nextern void mcb_pm_CurrentControl_Reset(void);\r\n\r\n#pragma CODE_SECTION (mcb__CurrentControl_Disable, \"ramfuncs\")\r\n\r\nextern void mcb__CurrentControl_Disable(void);\r\n\r\n#pragma CODE_SECTION (mcb_pmsm_foc_CurrentControl, \"ramfuncs\")\r\n\r\nextern void mcb_pmsm_foc_CurrentControl(void);\r\nextern void mcb__SPIMasterTransfer_Term(DW_SPIMasterTransfer_mcb_pmsm_T *localDW);\r\n\r\n#endif                                 /* mcb_pmsm_foc_qep_f28379d_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"mcb_pmsm_foc_qep_f28379d_types.h","type":"header","group":"model","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: mcb_pmsm_foc_qep_f28379d_types.h\r\n *\r\n * Code generated for Simulink model 'mcb_pmsm_foc_qep_f28379d'.\r\n *\r\n * Model version                  : 9.0\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Tue Dec 10 10:17:02 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef mcb_pmsm_foc_qep_f28379d_types_h_\r\n#define mcb_pmsm_foc_qep_f28379d_types_h_\r\n#include \"rtwtypes.h\"\r\n#include \"MW_c2000SPI.h\"\r\n\r\n/* Custom Type definition for MATLABSystem: '<S253>/SPI Master Transfer' */\r\n#include \"MW_c2000SPI.h\"\r\n#ifndef struct_tag_X3nhL3sVVdEpin6phQ7ajF\r\n#define struct_tag_X3nhL3sVVdEpin6phQ7ajF\r\n\r\nstruct tag_X3nhL3sVVdEpin6phQ7ajF\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  MW_Handle_Type MW_SPI_HANDLE;\r\n};\r\n\r\n#endif                                 /* struct_tag_X3nhL3sVVdEpin6phQ7ajF */\r\n\r\n#ifndef typedef_codertarget_tic2000_blocks_SP_T\r\n#define typedef_codertarget_tic2000_blocks_SP_T\r\n\r\ntypedef struct tag_X3nhL3sVVdEpin6phQ7ajF codertarget_tic2000_blocks_SP_T;\r\n\r\n#endif                             /* typedef_codertarget_tic2000_blocks_SP_T */\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_mcb_pmsm_foc_qep_f283_T RT_MODEL_mcb_pmsm_foc_qep_f28_T;\r\n\r\n#endif                                 /* mcb_pmsm_foc_qep_f28379d_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"mcb_pmsm_foc_qep_f28379d_data.c","type":"source","group":"data","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: mcb_pmsm_foc_qep_f28379d_data.c\r\n *\r\n * Code generated for Simulink model 'mcb_pmsm_foc_qep_f28379d'.\r\n *\r\n * Model version                  : 9.0\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Tue Dec 10 10:17:02 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"mcb_pmsm_foc_qep_f28379d.h\"\r\n\r\n/* Invariant block signals (default storage) */\r\nconst ConstB_mcb_pmsm_foc_qep_f2837_T mcb_pmsm_foc_qep_f28379d_ConstB = {\r\n  2U                                   /* '<S226>/Width' */\r\n};\r\n\r\n/* Constant parameters (default storage) */\r\nconst ConstP_mcb_pmsm_foc_qep_f2837_T mcb_pmsm_foc_qep_f28379d_ConstP = {\r\n  /* Pooled Parameter (Expression: )\r\n   * Referenced by:\r\n   *   '<S156>/sine_table_values'\r\n   *   '<S180>/sine_table_values'\r\n   */\r\n  { 0.0F, 0.00785390101F, 0.0157073177F, 0.023559764F, 0.0314107575F,\r\n    0.0392598175F, 0.0471064523F, 0.0549501814F, 0.0627905205F, 0.070626989F,\r\n    0.0784591F, 0.086286366F, 0.0941083133F, 0.101924457F, 0.109734312F,\r\n    0.117537394F, 0.125333235F, 0.133121341F, 0.140901238F, 0.148672432F,\r\n    0.156434461F, 0.16418685F, 0.171929106F, 0.179660752F, 0.187381312F,\r\n    0.195090324F, 0.202787295F, 0.210471764F, 0.21814324F, 0.225801274F,\r\n    0.233445361F, 0.241075054F, 0.24868989F, 0.256289363F, 0.263873041F,\r\n    0.271440446F, 0.278991103F, 0.286524564F, 0.294040322F, 0.301537961F,\r\n    0.309017F, 0.316476971F, 0.323917419F, 0.331337899F, 0.338737935F,\r\n    0.346117049F, 0.353474855F, 0.360810816F, 0.368124545F, 0.375415564F,\r\n    0.382683426F, 0.389927685F, 0.397147894F, 0.404343605F, 0.411514372F,\r\n    0.418659747F, 0.425779283F, 0.432872593F, 0.439939171F, 0.446978629F,\r\n    0.453990489F, 0.460974365F, 0.46792981F, 0.474856377F, 0.481753677F,\r\n    0.488621235F, 0.495458663F, 0.502265513F, 0.509041429F, 0.515785873F,\r\n    0.522498548F, 0.529179F, 0.535826802F, 0.542441547F, 0.549022794F,\r\n    0.555570245F, 0.562083364F, 0.568561852F, 0.575005233F, 0.581413209F,\r\n    0.587785244F, 0.594121039F, 0.600420237F, 0.60668236F, 0.612907052F,\r\n    0.619093955F, 0.625242651F, 0.631352782F, 0.637424F, 0.643455863F,\r\n    0.649448037F, 0.655400157F, 0.661311865F, 0.667182744F, 0.673012495F,\r\n    0.678800762F, 0.684547126F, 0.690251231F, 0.695912778F, 0.70153141F,\r\n    0.707106769F, 0.712638497F, 0.718126297F, 0.723569751F, 0.72896862F,\r\n    0.734322488F, 0.739631116F, 0.744894F, 0.750111043F, 0.755281806F,\r\n    0.760405958F, 0.765483201F, 0.770513237F, 0.775495768F, 0.780430436F,\r\n    0.785316944F, 0.790155F, 0.794944346F, 0.799684644F, 0.804375648F, 0.809017F,\r\n    0.813608468F, 0.818149745F, 0.822640538F, 0.827080548F, 0.831469595F,\r\n    0.835807383F, 0.840093553F, 0.844327927F, 0.848510206F, 0.852640152F,\r\n    0.856717527F, 0.860742033F, 0.86471343F, 0.868631542F, 0.872496F,\r\n    0.876306653F, 0.880063295F, 0.883765638F, 0.887413442F, 0.891006529F,\r\n    0.894544661F, 0.898027599F, 0.901455104F, 0.904827058F, 0.908143163F,\r\n    0.911403298F, 0.914607167F, 0.91775465F, 0.920845509F, 0.923879504F,\r\n    0.926856577F, 0.92977649F, 0.932639F, 0.935444057F, 0.938191354F,\r\n    0.940880775F, 0.943512142F, 0.946085334F, 0.948600173F, 0.95105654F,\r\n    0.953454196F, 0.955793F, 0.958072901F, 0.96029371F, 0.962455213F,\r\n    0.964557409F, 0.96660012F, 0.968583167F, 0.970506489F, 0.972369909F,\r\n    0.974173367F, 0.975916743F, 0.977599919F, 0.979222834F, 0.980785251F,\r\n    0.982287228F, 0.983728647F, 0.985109329F, 0.986429274F, 0.987688363F,\r\n    0.988886476F, 0.990023673F, 0.991099775F, 0.992114723F, 0.993068457F,\r\n    0.993961F, 0.994792163F, 0.995561957F, 0.996270359F, 0.996917307F,\r\n    0.997502804F, 0.998026729F, 0.998489082F, 0.998889863F, 0.999229F,\r\n    0.999506533F, 0.999722421F, 0.999876618F, 0.999969184F, 1.0F, 0.999969184F,\r\n    0.999876618F, 0.999722421F, 0.999506533F, 0.999229F, 0.998889863F,\r\n    0.998489082F, 0.998026729F, 0.997502804F, 0.996917307F, 0.996270359F,\r\n    0.995561957F, 0.994792163F, 0.993961F, 0.993068457F, 0.992114723F,\r\n    0.991099775F, 0.990023673F, 0.988886476F, 0.987688363F, 0.986429274F,\r\n    0.985109329F, 0.983728647F, 0.982287228F, 0.980785251F, 0.979222834F,\r\n    0.977599919F, 0.975916743F, 0.974173367F, 0.972369909F, 0.970506489F,\r\n    0.968583167F, 0.96660012F, 0.964557409F, 0.962455213F, 0.96029371F,\r\n    0.958072901F, 0.955793F, 0.953454196F, 0.95105654F, 0.948600173F,\r\n    0.946085334F, 0.943512142F, 0.940880775F, 0.938191354F, 0.935444057F,\r\n    0.932639F, 0.92977649F, 0.926856577F, 0.923879504F, 0.920845509F,\r\n    0.91775465F, 0.914607167F, 0.911403298F, 0.908143163F, 0.904827058F,\r\n    0.901455104F, 0.898027599F, 0.894544661F, 0.891006529F, 0.887413442F,\r\n    0.883765638F, 0.880063295F, 0.876306653F, 0.872496F, 0.868631542F,\r\n    0.86471343F, 0.860742033F, 0.856717527F, 0.852640152F, 0.848510206F,\r\n    0.844327927F, 0.840093553F, 0.835807383F, 0.831469595F, 0.827080548F,\r\n    0.822640538F, 0.818149745F, 0.813608468F, 0.809017F, 0.804375648F,\r\n    0.799684644F, 0.794944346F, 0.790155F, 0.785316944F, 0.780430436F,\r\n    0.775495768F, 0.770513237F, 0.765483201F, 0.760405958F, 0.755281806F,\r\n    0.750111043F, 0.744894F, 0.739631116F, 0.734322488F, 0.72896862F,\r\n    0.723569751F, 0.718126297F, 0.712638497F, 0.707106769F, 0.70153141F,\r\n    0.695912778F, 0.690251231F, 0.684547126F, 0.678800762F, 0.673012495F,\r\n    0.667182744F, 0.661311865F, 0.655400157F, 0.649448037F, 0.643455863F,\r\n    0.637424F, 0.631352782F, 0.625242651F, 0.619093955F, 0.612907052F,\r\n    0.60668236F, 0.600420237F, 0.594121039F, 0.587785244F, 0.581413209F,\r\n    0.575005233F, 0.568561852F, 0.562083364F, 0.555570245F, 0.549022794F,\r\n    0.542441547F, 0.535826802F, 0.529179F, 0.522498548F, 0.515785873F,\r\n    0.509041429F, 0.502265513F, 0.495458663F, 0.488621235F, 0.481753677F,\r\n    0.474856377F, 0.46792981F, 0.460974365F, 0.453990489F, 0.446978629F,\r\n    0.439939171F, 0.432872593F, 0.425779283F, 0.418659747F, 0.411514372F,\r\n    0.404343605F, 0.397147894F, 0.389927685F, 0.382683426F, 0.375415564F,\r\n    0.368124545F, 0.360810816F, 0.353474855F, 0.346117049F, 0.338737935F,\r\n    0.331337899F, 0.323917419F, 0.316476971F, 0.309017F, 0.301537961F,\r\n    0.294040322F, 0.286524564F, 0.278991103F, 0.271440446F, 0.263873041F,\r\n    0.256289363F, 0.24868989F, 0.241075054F, 0.233445361F, 0.225801274F,\r\n    0.21814324F, 0.210471764F, 0.202787295F, 0.195090324F, 0.187381312F,\r\n    0.179660752F, 0.171929106F, 0.16418685F, 0.156434461F, 0.148672432F,\r\n    0.140901238F, 0.133121341F, 0.125333235F, 0.117537394F, 0.109734312F,\r\n    0.101924457F, 0.0941083133F, 0.086286366F, 0.0784591F, 0.070626989F,\r\n    0.0627905205F, 0.0549501814F, 0.0471064523F, 0.0392598175F, 0.0314107575F,\r\n    0.023559764F, 0.0157073177F, 0.00785390101F, 1.22464685E-16F,\r\n    -0.00785390101F, -0.0157073177F, -0.023559764F, -0.0314107575F,\r\n    -0.0392598175F, -0.0471064523F, -0.0549501814F, -0.0627905205F,\r\n    -0.070626989F, -0.0784591F, -0.086286366F, -0.0941083133F, -0.101924457F,\r\n    -0.109734312F, -0.117537394F, -0.125333235F, -0.133121341F, -0.140901238F,\r\n    -0.148672432F, -0.156434461F, -0.16418685F, -0.171929106F, -0.179660752F,\r\n    -0.187381312F, -0.195090324F, -0.202787295F, -0.210471764F, -0.21814324F,\r\n    -0.225801274F, -0.233445361F, -0.241075054F, -0.24868989F, -0.256289363F,\r\n    -0.263873041F, -0.271440446F, -0.278991103F, -0.286524564F, -0.294040322F,\r\n    -0.301537961F, -0.309017F, -0.316476971F, -0.323917419F, -0.331337899F,\r\n    -0.338737935F, -0.346117049F, -0.353474855F, -0.360810816F, -0.368124545F,\r\n    -0.375415564F, -0.382683426F, -0.389927685F, -0.397147894F, -0.404343605F,\r\n    -0.411514372F, -0.418659747F, -0.425779283F, -0.432872593F, -0.439939171F,\r\n    -0.446978629F, -0.453990489F, -0.460974365F, -0.46792981F, -0.474856377F,\r\n    -0.481753677F, -0.488621235F, -0.495458663F, -0.502265513F, -0.509041429F,\r\n    -0.515785873F, -0.522498548F, -0.529179F, -0.535826802F, -0.542441547F,\r\n    -0.549022794F, -0.555570245F, -0.562083364F, -0.568561852F, -0.575005233F,\r\n    -0.581413209F, -0.587785244F, -0.594121039F, -0.600420237F, -0.60668236F,\r\n    -0.612907052F, -0.619093955F, -0.625242651F, -0.631352782F, -0.637424F,\r\n    -0.643455863F, -0.649448037F, -0.655400157F, -0.661311865F, -0.667182744F,\r\n    -0.673012495F, -0.678800762F, -0.684547126F, -0.690251231F, -0.695912778F,\r\n    -0.70153141F, -0.707106769F, -0.712638497F, -0.718126297F, -0.723569751F,\r\n    -0.72896862F, -0.734322488F, -0.739631116F, -0.744894F, -0.750111043F,\r\n    -0.755281806F, -0.760405958F, -0.765483201F, -0.770513237F, -0.775495768F,\r\n    -0.780430436F, -0.785316944F, -0.790155F, -0.794944346F, -0.799684644F,\r\n    -0.804375648F, -0.809017F, -0.813608468F, -0.818149745F, -0.822640538F,\r\n    -0.827080548F, -0.831469595F, -0.835807383F, -0.840093553F, -0.844327927F,\r\n    -0.848510206F, -0.852640152F, -0.856717527F, -0.860742033F, -0.86471343F,\r\n    -0.868631542F, -0.872496F, -0.876306653F, -0.880063295F, -0.883765638F,\r\n    -0.887413442F, -0.891006529F, -0.894544661F, -0.898027599F, -0.901455104F,\r\n    -0.904827058F, -0.908143163F, -0.911403298F, -0.914607167F, -0.91775465F,\r\n    -0.920845509F, -0.923879504F, -0.926856577F, -0.92977649F, -0.932639F,\r\n    -0.935444057F, -0.938191354F, -0.940880775F, -0.943512142F, -0.946085334F,\r\n    -0.948600173F, -0.95105654F, -0.953454196F, -0.955793F, -0.958072901F,\r\n    -0.96029371F, -0.962455213F, -0.964557409F, -0.96660012F, -0.968583167F,\r\n    -0.970506489F, -0.972369909F, -0.974173367F, -0.975916743F, -0.977599919F,\r\n    -0.979222834F, -0.980785251F, -0.982287228F, -0.983728647F, -0.985109329F,\r\n    -0.986429274F, -0.987688363F, -0.988886476F, -0.990023673F, -0.991099775F,\r\n    -0.992114723F, -0.993068457F, -0.993961F, -0.994792163F, -0.995561957F,\r\n    -0.996270359F, -0.996917307F, -0.997502804F, -0.998026729F, -0.998489082F,\r\n    -0.998889863F, -0.999229F, -0.999506533F, -0.999722421F, -0.999876618F,\r\n    -0.999969184F, -1.0F, -0.999969184F, -0.999876618F, -0.999722421F,\r\n    -0.999506533F, -0.999229F, -0.998889863F, -0.998489082F, -0.998026729F,\r\n    -0.997502804F, -0.996917307F, -0.996270359F, -0.995561957F, -0.994792163F,\r\n    -0.993961F, -0.993068457F, -0.992114723F, -0.991099775F, -0.990023673F,\r\n    -0.988886476F, -0.987688363F, -0.986429274F, -0.985109329F, -0.983728647F,\r\n    -0.982287228F, -0.980785251F, -0.979222834F, -0.977599919F, -0.975916743F,\r\n    -0.974173367F, -0.972369909F, -0.970506489F, -0.968583167F, -0.96660012F,\r\n    -0.964557409F, -0.962455213F, -0.96029371F, -0.958072901F, -0.955793F,\r\n    -0.953454196F, -0.95105654F, -0.948600173F, -0.946085334F, -0.943512142F,\r\n    -0.940880775F, -0.938191354F, -0.935444057F, -0.932639F, -0.92977649F,\r\n    -0.926856577F, -0.923879504F, -0.920845509F, -0.91775465F, -0.914607167F,\r\n    -0.911403298F, -0.908143163F, -0.904827058F, -0.901455104F, -0.898027599F,\r\n    -0.894544661F, -0.891006529F, -0.887413442F, -0.883765638F, -0.880063295F,\r\n    -0.876306653F, -0.872496F, -0.868631542F, -0.86471343F, -0.860742033F,\r\n    -0.856717527F, -0.852640152F, -0.848510206F, -0.844327927F, -0.840093553F,\r\n    -0.835807383F, -0.831469595F, -0.827080548F, -0.822640538F, -0.818149745F,\r\n    -0.813608468F, -0.809017F, -0.804375648F, -0.799684644F, -0.794944346F,\r\n    -0.790155F, -0.785316944F, -0.780430436F, -0.775495768F, -0.770513237F,\r\n    -0.765483201F, -0.760405958F, -0.755281806F, -0.750111043F, -0.744894F,\r\n    -0.739631116F, -0.734322488F, -0.72896862F, -0.723569751F, -0.718126297F,\r\n    -0.712638497F, -0.707106769F, -0.70153141F, -0.695912778F, -0.690251231F,\r\n    -0.684547126F, -0.678800762F, -0.673012495F, -0.667182744F, -0.661311865F,\r\n    -0.655400157F, -0.649448037F, -0.643455863F, -0.637424F, -0.631352782F,\r\n    -0.625242651F, -0.619093955F, -0.612907052F, -0.60668236F, -0.600420237F,\r\n    -0.594121039F, -0.587785244F, -0.581413209F, -0.575005233F, -0.568561852F,\r\n    -0.562083364F, -0.555570245F, -0.549022794F, -0.542441547F, -0.535826802F,\r\n    -0.529179F, -0.522498548F, -0.515785873F, -0.509041429F, -0.502265513F,\r\n    -0.495458663F, -0.488621235F, -0.481753677F, -0.474856377F, -0.46792981F,\r\n    -0.460974365F, -0.453990489F, -0.446978629F, -0.439939171F, -0.432872593F,\r\n    -0.425779283F, -0.418659747F, -0.411514372F, -0.404343605F, -0.397147894F,\r\n    -0.389927685F, -0.382683426F, -0.375415564F, -0.368124545F, -0.360810816F,\r\n    -0.353474855F, -0.346117049F, -0.338737935F, -0.331337899F, -0.323917419F,\r\n    -0.316476971F, -0.309017F, -0.301537961F, -0.294040322F, -0.286524564F,\r\n    -0.278991103F, -0.271440446F, -0.263873041F, -0.256289363F, -0.24868989F,\r\n    -0.241075054F, -0.233445361F, -0.225801274F, -0.21814324F, -0.210471764F,\r\n    -0.202787295F, -0.195090324F, -0.187381312F, -0.179660752F, -0.171929106F,\r\n    -0.16418685F, -0.156434461F, -0.148672432F, -0.140901238F, -0.133121341F,\r\n    -0.125333235F, -0.117537394F, -0.109734312F, -0.101924457F, -0.0941083133F,\r\n    -0.086286366F, -0.0784591F, -0.070626989F, -0.0627905205F, -0.0549501814F,\r\n    -0.0471064523F, -0.0392598175F, -0.0314107575F, -0.023559764F,\r\n    -0.0157073177F, -0.00785390101F, -2.44929371E-16F, 0.00785390101F,\r\n    0.0157073177F, 0.023559764F, 0.0314107575F, 0.0392598175F, 0.0471064523F,\r\n    0.0549501814F, 0.0627905205F, 0.070626989F, 0.0784591F, 0.086286366F,\r\n    0.0941083133F, 0.101924457F, 0.109734312F, 0.117537394F, 0.125333235F,\r\n    0.133121341F, 0.140901238F, 0.148672432F, 0.156434461F, 0.16418685F,\r\n    0.171929106F, 0.179660752F, 0.187381312F, 0.195090324F, 0.202787295F,\r\n    0.210471764F, 0.21814324F, 0.225801274F, 0.233445361F, 0.241075054F,\r\n    0.24868989F, 0.256289363F, 0.263873041F, 0.271440446F, 0.278991103F,\r\n    0.286524564F, 0.294040322F, 0.301537961F, 0.309017F, 0.316476971F,\r\n    0.323917419F, 0.331337899F, 0.338737935F, 0.346117049F, 0.353474855F,\r\n    0.360810816F, 0.368124545F, 0.375415564F, 0.382683426F, 0.389927685F,\r\n    0.397147894F, 0.404343605F, 0.411514372F, 0.418659747F, 0.425779283F,\r\n    0.432872593F, 0.439939171F, 0.446978629F, 0.453990489F, 0.460974365F,\r\n    0.46792981F, 0.474856377F, 0.481753677F, 0.488621235F, 0.495458663F,\r\n    0.502265513F, 0.509041429F, 0.515785873F, 0.522498548F, 0.529179F,\r\n    0.535826802F, 0.542441547F, 0.549022794F, 0.555570245F, 0.562083364F,\r\n    0.568561852F, 0.575005233F, 0.581413209F, 0.587785244F, 0.594121039F,\r\n    0.600420237F, 0.60668236F, 0.612907052F, 0.619093955F, 0.625242651F,\r\n    0.631352782F, 0.637424F, 0.643455863F, 0.649448037F, 0.655400157F,\r\n    0.661311865F, 0.667182744F, 0.673012495F, 0.678800762F, 0.684547126F,\r\n    0.690251231F, 0.695912778F, 0.70153141F, 0.707106769F, 0.712638497F,\r\n    0.718126297F, 0.723569751F, 0.72896862F, 0.734322488F, 0.739631116F,\r\n    0.744894F, 0.750111043F, 0.755281806F, 0.760405958F, 0.765483201F,\r\n    0.770513237F, 0.775495768F, 0.780430436F, 0.785316944F, 0.790155F,\r\n    0.794944346F, 0.799684644F, 0.804375648F, 0.809017F, 0.813608468F,\r\n    0.818149745F, 0.822640538F, 0.827080548F, 0.831469595F, 0.835807383F,\r\n    0.840093553F, 0.844327927F, 0.848510206F, 0.852640152F, 0.856717527F,\r\n    0.860742033F, 0.86471343F, 0.868631542F, 0.872496F, 0.876306653F,\r\n    0.880063295F, 0.883765638F, 0.887413442F, 0.891006529F, 0.894544661F,\r\n    0.898027599F, 0.901455104F, 0.904827058F, 0.908143163F, 0.911403298F,\r\n    0.914607167F, 0.91775465F, 0.920845509F, 0.923879504F, 0.926856577F,\r\n    0.92977649F, 0.932639F, 0.935444057F, 0.938191354F, 0.940880775F,\r\n    0.943512142F, 0.946085334F, 0.948600173F, 0.95105654F, 0.953454196F,\r\n    0.955793F, 0.958072901F, 0.96029371F, 0.962455213F, 0.964557409F,\r\n    0.96660012F, 0.968583167F, 0.970506489F, 0.972369909F, 0.974173367F,\r\n    0.975916743F, 0.977599919F, 0.979222834F, 0.980785251F, 0.982287228F,\r\n    0.983728647F, 0.985109329F, 0.986429274F, 0.987688363F, 0.988886476F,\r\n    0.990023673F, 0.991099775F, 0.992114723F, 0.993068457F, 0.993961F,\r\n    0.994792163F, 0.995561957F, 0.996270359F, 0.996917307F, 0.997502804F,\r\n    0.998026729F, 0.998489082F, 0.998889863F, 0.999229F, 0.999506533F,\r\n    0.999722421F, 0.999876618F, 0.999969184F, 1.0F, 0.999969184F }\r\n};\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetInf.c\r\n *\r\n * Code generated for Simulink model 'mcb_pmsm_foc_qep_f28379d'.\r\n *\r\n * Model version                  : 9.0\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Tue Dec 10 10:17:02 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 16U\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    inf = tmpVal.fltVal;\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    minf = tmpVal.fltVal;\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetInf.h\r\n *\r\n * Code generated for Simulink model 'mcb_pmsm_foc_qep_f28379d'.\r\n *\r\n * Model version                  : 9.0\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Tue Dec 10 10:17:02 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rtGetInf_h_\r\n#define rtGetInf_h_\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetInf(void);\r\nextern real32_T rtGetInfF(void);\r\nextern real_T rtGetMinusInf(void);\r\nextern real32_T rtGetMinusInfF(void);\r\n\r\n#endif                                 /* rtGetInf_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetNaN.c\r\n *\r\n * Code generated for Simulink model 'mcb_pmsm_foc_qep_f28379d'.\r\n *\r\n * Model version                  : 9.0\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Tue Dec 10 10:17:02 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetNaN.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 16U\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    nan = tmpVal.fltVal;\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  nanF.wordL.wordLuint = 0xFFC00000U;\r\n  return nanF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetNaN.h\r\n *\r\n * Code generated for Simulink model 'mcb_pmsm_foc_qep_f28379d'.\r\n *\r\n * Model version                  : 9.0\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Tue Dec 10 10:17:02 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rtGetNaN_h_\r\n#define rtGetNaN_h_\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetNaN(void);\r\nextern real32_T rtGetNaNF(void);\r\n\r\n#endif                                 /* rtGetNaN_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rt_nonfinite.c\r\n *\r\n * Code generated for Simulink model 'mcb_pmsm_foc_qep_f28379d'.\r\n *\r\n * Model version                  : 9.0\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Tue Dec 10 10:17:02 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 16U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rt_nonfinite.h\r\n *\r\n * Code generated for Simulink model 'mcb_pmsm_foc_qep_f28379d'.\r\n *\r\n * Model version                  : 9.0\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Tue Dec 10 10:17:02 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rt_nonfinite_h_\r\n#define rt_nonfinite_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#define NOT_USING_NONFINITE_LITERALS   1\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern void rt_InitInfAndNaN(size_t realSize);\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordH;\r\n    uint32_T wordL;\r\n  } words;\r\n} BigEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordL;\r\n    uint32_T wordH;\r\n  } words;\r\n} LittleEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  union {\r\n    real32_T wordLreal;\r\n    uint32_T wordLuint;\r\n  } wordL;\r\n} IEEESingle;\r\n\r\n#endif                                 /* rt_nonfinite_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'mcb_pmsm_foc_qep_f28379d'.\r\n *\r\n * Model version                  : 9.0\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Tue Dec 10 10:17:02 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: Texas Instruments->C2000\r\n *   Number of bits:     char:  16    short:   16    int:  16\r\n *                       long:  32    long long:  64\r\n *                       native word size:  16\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *                                                                       *\r\n *                                                                       *\r\n *   Note:  Because the specified hardware does not have native support  *\r\n *          for all data sizes, some data types are actually typedef'ed  *\r\n *          from larger native data sizes.  The following data types are *\r\n *          not in the ideal native data types:                          *\r\n *                                                                       *\r\n *          int8_T, uint8_T                                              *\r\n *=======================================================================*/\r\ntypedef int int8_T;\r\ntypedef unsigned int uint8_T;\r\ntypedef int int16_T;\r\ntypedef unsigned int uint16_T;\r\ntypedef long int32_T;\r\ntypedef unsigned long uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned int boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647L))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647L-1L))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFUL))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtmodel.h\r\n *\r\n * Code generated for Simulink model 'mcb_pmsm_foc_qep_f28379d'.\r\n *\r\n * Model version                  : 9.0\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Tue Dec 10 10:17:02 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef rtmodel_h_\r\n#define rtmodel_h_\r\n#include \"mcb_pmsm_foc_qep_f28379d.h\"\r\n\r\n/* Macros generated for backwards compatibility  */\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n#endif                                 /* rtmodel_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"DSP28xx_SciUtil.c","type":"source","group":"","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: DSP28xx_SciUtil.c\r\n *\r\n * Code generated for Simulink model 'mcb_pmsm_foc_qep_f28379d'.\r\n *\r\n * Model version                  : 9.0\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Tue Dec 10 10:17:02 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"DSP28xx_SciUtil.h\"\r\n\r\n// to prevent re-entrancy in SCI transmit function\r\nuint16_T checkSCITransmitInProgressA;\r\nuint32_T frameA1Count;\r\nuint16_T frameA1Transmitted;\r\n\r\n/* Transmit character(s) from the SCIa*/\r\nint16_T scia_xmit(uchar_T* pmsg, int16_T msglen, int16_T typeLen)\r\n/*Blocking mode*/\r\n{\r\n  int16_T i,j;\r\n  if (typeLen==1) {\r\n    for (i = 0; i < msglen; i++) {\r\n      while (SciaRegs.SCIFFTX.bit.TXFFST == 16U) {\r\n      }                                /* The buffer is full;*/\r\n\r\n      SciaRegs.SCITXBUF.bit.TXDT = pmsg[i];\r\n    }\r\n  } else {\r\n    for (i = 0; i < (msglen/2); i++) {\r\n      for (j = 0; j<=1; j++) {\r\n        while (SciaRegs.SCIFFTX.bit.TXFFST == 16U) {\r\n        }                              /* The buffer is full;*/\r\n\r\n        SciaRegs.SCITXBUF.bit.TXDT = pmsg[i]>>(8*j);\r\n      }\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\n/*\r\n * Receive character(s) from the SCIa\r\n * Received character(s) will be write to rcvBuff.\r\n * Return 0 if characters are received with no error.\r\n * Return 1 if waiting timeout.\r\n * Return 2 if data error.(receiving timeout or checksum error)\r\n * Return 3 if a parity error occurred.\r\n * Return 4 if a frame error occurred.\r\n */\r\nint16_T scia_rcv(uint16_T *rcvBuff, int16_T buffLen, int16_T typeLen)\r\n{\r\n  int16_T i;\r\n  int16_T errorVal = NOERROR;\r\n  uint16_T byte_cnt = 0;\r\n  Uint32 elapsedTimeCnt, startTimeCnt, currentTimeCnt;\r\n  uint32_T BlockingModeTimeoutCnt = 1.7500000000000002E+6;\r\n  for (i = 0; i<buffLen; i++) {\r\n    startTimeCnt = ReadCpuTimer2Counter();\r\n    elapsedTimeCnt = 0U;\r\n    while (SciaRegs.SCIFFRX.bit.RXFFST == 0U) {\r\n      /* wait until data received */\r\n      currentTimeCnt = (ReadCpuTimer2Counter());\r\n      if (currentTimeCnt <= startTimeCnt) {\r\n        elapsedTimeCnt = (Uint32)(startTimeCnt - currentTimeCnt);\r\n      } else {\r\n        elapsedTimeCnt = (Uint32)(0xFFFFFFFFU + startTimeCnt - currentTimeCnt);\r\n      }\r\n\r\n      if (elapsedTimeCnt >= BlockingModeTimeoutCnt) {\r\n        return TIMEOUT;\r\n      }\r\n    }\r\n\r\n    if (typeLen > 1) {\r\n      if (byte_cnt == 0U) {\r\n        rcvBuff[i/2] = (SciaRegs.SCIRXBUF.all & 0x00FFU);\r\n        byte_cnt = 1U;\r\n      } else {\r\n        rcvBuff[i/2] |= SciaRegs.SCIRXBUF.all << 8;\r\n        byte_cnt = 0U;\r\n      }\r\n    } else {\r\n      rcvBuff[i] = SciaRegs.SCIRXBUF.all;\r\n    }\r\n\r\n    //check flags\r\n    if (SciaRegs.SCIFFRX.bit.RXFFOVF == 1U)/* detect FIFO overflow*/\r\n    {\r\n      SciaRegs.SCIFFRX.bit.RXFFOVRCLR = 1U;\r\n\r\n      /*SciaRegs.SCIFFRX.bit.RXFIFORESET = 0U;    Reset the FIFO pointer to zero.\r\n       * SciaRegs.SCIFFRX.bit.RXFIFORESET = 1U;   Re-enable receive FIFO operation.\r\n       */\r\n    }\r\n\r\n    if (SciaRegs.SCIRXST.bit.FE) {\r\n      errorVal = FRAMERR;\r\n    }\r\n\r\n    if (SciaRegs.SCIRXST.bit.PE) {\r\n      errorVal = PRTYERR;\r\n    }\r\n\r\n    if (SciaRegs.SCIRXST.bit.OE) {\r\n      errorVal = OVRNERR;\r\n    }\r\n\r\n    if (SciaRegs.SCIRXST.bit.BRKDT) {\r\n      errorVal = BRKDTERR;\r\n    }\r\n\r\n    if (SciaRegs.SCIRXST.bit.RXERROR == 1U) {\r\n      SciaRegs.SCICTL1.bit.SWRESET = 1U;\r\n      SciaRegs.SCICTL1.bit.SWRESET = 0U;\r\n      SciaRegs.SCICTL1.bit.SWRESET = 1U;\r\n    }\r\n  }\r\n\r\n  return errorVal;\r\n}\r\n\r\n/*\r\n * Receive character(s) from the SCIa\r\n * Received character(s) will be write to rcvBuff.\r\n * Receive data until tail is received.\r\n * Once first byte of tail matches with received byte start tailCount\r\n * If in between tail byte is not matching with received byte then reset tailCount\r\n * When tailCount becomes equal to tailSize then update rcvBufferLen with received number of bytes, check forFlags and exit.\r\n *\r\n *\r\n * Return 0 if characters are received with no error.\r\n * Return 1 if waiting timeout.\r\n * Return 2 if data error.(receiving timeout or checksum error)\r\n * Return 3 if a parity error occurred.\r\n * Return 4 if a frame error occurred.\r\n */\r\nint16_T scia_rcv_varsize(uint16_T *rcvBuff, int16_T buffLen, int16_T typeLen,\r\n  uchar_T *expTail, int16_T tailsize, int16_T *rcvBufferLen)\r\n{\r\n  int16_T i = 0;\r\n  int16_T errorVal = NOERROR;\r\n  uint16_T byte_cnt = 0;\r\n  int16_T tailCount = 0;\r\n  int16_T totalLen = buffLen + tailsize;\r\n  *rcvBufferLen = 0;\r\n  while (i < totalLen) {\r\n    if (SciaRegs.SCIFFRX.bit.RXFFST > 0U) {/*Check if receive FIFO has data*/\r\n      if (typeLen > 1) {\r\n        int_T tempData = 0;\r\n        tempData = SciaRegs.SCIRXBUF.all;\r\n        if (byte_cnt == 0U) {\r\n          rcvBuff[i/2] = (tempData & 0x00FFU);\r\n          byte_cnt = 1U;\r\n        } else {\r\n          rcvBuff[i/2] |= tempData << 8;\r\n          byte_cnt = 0U;\r\n        }\r\n\r\n        if (tailsize != 0) {\r\n          // Do not check tail if tail is not provided\r\n          if (tempData == expTail[tailCount]) {\r\n            tailCount++;\r\n            if (tailCount == tailsize) {\r\n              *rcvBufferLen = i - tailsize + 1;\r\n              break;\r\n            }\r\n          } else {\r\n            tailCount = 0;\r\n          }\r\n        }\r\n      } else {\r\n        // for (typeLen<=1)\r\n        rcvBuff[i] = SciaRegs.SCIRXBUF.all;\r\n        if (tailsize != 0) {\r\n          // Do not check tail if tail is not provided\r\n          if (rcvBuff[i] == expTail[tailCount]) {\r\n            tailCount++;\r\n            if (tailCount == tailsize) {\r\n              *rcvBufferLen = i - tailsize + 1;\r\n              break;\r\n            }\r\n          }\r\n        } else {\r\n          tailCount = 0;\r\n        }\r\n      }\r\n    } else {\r\n      // If data is not available in FIFO i.e RXFFST == 0\r\n      if (i == 0) {\r\n        return DATANOTAVAILABLE;\r\n      } else {\r\n        *rcvBufferLen = i;\r\n        if (*rcvBufferLen > buffLen) {\r\n          *rcvBufferLen = buffLen;\r\n        }\r\n\r\n        errorVal = PARTIALDATA;\r\n        break;\r\n      }\r\n    }\r\n\r\n    i = i+1;\r\n\r\n    //Check flags\r\n    if (SciaRegs.SCIFFRX.bit.RXFFOVF == 1U)/* detect FIFO overflow*/\r\n    {\r\n      SciaRegs.SCIFFRX.bit.RXFFOVRCLR = 1U;\r\n\r\n      /*SciaRegs.SCIFFRX.bit.RXFIFORESET = 0U;    Reset the FIFO pointer to zero.\r\n       * SciaRegs.SCIFFRX.bit.RXFIFORESET = 1U;   Re-enable receive FIFO operation.\r\n       */\r\n    }\r\n\r\n    if (SciaRegs.SCIRXST.bit.FE) {\r\n      errorVal = FRAMERR;\r\n    }\r\n\r\n    if (SciaRegs.SCIRXST.bit.PE) {\r\n      errorVal = PRTYERR;\r\n    }\r\n\r\n    if (SciaRegs.SCIRXST.bit.OE) {\r\n      errorVal = OVRNERR;\r\n    }\r\n\r\n    if (SciaRegs.SCIRXST.bit.BRKDT) {\r\n      errorVal = BRKDTERR;\r\n    }\r\n\r\n    if (SciaRegs.SCIRXST.bit.RXERROR == 1U) {\r\n      SciaRegs.SCICTL1.bit.SWRESET = 1U;\r\n      SciaRegs.SCICTL1.bit.SWRESET = 0U;\r\n      SciaRegs.SCICTL1.bit.SWRESET = 1U;\r\n    }\r\n  }\r\n\r\n  if (0 == tailsize) {\r\n    if (errorVal != PARTIALDATA) {\r\n      //In case of tail not provided, error flag will NOERROR if data received is of max length\r\n      *rcvBufferLen = totalLen;\r\n    }\r\n  } else {\r\n    // error out as partial data received if tail is provided and not found till maximum length and output the length as max length\r\n    if (*rcvBufferLen == 0) {\r\n      if (tailCount != (i+1)) {\r\n        *rcvBufferLen = i-1;\r\n        errorVal = PARTIALDATA;\r\n      } else {\r\n        errorVal = DATANOTAVAILABLE;\r\n      }\r\n\r\n      if (*rcvBufferLen > buffLen) {\r\n        *rcvBufferLen = buffLen;\r\n      }\r\n\r\n      if (*rcvBufferLen < 0) {\r\n        *rcvBufferLen = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  return errorVal;\r\n}\r\n\r\nvoid init_SCIFrame(void)\r\n{\r\n  // to prevent re-entrancy in SCI transmit function\r\n  checkSCITransmitInProgressA = 0;\r\n  frameA1Count = 0U;\r\n  frameA1Transmitted = 1;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"DSP28xx_SciUtil.h","type":"header","group":"","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Other files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: DSP28xx_SciUtil.h\r\n *\r\n * Code generated for Simulink model 'mcb_pmsm_foc_qep_f28379d'.\r\n *\r\n * Model version                  : 9.0\r\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n * C/C++ source code generated on : Tue Dec 10 10:17:02 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef DSP28xx_SciUtil_h_\r\n#define DSP28xx_SciUtil_h_\r\n#include \"MW_f2837xD_includes.h\"\r\n#include \"F2837xD_device.h\"\r\n#include <string.h>\r\n#include \"rtwtypes.h\"\r\n#define NOERROR                        0                         /* no error*/\r\n#define TIMEOUT                        1                         /* waiting timeout*/\r\n#define DATAERR                        2                         /* data error (checksum error)*/\r\n#define PRTYERR                        3                         /* parity error*/\r\n#define FRAMERR                        4                         /* frame error*/\r\n#define OVRNERR                        5                         /* overrun error*/\r\n#define BRKDTERR                       6                         /* brake-detect error*/\r\n#define DATANOTAVAILABLE               7                         /* Data not available */\r\n#define PARTIALDATA                    8                         /* Partial Data available */\r\n\r\nextern uint16_T checkSCITransmitInProgressA;\r\nextern uint32_T frameA1Count;\r\nextern uint16_T frameA1Transmitted;\r\nint16_T scia_xmit(uchar_T* pmsg, int16_T msglen, int16_T typeLen);\r\nint16_T scia_rcv(uint16_T *rcvBuff, int16_T buffLen, int16_T typeLen);\r\nint16_T scia_rcv_varsize(uint16_T *rcvBuff, int16_T buffLen, int16_T typeLen,\r\n  uchar_T *expTail, int16_T tailsize, int16_T *rcvBufferLen);\r\nvoid init_SCIFrame(void);\r\n\r\n#endif                                 /* DSP28xx_SciUtil_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"F2837xD_Adc.c","type":"source","group":"legacy","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_02_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   F2837xD_Adc.c\n//\n// TITLE:  F2837xD Adc Support Functions.\n//\n//###########################################################################\n//\n// $Release Date: $\n// $Copyright:\n// Copyright (C) 2013-2024 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"F2837xD_device.h\"\n#include \"F2837xD_Examples.h\"\n\n//\n// AdcSetMode - Set the resolution and signalmode for a given ADC. This will\n//              ensure that the correct trim is loaded.\n//\n// NOTE!!! There is no EALLOW/EDIS in this function! You need to make sure you\n// perform the EALLOW before calling this function or else the ADC registers\n// will not be configured.\n//\nvoid AdcSetMode(Uint16 adc, Uint16 resolution, Uint16 signalmode)\n{\n    Uint16 adcOffsetTrimOTPIndex; //index into OTP table of ADC offset trims\n    Uint16 adcOffsetTrim;         //temporary ADC offset trim\n\n    //\n    //re-populate INL trim\n    //\n    CalAdcINL(adc);\n\n    if(0xFFFF != *((Uint16*)GetAdcOffsetTrimOTP))\n    {\n        //\n        //offset trim function is programmed into OTP, so call it\n        //\n\n        //\n        //calculate the index into OTP table of offset trims and call\n        //function to return the correct offset trim\n        //\n#ifndef _DUAL_HEADERS\n        if(ADC_RESOLUTION_12BIT == resolution)\n#else\n        if(ADC_BITRESOLUTION_12BIT == resolution)\n#endif\n        {\n            adcOffsetTrimOTPIndex = 4*adc + 1*signalmode;\n        }\n        else\n        {\n            adcOffsetTrimOTPIndex = 4*adc + 1*signalmode + 2;\n        }\n\n        adcOffsetTrim = (*GetAdcOffsetTrimOTP)(adcOffsetTrimOTPIndex);\n    }\n    else\n    {\n        //\n        //offset trim function is not populated, so set offset trim to 0\n        //\n        adcOffsetTrim = 0;\n    }\n\n    //\n    // Apply the resolution and signalmode to the specified ADC.\n    // Also apply the offset trim and, if needed, linearity trim correction.\n    //\n    switch(adc)\n    {\n        case ADC_ADCA:\n        {\n            AdcaRegs.ADCCTL2.bit.SIGNALMODE = signalmode;\n            if(adcOffsetTrim > 0x0)\n            {\n                AdcaRegs.ADCOFFTRIM.all = adcOffsetTrim;\n            }\n#ifndef _DUAL_HEADERS\n            if(ADC_RESOLUTION_12BIT == resolution)\n#else\n            if(ADC_BITRESOLUTION_12BIT == resolution)\n#endif\n            {\n                AdcaRegs.ADCCTL2.bit.RESOLUTION = 0;\n\n                //\n                //12-bit linearity trim workaround\n                //\n                AdcaRegs.ADCINLTRIM1 &= 0xFFFF0000;\n                AdcaRegs.ADCINLTRIM2 &= 0xFFFF0000;\n                AdcaRegs.ADCINLTRIM4 &= 0xFFFF0000;\n                AdcaRegs.ADCINLTRIM5 &= 0xFFFF0000;\n            }\n            else\n            {\n                AdcaRegs.ADCCTL2.bit.RESOLUTION = 1;\n            }\n            break;\n        }\n        case ADC_ADCB:\n        {\n            AdcbRegs.ADCCTL2.bit.SIGNALMODE = signalmode;\n            if(adcOffsetTrim > 0x0)\n            {\n                AdcbRegs.ADCOFFTRIM.all = adcOffsetTrim;\n            }\n#ifndef _DUAL_HEADERS\n            if(ADC_RESOLUTION_12BIT == resolution)\n#else\n            if(ADC_BITRESOLUTION_12BIT == resolution)\n#endif\n            {\n                AdcbRegs.ADCCTL2.bit.RESOLUTION = 0;\n\n                //\n                //12-bit linearity trim workaround\n                //\n                AdcbRegs.ADCINLTRIM1 &= 0xFFFF0000;\n                AdcbRegs.ADCINLTRIM2 &= 0xFFFF0000;\n                AdcbRegs.ADCINLTRIM4 &= 0xFFFF0000;\n                AdcbRegs.ADCINLTRIM5 &= 0xFFFF0000;\n            }\n            else\n            {\n                AdcbRegs.ADCCTL2.bit.RESOLUTION = 1;\n            }\n            break;\n        }\n        case ADC_ADCC:\n        {\n            AdccRegs.ADCCTL2.bit.SIGNALMODE = signalmode;\n            if(adcOffsetTrim > 0x0)\n            {\n                AdccRegs.ADCOFFTRIM.all = adcOffsetTrim;\n            }\n#ifndef _DUAL_HEADERS\n            if(ADC_RESOLUTION_12BIT == resolution)\n#else\n            if(ADC_BITRESOLUTION_12BIT == resolution)\n#endif\n            {\n                AdccRegs.ADCCTL2.bit.RESOLUTION = 0;\n                //\n                //12-bit linearity trim workaround\n                //\n                AdccRegs.ADCINLTRIM1 &= 0xFFFF0000;\n                AdccRegs.ADCINLTRIM2 &= 0xFFFF0000;\n                AdccRegs.ADCINLTRIM4 &= 0xFFFF0000;\n                AdccRegs.ADCINLTRIM5 &= 0xFFFF0000;\n            }\n            else\n            {\n                AdccRegs.ADCCTL2.bit.RESOLUTION = 1;\n            }\n            break;\n        }\n        case ADC_ADCD:\n        {\n            AdcdRegs.ADCCTL2.bit.SIGNALMODE = signalmode;\n            if(adcOffsetTrim > 0x0)\n            {\n                AdcdRegs.ADCOFFTRIM.all = adcOffsetTrim;\n            }\n#ifndef _DUAL_HEADERS\n            if(ADC_RESOLUTION_12BIT == resolution)\n#else\n            if(ADC_BITRESOLUTION_12BIT == resolution)\n#endif\n            {\n                AdcdRegs.ADCCTL2.bit.RESOLUTION = 0;\n\n                //\n                //12-bit linearity trim workaround\n                //\n                AdcdRegs.ADCINLTRIM1 &= 0xFFFF0000;\n                AdcdRegs.ADCINLTRIM2 &= 0xFFFF0000;\n                AdcdRegs.ADCINLTRIM4 &= 0xFFFF0000;\n                AdcdRegs.ADCINLTRIM5 &= 0xFFFF0000;\n            }\n            else\n            {\n                AdcdRegs.ADCCTL2.bit.RESOLUTION = 1;\n            }\n            break;\n        }\n    }\n}\n\n//\n// CalAdcINL - Loads INL trim values from OTP into the trim registers of the\n//             specified ADC. Use only as part of AdcSetMode function, since\n//             linearity trim correction is needed for some modes.\n//\nvoid CalAdcINL(Uint16 adc)\n{\n    switch(adc)\n    {\n        case ADC_ADCA:\n            if(0xFFFF != *((Uint16*)CalAdcaINL))\n            {\n                //\n                //trim function is programmed into OTP, so call it\n                //\n                (*CalAdcaINL)();\n            }\n            else\n            {\n                //\n                //do nothing, no INL trim function populated\n                //\n            }\n            break;\n        case ADC_ADCB:\n            if(0xFFFF != *((Uint16*)CalAdcbINL))\n            {\n                //\n                //trim function is programmed into OTP, so call it\n                //\n                (*CalAdcbINL)();\n            }\n            else\n            {\n                //\n                //do nothing, no INL trim function populated\n                //\n            }\n            break;\n        case ADC_ADCC:\n            if(0xFFFF != *((Uint16*)CalAdccINL))\n            {\n                //\n                //trim function is programmed into OTP, so call it\n                //\n                (*CalAdccINL)();\n            }\n            else\n            {\n                //\n                //do nothing, no INL trim function populated\n                //\n            }\n            break;\n        case ADC_ADCD:\n            if(0xFFFF != *((Uint16*)CalAdcdINL))\n            {\n                //\n                //trim function is programmed into OTP, so call it\n                //\n                (*CalAdcdINL)();\n            }\n            else\n            {\n                //\n                //do nothing, no INL trim function populated\n                //\n            }\n            break;\n    }\n}\n\n//\n// End of file\n//\n"},{"name":"F2837xD_CodeStartBranch.asm","type":"other","group":"legacy","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_02_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":";//###########################################################################\n;//\n;// FILE:  F2837xD_CodeStartBranch.asm\n;//\n;// TITLE: Branch for redirecting code execution after boot.\n;//\n;// For these examples, code_start is the first code that is executed after\n;// exiting the boot ROM code.\n;//\n;// The codestart section in the linker cmd file is used to physically place\n;// this code at the correct memory location.  This section should be placed\n;// at the location the BOOT ROM will re-direct the code to.  For example,\n;// for boot to FLASH this code will be located at 0x3f7ff6.\n;//\n;// In addition, the example F2837xD projects are setup such that the codegen\n;// entry point is also set to the code_start label.  This is done by linker\n;// option -e in the project build options.  When the debugger loads the code,\n;// it will automatically set the PC to the \"entry point\" address indicated by\n;// the -e linker option.  In this case the debugger is simply assigning the PC,\n;// it is not the same as a full reset of the device.\n;//\n;// The compiler may warn that the entry point for the project is other then\n;//  _c_init00.  _c_init00 is the C environment setup and is run before\n;// main() is entered. The code_start code will re-direct the execution\n;// to _c_init00 and thus there is no worry and this warning can be ignored.\n;//\n;//###########################################################################\n;//\n;// $Release Date:  $\n;// $Copyright:\n;// Copyright (C) 2013-2024 Texas Instruments Incorporated - http://www.ti.com/\n;//\n;// Redistribution and use in source and binary forms, with or without \n;// modification, are permitted provided that the following conditions \n;// are met:\n;// \n;//   Redistributions of source code must retain the above copyright \n;//   notice, this list of conditions and the following disclaimer.\n;// \n;//   Redistributions in binary form must reproduce the above copyright\n;//   notice, this list of conditions and the following disclaimer in the \n;//   documentation and/or other materials provided with the   \n;//   distribution.\n;// \n;//   Neither the name of Texas Instruments Incorporated nor the names of\n;//   its contributors may be used to endorse or promote products derived\n;//   from this software without specific prior written permission.\n;// \n;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n;// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n;// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n;// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n;// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n;// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n;// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n;// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n;// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n;// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n;// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n;// $\n;//###########################################################################\n\n***********************************************************************\n\nWD_DISABLE  .set  1    ;set to 1 to disable WD, else set to 0\n\n    .ref _c_int00\n    .global code_start\n\n***********************************************************************\n* Function: codestart section\n*\n* Description: Branch to code starting point\n***********************************************************************\n\n    .sect \"codestart\"\n    .retain\n\ncode_start:\n    .if WD_DISABLE == 1\n        LB wd_disable       ;Branch to watchdog disable code\n    .else\n        LB _c_int00         ;Branch to start of boot._asm in RTS library\n    .endif\n\n;end codestart section\n\n***********************************************************************\n* Function: wd_disable\n*\n* Description: Disables the watchdog timer\n***********************************************************************\n    .if WD_DISABLE == 1\n\n    .text\nwd_disable:\n    SETC OBJMODE        ;Set OBJMODE for 28x object code\n    EALLOW              ;Enable EALLOW protected register access\n    MOVZ DP, #7029h>>6  ;Set data page for WDCR register\n    MOV @7029h, #0068h  ;Set WDDIS bit in WDCR to disable WD\n    EDIS                ;Disable EALLOW protected register access\n    LB _c_int00         ;Branch to start of boot._asm in RTS library\n\n    .endif\n\n;end wd_disable\n\n    .end\n\n;//\n;// End of file.\n;//\n"},{"name":"F2837xD_CpuTimers.c","type":"source","group":"legacy","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_02_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:    F2837xD_CpuTimers.c\n//\n// TITLE:   CPU 32-bit Timers Initialization & Support Functions.\n//\n//###########################################################################\n//\n// $Release Date:  $\n// $Copyright:\n// Copyright (C) 2013-2024 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"F2837xD_device.h\"\n#include \"F2837xD_Examples.h\"\n\n//\n// Globals\n//\nstruct CPUTIMER_VARS CpuTimer0;\nstruct CPUTIMER_VARS CpuTimer1;\nstruct CPUTIMER_VARS CpuTimer2;\n\n//\n// InitCpuTimers - This function initializes all three CPU timers to a known\n//                 state.\n//\nvoid InitCpuTimers(void)\n{\n    //\n    // CPU Timer 0\n    // Initialize address pointers to respective timer registers:\n    //\n    CpuTimer0.RegsAddr = &CpuTimer0Regs;\n\n    //\n    // Initialize timer period to maximum:\n    //\n    CpuTimer0Regs.PRD.all  = 0xFFFFFFFF;\n\n    //\n    // Initialize pre-scale counter to divide by 1 (SYSCLKOUT):\n    //\n    CpuTimer0Regs.TPR.all  = 0;\n    CpuTimer0Regs.TPRH.all = 0;\n\n    //\n    // Make sure timer is stopped:\n    //\n    CpuTimer0Regs.TCR.bit.TSS = 1;\n\n    //\n    // Reload all counter register with period value:\n    //\n    CpuTimer0Regs.TCR.bit.TRB = 1;\n\n    //\n    // Reset interrupt counters:\n    //\n    CpuTimer0.InterruptCount = 0;\n\n    //\n    // Initialize address pointers to respective timer registers:\n    //\n    CpuTimer1.RegsAddr = &CpuTimer1Regs;\n    CpuTimer2.RegsAddr = &CpuTimer2Regs;\n\n    //\n    // Initialize timer period to maximum:\n    //\n    CpuTimer1Regs.PRD.all  = 0xFFFFFFFF;\n    CpuTimer2Regs.PRD.all  = 0xFFFFFFFF;\n\n    //\n    // Initialize pre-scale counter to divide by 1 (SYSCLKOUT):\n    //\n    CpuTimer1Regs.TPR.all  = 0;\n    CpuTimer1Regs.TPRH.all = 0;\n    CpuTimer2Regs.TPR.all  = 0;\n    CpuTimer2Regs.TPRH.all = 0;\n\n    //\n    // Make sure timers are stopped:\n    //\n    CpuTimer1Regs.TCR.bit.TSS = 1;\n    CpuTimer2Regs.TCR.bit.TSS = 1;\n\n    //\n    // Reload all counter register with period value:\n    //\n    CpuTimer1Regs.TCR.bit.TRB = 1;\n    CpuTimer2Regs.TCR.bit.TRB = 1;\n\n    //\n    // Reset interrupt counters:\n    //\n    CpuTimer1.InterruptCount = 0;\n    CpuTimer2.InterruptCount = 0;\n}\n\n//\n// ConfigCpuTimer - This function initializes the selected timer to the period\n//                  specified by the \"Freq\" and \"Period\" parameters. The \"Freq\"\n//                  is entered as \"MHz\" and the period in \"uSeconds\". The timer\n//                  is held in the stopped state after configuration.\n//\nvoid ConfigCpuTimer(struct CPUTIMER_VARS *Timer, float Freq, float Period)\n{\n    Uint32 temp;\n\n    //\n    // Initialize timer period:\n    //\n    Timer->CPUFreqInMHz = Freq;\n    Timer->PeriodInUSec = Period;\n    temp = (long) (Freq * Period);\n\n    //\n    // Counter decrements PRD+1 times each period\n    //\n    Timer->RegsAddr->PRD.all = temp - 1;\n\n    //\n    // Set pre-scale counter to divide by 1 (SYSCLKOUT):\n    //\n    Timer->RegsAddr->TPR.all  = 0;\n    Timer->RegsAddr->TPRH.all  = 0;\n\n    //\n    // Initialize timer control register:\n    //\n    Timer->RegsAddr->TCR.bit.TSS = 1;     // 1 = Stop timer, 0 = Start/Restart\n                                          // Timer\n    Timer->RegsAddr->TCR.bit.TRB = 1;     // 1 = reload timer\n    Timer->RegsAddr->TCR.bit.SOFT = 0;\n    Timer->RegsAddr->TCR.bit.FREE = 0;    // Timer Free Run Disabled\n    Timer->RegsAddr->TCR.bit.TIE = 1;     // 0 = Disable/ 1 = Enable Timer\n                                          // Interrupt\n\n    //\n    // Reset interrupt counter:\n    //\n    Timer->InterruptCount = 0;\n}\n\n\n//\n// End of file\n//\n"},{"name":"F2837xD_DefaultISR.c","type":"source","group":"legacy","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_02_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   F2837xD_DefaultISR.c\n//\n// TITLE:  F2837xD Device Default Interrupt Service Routines\n//\n//###########################################################################\n//   $\n// $Release Date:   $\n// $Copyright:\n// Copyright (C) 2013-2024 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"F2837xD_device.h\"\n#include \"F2837xD_Examples.h\"\n\n//\n// CPU Timer 1 Interrupt\n//\ninterrupt void TIMER1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// CPU Timer 2 Interrupt\n//\ninterrupt void TIMER2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// Datalogging Interrupt\n//\ninterrupt void DATALOG_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// RTOS Interrupt\n//\ninterrupt void RTOS_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// Emulation Interrupt\n//\ninterrupt void EMU_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// Non-Maskable Interrupt\n//\ninterrupt void NMI_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// Illegal Operation Trap\n//\ninterrupt void ILLEGAL_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 1\n//\ninterrupt void USER1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 2\n//\ninterrupt void USER2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 3\n//\ninterrupt void USER3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 4\n//\ninterrupt void USER4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 5\n//\ninterrupt void USER5_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 6\n//\ninterrupt void USER6_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 7\n//\ninterrupt void USER7_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 8\n//\ninterrupt void USER8_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 9\n//\ninterrupt void USER9_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 10\n//\ninterrupt void USER10_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 11\n//\ninterrupt void USER11_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// User Defined Trap 12\n//\ninterrupt void USER12_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.1 - ADCA Interrupt 1\n//\ninterrupt void ADCA1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.2 - ADCB Interrupt 1\n//\ninterrupt void ADCB1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.3 - ADCC Interrupt 1\n//\ninterrupt void ADCC1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.4 - XINT1 Interrupt\n//\ninterrupt void XINT1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.5 - XINT2 Interrupt\n//\ninterrupt void XINT2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.6 - ADCD Interrupt 1\n//\ninterrupt void ADCD1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.7 - Timer 0 Interrupt\n//\ninterrupt void TIMER0_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.8 - Standby and Halt Wakeup Interrupt\n//\ninterrupt void WAKE_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.1 - ePWM1 Trip Zone Interrupt\n//\ninterrupt void EPWM1_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.2 - ePWM2 Trip Zone Interrupt\n//\ninterrupt void EPWM2_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.3 - ePWM3 Trip Zone Interrupt\n//\ninterrupt void EPWM3_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.4 - ePWM4 Trip Zone Interrupt\n//\ninterrupt void EPWM4_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.5 - ePWM5 Trip Zone Interrupt\n//\ninterrupt void EPWM5_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.6 - ePWM6 Trip Zone Interrupt\n//\ninterrupt void EPWM6_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.7 - ePWM7 Trip Zone Interrupt\n//\ninterrupt void EPWM7_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.8 - ePWM8 Trip Zone Interrupt\n//\ninterrupt void EPWM8_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.1 - ePWM1 Interrupt\n//\ninterrupt void EPWM1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.2 - ePWM2 Interrupt\n//\ninterrupt void EPWM2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.3 - ePWM3 Interrupt\n//\ninterrupt void EPWM3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.4 - ePWM4 Interrupt\n//\ninterrupt void EPWM4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.5 - ePWM5 Interrupt\n//\ninterrupt void EPWM5_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.6 - ePWM6 Interrupt\n//\ninterrupt void EPWM6_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.7 - ePWM7 Interrupt\n//\ninterrupt void EPWM7_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.8 - ePWM8 Interrupt\n//\ninterrupt void EPWM8_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 4.1 - eCAP1 Interrupt\n//\ninterrupt void ECAP1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 4.2 - eCAP2 Interrupt\n//\ninterrupt void ECAP2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 4.3 - eCAP3 Interrupt\n//\ninterrupt void ECAP3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 4.4 - eCAP4 Interrupt\n//\ninterrupt void ECAP4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 4.5 - eCAP5 Interrupt\n//\ninterrupt void ECAP5_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 4.6 - eCAP6 Interrupt\n//\ninterrupt void ECAP6_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 5.1 - eQEP1 Interrupt\n//\ninterrupt void EQEP1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 5.2 - eQEP2 Interrupt\n//\ninterrupt void EQEP2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 5.3 - eQEP3 Interrupt\n//\ninterrupt void EQEP3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 6.1 - SPIA Receive Interrupt\n//\ninterrupt void SPIA_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 6.2 - SPIA Transmit Interrupt\n//\ninterrupt void SPIA_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 6.3 - SPIB Receive Interrupt\n//\ninterrupt void SPIB_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 6.4 - SPIB Transmit Interrupt\n//\ninterrupt void SPIB_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 6.5 - McBSPA Receive Interrupt\n//\ninterrupt void MCBSPA_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 6.6 - McBSPA Transmit Interrupt\n//\ninterrupt void MCBSPA_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 6.7 - McBSPB Receive Interrupt\n//\ninterrupt void MCBSPB_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 6.8 - McBSPB Transmit Interrupt\n//\ninterrupt void MCBSPB_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 7.1 - DMA Channel 1 Interrupt\n//\ninterrupt void DMA_CH1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 7.2 - DMA Channel 2 Interrupt\n//\ninterrupt void DMA_CH2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 7.3 - DMA Channel 3 Interrupt\n//\ninterrupt void DMA_CH3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 7.4 - DMA Channel 4 Interrupt\n//\ninterrupt void DMA_CH4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 7.5 - DMA Channel 5 Interrupt\n//\ninterrupt void DMA_CH5_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 7.6 - DMA Channel 6 Interrupt\n//\ninterrupt void DMA_CH6_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 8.1 - I2CA Interrupt 1\n//\ninterrupt void I2CA_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 8.2 - I2CA Interrupt 2\n//\ninterrupt void I2CA_FIFO_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 8.3 - I2CB Interrupt 1\n//\ninterrupt void I2CB_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 8.4 - I2CB Interrupt 2\n//\ninterrupt void I2CB_FIFO_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 8.5 - SCIC Receive Interrupt\n//\ninterrupt void SCIC_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 8.6 - SCIC Transmit Interrupt\n//\ninterrupt void SCIC_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 8.7 - SCID Receive Interrupt\n//\ninterrupt void SCID_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 8.8 - SCID Transmit Interrupt\n//\ninterrupt void SCID_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 9.1 - SCIA Receive Interrupt\n//\ninterrupt void SCIA_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 9.2 - SCIA Transmit Interrupt\n//\ninterrupt void SCIA_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 9.3 - SCIB Receive Interrupt\n//\ninterrupt void SCIB_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 9.4 - SCIB Transmit Interrupt\n//\ninterrupt void SCIB_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 9.5 - CANA Interrupt 0\n//\ninterrupt void CANA0_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 9.6 - CANA Interrupt 1\n//\ninterrupt void CANA1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 9.7 - CANB Interrupt 0\n//\ninterrupt void CANB0_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 9.8 - CANB Interrupt 1\n//\ninterrupt void CANB1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.1 - ADCA Event Interrupt\n//\ninterrupt void ADCA_EVT_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.2 - ADCA Interrupt 2\n//\ninterrupt void ADCA2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.3 - ADCA Interrupt 3\n//\ninterrupt void ADCA3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.4 - ADCA Interrupt 4\n//\ninterrupt void ADCA4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.5 - ADCB Event Interrupt\n//\ninterrupt void ADCB_EVT_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.6 - ADCB Interrupt 2\n//\ninterrupt void ADCB2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.7 - ADCB Interrupt 3\n//\ninterrupt void ADCB3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.8 - ADCB Interrupt 4\n//\ninterrupt void ADCB4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 11.1 - CLA1 Interrupt 1\n//\ninterrupt void CLA1_1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 11.2 - CLA1 Interrupt 2\n//\ninterrupt void CLA1_2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 11.3 - CLA1 Interrupt 3\n//\ninterrupt void CLA1_3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 11.4 - CLA1 Interrupt 4\n//\ninterrupt void CLA1_4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 11.5 - CLA1 Interrupt 5\n//\ninterrupt void CLA1_5_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 11.6 - CLA1 Interrupt 6\n//\ninterrupt void CLA1_6_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 11.7 - CLA1 Interrupt 7\n//\ninterrupt void CLA1_7_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 11.8 - CLA1 Interrupt 8\n//\ninterrupt void CLA1_8_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.1 - XINT3 Interrupt\n//\ninterrupt void XINT3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.2 - XINT4 Interrupt\n//\ninterrupt void XINT4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.3 - XINT5 Interrupt\n//\ninterrupt void XINT5_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.6 - VCU Interrupt\n//\ninterrupt void VCU_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.7 - FPU Overflow Interrupt\n//\ninterrupt void FPU_OVERFLOW_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.8 - FPU Underflow Interrupt\n//\ninterrupt void FPU_UNDERFLOW_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.13 - IPC Interrupt 0\n//\ninterrupt void IPC0_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.14 - IPC Interrupt 1\n//\ninterrupt void IPC1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.15 - IPC Interrupt 2\n//\ninterrupt void IPC2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 1.16 - IPC Interrupt 3\n//\ninterrupt void IPC3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.9 - ePWM9 Trip Zone Interrupt\n//\ninterrupt void EPWM9_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.10 - ePWM10 Trip Zone Interrupt\n//\ninterrupt void EPWM10_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.11 - ePWM11 Trip Zone Interrupt\n//\ninterrupt void EPWM11_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 2.12 - ePWM12 Trip Zone Interrupt\n//\ninterrupt void EPWM12_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.9 - ePWM9 Interrupt\n//\ninterrupt void EPWM9_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.10 - ePWM10 Interrupt\n//\ninterrupt void EPWM10_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.11 - ePWM11 Interrupt\n//\ninterrupt void EPWM11_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 3.12 - ePWM12 Interrupt\n//\ninterrupt void EPWM12_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 5.9 - SD1 Interrupt\n//\ninterrupt void SD1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 5.10 - SD2 Interrupt\n//\ninterrupt void SD2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 6.9 - SPIC Receive Interrupt\n//\ninterrupt void SPIC_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 6.10 - SPIC Transmit Interrupt\n//\ninterrupt void SPIC_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 8.15 - uPPA Interrupt\n//\ninterrupt void UPPA_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 9.15 - USBA Interrupt\n//\ninterrupt void USBA_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.9 - ADCC Event Interrupt\n//\ninterrupt void ADCC_EVT_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.10 - ADCC Interrupt 2\n//\ninterrupt void ADCC2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.11 - ADCC Interrupt 3\n//\ninterrupt void ADCC3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.12 - ADCC Interrupt 4\n//\ninterrupt void ADCC4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.13 - ADCD Event Interrupt\n//\ninterrupt void ADCD_EVT_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.14 - ADCD Interrupt 2\n//\ninterrupt void ADCD2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.15 - ADCD Interrupt 3\n//\ninterrupt void ADCD3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 10.16 - ADCD Interrupt 4\n//\ninterrupt void ADCD4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.9 - EMIF Error Interrupt\n//\ninterrupt void EMIF_ERROR_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.10 - RAM Correctable Error Interrupt\n//\ninterrupt void RAM_CORRECTABLE_ERROR_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.11 - Flash Correctable Error Interrupt\n//\ninterrupt void FLASH_CORRECTABLE_ERROR_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.12 - RAM Access Violation Interrupt\n//\ninterrupt void RAM_ACCESS_VIOLATION_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.13 - System PLL Slip Interrupt\n//\ninterrupt void SYS_PLL_SLIP_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.14 - Auxiliary PLL Slip Interrupt\n//\ninterrupt void AUX_PLL_SLIP_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.15 - CLA Overflow Interrupt\n//\ninterrupt void CLA_OVERFLOW_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// 12.16 - CLA Underflow Interrupt\n//\ninterrupt void CLA_UNDERFLOW_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// Catch-all Default ISRs:\n//\n\n//\n// PIE_RESERVED_ISR - Reserved ISR\n//\ninterrupt void PIE_RESERVED_ISR(void)\n{\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n//\n// EMPTY_ISR - Only does a return\n//\ninterrupt void EMPTY_ISR(void)\n{\n\n}\n\n//\n// NOTUSED_ISR - Unused ISR\n//\ninterrupt void NOTUSED_ISR(void)\n{\n    asm (\"      ESTOP0\");\n    for(;;);\n}\n\n"},{"name":"F2837xD_Dma.c","type":"source","group":"legacy","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_02_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:    F2837xD_DMA.c\n//\n// TITLE:   F2837xD Device DMA Initialization & Support Functions.\n//\n//###########################################################################\n//\n// $Release Date:  $\n// $Copyright:\n// Copyright (C) 2013-2024 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"F2837xD_device.h\"\n#include \"F2837xD_Examples.h\"\n\n//\n// DMAInitialize - This function initializes the DMA to a known state.\n//\nvoid DMAInitialize(void)\n{\n    EALLOW;\n\n    //\n    // Perform a hard reset on DMA\n    //\n    DmaRegs.DMACTRL.bit.HARDRESET = 1;\n   __asm (\" nop\"); // one NOP required after HARDRESET\n\n    //\n    // Allow DMA to run free on emulation suspend\n    //\n    DmaRegs.DEBUGCTRL.bit.FREE = 1;\n\n    EDIS;\n}\n\n//\n// DMACH1AddrConfig - DMA Channel 1 Address Configuration\n//\nvoid DMACH1AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH1.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source;   // Point to\n                                                            // beginning of\n                                                            // source buffer\n    DmaRegs.CH1.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH1.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;  // Point to\n                                                         // beginning of\n                                                         // destination buffer\n    DmaRegs.CH1.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH1BurstConfig - DMA Channel 1 Burst size configuration\n//\nvoid DMACH1BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\n{\n    EALLOW;\n\n    //\n    // Set up BURST registers:\n    //\n    DmaRegs.CH1.BURST_SIZE.all = bsize;      // Number of words(X-1)\n                                             // x-ferred in a burst.\n    DmaRegs.CH1.SRC_BURST_STEP = srcbstep;   // Increment source addr between\n                                             // each word x-ferred.\n    DmaRegs.CH1.DST_BURST_STEP = desbstep;   // Increment dest addr between\n                                             // each word x-ferred.\n\n    EDIS;\n}\n\n//\n// DMACH1TransferConfig - DMA Channel 1 Transfer size configuration\n//\nvoid DMACH1TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\n{\n    EALLOW;\n\n    //\n    // Set up TRANSFER registers:\n    //\n    DmaRegs.CH1.TRANSFER_SIZE = tsize;        // Number of bursts per transfer,\n                                              // DMA interrupt will occur after\n                                              // completed transfer.\n    DmaRegs.CH1.SRC_TRANSFER_STEP = srctstep; // TRANSFER_STEP is ignored\n                                              // when WRAP occurs.\n    DmaRegs.CH1.DST_TRANSFER_STEP = deststep; // TRANSFER_STEP is ignored\n                                              // when WRAP occurs.\n\n    EDIS;\n}\n\n//\n// DMACH1WrapConfig - DMA Channel 1 Wrap size configuration\n//\nvoid DMACH1WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize,\n                      int16 deswstep)\n{\n    EALLOW;\n\n    //\n    // Set up WRAP registers:\n    //\n    DmaRegs.CH1.SRC_WRAP_SIZE = srcwsize; // Wrap source address after N bursts\n    DmaRegs.CH1.SRC_WRAP_STEP = srcwstep; // Step for source wrap\n\n    DmaRegs.CH1.DST_WRAP_SIZE = deswsize; // Wrap destination address after\n                                          // N bursts.\n    DmaRegs.CH1.DST_WRAP_STEP = deswstep; // Step for destination wrap\n\n    EDIS;\n}\n\n//\n// DMACH1ModeConfig - DMA Channel 1 Mode configuration\n//\nvoid DMACH1ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot,\n                      Uint16 cont, Uint16 synce, Uint16 syncsel,\n                      Uint16 ovrinte, Uint16 datasize, Uint16 chintmode,\n                      Uint16 chinte)\n{\n    EALLOW;\n\n    //\n    // Set up MODE Register:\n    // persel - Source select\n    // PERINTSEL - Should be hard coded to channel, above now selects source\n    // PERINTE - Peripheral interrupt enable\n    // ONESHOT - Oneshot enable\n    // CONTINUOUS - Continuous enable\n    // OVRINTE - Enable/disable the overflow interrupt\n    // DATASIZE - 16-bit/32-bit data size transfers\n    // CHINTMODE - Generate interrupt to CPU at beginning/end of transfer\n    // CHINTE - Channel Interrupt to  CPU enable\n    //\n    DmaClaSrcSelRegs.DMACHSRCSEL1.bit.CH1 = persel;\n    DmaRegs.CH1.MODE.bit.PERINTSEL = 1;\n    DmaRegs.CH1.MODE.bit.PERINTE = perinte;\n    DmaRegs.CH1.MODE.bit.ONESHOT = oneshot;\n    DmaRegs.CH1.MODE.bit.CONTINUOUS = cont;\n    DmaRegs.CH1.MODE.bit.OVRINTE = ovrinte;\n    DmaRegs.CH1.MODE.bit.DATASIZE = datasize;\n    DmaRegs.CH1.MODE.bit.CHINTMODE = chintmode;\n    DmaRegs.CH1.MODE.bit.CHINTE = chinte;\n\n    //\n    // Clear any spurious flags: interrupt and sync error flags\n    //\n    DmaRegs.CH1.CONTROL.bit.PERINTCLR = 1;\n    DmaRegs.CH1.CONTROL.bit.ERRCLR = 1;\n\n    //\n    // Initialize PIE vector for CPU interrupt:\n    // Enable DMA CH1 interrupt in PIE\n    //\n    PieCtrlRegs.PIEIER7.bit.INTx1 = 1;\n\n    EDIS;\n}\n\n//\n// StartDMACH1 - This function starts DMA Channel 1.\n//\nvoid StartDMACH1(void)\n{\n    EALLOW;\n    DmaRegs.CH1.CONTROL.bit.RUN = 1;\n    EDIS;\n}\n\n//\n// DMACH2AddrConfig - DMA Channel 2 Address Configuration\n//\nvoid DMACH2AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH2.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source;   // Point to\n                                                            // beginning of\n                                                            // source buffer.\n    DmaRegs.CH2.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH2.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;  // Point to beginning\n                                                         // of destination\n                                                         // buffer.\n    DmaRegs.CH2.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH2BurstConfig - DMA Channel 2 Burst size configuration\n//\nvoid DMACH2BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\n{\n    EALLOW;\n\n    //\n    // Set up BURST registers:\n    //\n    DmaRegs.CH2.BURST_SIZE.all = bsize;     // Number of words(X-1) x-ferred in\n                                            // a burst.\n    DmaRegs.CH2.SRC_BURST_STEP = srcbstep;  // Increment source addr between\n                                            // each word x-ferred.\n    DmaRegs.CH2.DST_BURST_STEP = desbstep;  // Increment dest addr between each\n                                            // word x-ferred.\n\n    EDIS;\n}\n\n//\n// DMACH2TransferConfig - DMA Channel 2 Transfer size Configuration\n//\nvoid DMACH2TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\n{\n    EALLOW;\n\n    //\n    // Set up TRANSFER registers:\n    //\n    DmaRegs.CH2.TRANSFER_SIZE = tsize;        // Number of bursts per transfer,\n                                              // DMA interrupt will occur after\n                                              // completed transfer.\n    DmaRegs.CH2.SRC_TRANSFER_STEP = srctstep; // TRANSFER_STEP is ignored when\n                                              // WRAP occurs.\n    DmaRegs.CH2.DST_TRANSFER_STEP = deststep; // TRANSFER_STEP is ignored when\n                                              // WRAP occurs.\n\n    EDIS;\n}\n\n//\n// DMACH2WrapConfig - DMA Channel 2 Wrap size configuration\n//\nvoid DMACH2WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize,\n                      int16 deswstep)\n{\n    EALLOW;\n\n    //\n    // Set up WRAP registers:\n    //\n    DmaRegs.CH2.SRC_WRAP_SIZE = srcwsize; // Wrap source address after N bursts\n    DmaRegs.CH2.SRC_WRAP_STEP = srcwstep; // Step for source wrap\n\n    DmaRegs.CH2.DST_WRAP_SIZE = deswsize; // Wrap destination address after\n                                          // N bursts.\n    DmaRegs.CH2.DST_WRAP_STEP = deswstep; // Step for destination wrap\n\n    EDIS;\n}\n\n//\n// DMACH2ModeConfig - DMA Channel 2 Mode configuration\n//\nvoid DMACH2ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot,\n                      Uint16 cont, Uint16 synce, Uint16 syncsel,\n                      Uint16 ovrinte, Uint16 datasize, Uint16 chintmode,\n                      Uint16 chinte)\n{\n    EALLOW;\n\n    //\n    // Set up MODE Register:\n    // persel - Source select\n    // PERINTSEL - Should be hard coded to channel, above now selects source\n    // PERINTE - Peripheral interrupt enable\n    // ONESHOT - Oneshot enable\n    // CONTINUOUS - Continuous enable\n    // OVRINTE - Enable/disable the overflow interrupt\n    // DATASIZE - 16-bit/32-bit data size transfers\n    // CHINTMODE - Generate interrupt to CPU at beginning/end of transfer\n    // CHINTE - Channel Interrupt to  CPU enable\n    //\n    DmaClaSrcSelRegs.DMACHSRCSEL1.bit.CH2 = persel;\n    DmaRegs.CH2.MODE.bit.PERINTSEL = 2;\n    DmaRegs.CH2.MODE.bit.PERINTE = perinte;\n    DmaRegs.CH2.MODE.bit.ONESHOT = oneshot;\n    DmaRegs.CH2.MODE.bit.CONTINUOUS = cont;\n    DmaRegs.CH2.MODE.bit.OVRINTE = ovrinte;\n    DmaRegs.CH2.MODE.bit.DATASIZE = datasize;\n    DmaRegs.CH2.MODE.bit.CHINTMODE = chintmode;\n    DmaRegs.CH2.MODE.bit.CHINTE = chinte;\n\n    //\n    // Clear any spurious flags: Interrupt flags and sync error flags\n    //\n    DmaRegs.CH2.CONTROL.bit.PERINTCLR = 1;\n    DmaRegs.CH2.CONTROL.bit.ERRCLR = 1;\n\n    //\n    // Initialize PIE vector for CPU interrupt:\n    // Enable DMA CH2 interrupt in PIE\n    //\n    PieCtrlRegs.PIEIER7.bit.INTx2 = 1;\n\n    EDIS;\n}\n\n//\n// StartDMACH2 - This function starts DMA Channel 2.\n//\nvoid StartDMACH2(void)\n{\n    EALLOW;\n    DmaRegs.CH2.CONTROL.bit.RUN = 1;\n    EDIS;\n}\n\n//\n// DMACH3AddrConfig - DMA Channel 3 Address configuration\n//\nvoid DMACH3AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH3.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source; // Point to beginning\n                                                          // of source buffer.\n    DmaRegs.CH3.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH3.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest; // Point to beginning\n                                                        // of destination\n                                                        // buffer.\n    DmaRegs.CH3.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH3BurstConfig - DMA Channel 3 burst size configuration\n//\nvoid DMACH3BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\n{\n    EALLOW;\n\n    //\n    // Set up BURST registers:\n    //\n    DmaRegs.CH3.BURST_SIZE.all = bsize;     // Number of words(X-1) x-ferred in\n                                            // a burst.\n    DmaRegs.CH3.SRC_BURST_STEP = srcbstep;  // Increment source addr between\n                                            // each word x-ferred.\n    DmaRegs.CH3.DST_BURST_STEP = desbstep;  // Increment dest addr between each\n                                            // word x-ferred.\n\n    EDIS;\n}\n\n//\n// DMACH3TransferConfig - DMA channel 3 transfer size configuration\n//\nvoid DMACH3TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\n{\n    EALLOW;\n\n    //\n    // Set up TRANSFER registers:\n    //\n    DmaRegs.CH3.TRANSFER_SIZE = tsize;        // Number of bursts per transfer,\n                                              // DMA interrupt will occur after\n                                              // completed transfer.\n    DmaRegs.CH3.SRC_TRANSFER_STEP = srctstep; // TRANSFER_STEP is ignored when\n                                              // WRAP occurs.\n    DmaRegs.CH3.DST_TRANSFER_STEP = deststep; // TRANSFER_STEP is ignored when\n                                              // WRAP occurs.\n\n    EDIS;\n}\n\n//\n// DMACH3WrapConfig - DMA Channel 3 wrap size configuration\n//\nvoid DMACH3WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize,\n                      int16 deswstep)\n{\n    EALLOW;\n\n    //\n    // Set up WRAP registers:\n    //\n    DmaRegs.CH3.SRC_WRAP_SIZE = srcwsize; // Wrap source address after N bursts\n    DmaRegs.CH3.SRC_WRAP_STEP = srcwstep; // Step for source wrap\n\n    DmaRegs.CH3.DST_WRAP_SIZE = deswsize; // Wrap destination address after N\n                                          // bursts.\n    DmaRegs.CH3.DST_WRAP_STEP = deswstep; // Step for destination wrap\n\n    EDIS;\n}\n\n//\n// DMACH3ModeConfig - DMA Channel 3 mode configuration\n//\nvoid DMACH3ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot,\n                      Uint16 cont, Uint16 synce, Uint16 syncsel,\n                      Uint16 ovrinte, Uint16 datasize, Uint16 chintmode,\n                      Uint16 chinte)\n{\n    EALLOW;\n\n    //\n    // Set up MODE Register:\n    // persel - Source select\n    // PERINTSEL - Should be hard coded to channel, above now selects source\n    // PERINTE - Peripheral interrupt enable\n    // ONESHOT - Oneshot enable\n    // CONTINUOUS - Continuous enable\n    // OVRINTE - Enable/disable the overflow interrupt\n    // DATASIZE - 16-bit/32-bit data size transfers\n    // CHINTMODE - Generate interrupt to CPU at beginning/end of transfer\n    // CHINTE - Channel Interrupt to  CPU enable\n    //\n    DmaClaSrcSelRegs.DMACHSRCSEL1.bit.CH3 = persel;\n    DmaRegs.CH3.MODE.bit.PERINTSEL = 3;\n    DmaRegs.CH3.MODE.bit.PERINTE = perinte;\n    DmaRegs.CH3.MODE.bit.ONESHOT = oneshot;\n    DmaRegs.CH3.MODE.bit.CONTINUOUS = cont;\n    DmaRegs.CH3.MODE.bit.OVRINTE = ovrinte;\n    DmaRegs.CH3.MODE.bit.DATASIZE = datasize;\n    DmaRegs.CH3.MODE.bit.CHINTMODE = chintmode;\n    DmaRegs.CH3.MODE.bit.CHINTE = chinte;\n\n    //\n    // Clear any spurious flags: interrupt flags and sync error flags\n    //\n    DmaRegs.CH3.CONTROL.bit.PERINTCLR = 1;\n    DmaRegs.CH3.CONTROL.bit.ERRCLR = 1;\n\n    //\n    // Initialize PIE vector for CPU interrupt:\n    // Enable DMA CH3 interrupt in PIE\n    //\n    PieCtrlRegs.PIEIER7.bit.INTx3 = 1;\n\n    EDIS;\n}\n\n//\n// StartDMACH3 - This function starts DMA Channel 3.\n//\nvoid StartDMACH3(void)\n{\n    EALLOW;\n    DmaRegs.CH3.CONTROL.bit.RUN = 1;\n    EDIS;\n}\n\n//\n// DMACH4AddrConfig - DMA Channel 4 address configuration\n//\nvoid DMACH4AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH4.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source; // Point to beginning\n                                                          // of source buffer.\n    DmaRegs.CH4.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH4.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;   // Point to beginning\n                                                          // of destination\n                                                          // buffer.\n    DmaRegs.CH4.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH4BurstConfig - DMA Channel 4 burst size configuration\n//\nvoid DMACH4BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\n{\n    EALLOW;\n\n    //\n    // Set up BURST registers:\n    //\n    DmaRegs.CH4.BURST_SIZE.all = bsize;     // Number of words(X-1) x-ferred in\n                                            // a burst.\n    DmaRegs.CH4.SRC_BURST_STEP = srcbstep;  // Increment source addr between\n                                            // each word x-ferred.\n    DmaRegs.CH4.DST_BURST_STEP = desbstep;  // Increment dest addr between each\n                                            // word x-ferred.\n\n    EDIS;\n}\n\n//\n// DMACH4TransferConfig - DMA channel 4 transfer size configuration\n//\nvoid DMACH4TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\n{\n    EALLOW;\n\n    //\n    // Set up TRANSFER registers:\n    //\n    DmaRegs.CH4.TRANSFER_SIZE = tsize;        // Number of bursts per transfer,\n                                              // DMA interrupt will occur after\n                                              // completed transfer.\n    DmaRegs.CH4.SRC_TRANSFER_STEP = srctstep; // TRANSFER_STEP is ignored when\n                                              // WRAP occurs.\n    DmaRegs.CH4.DST_TRANSFER_STEP = deststep; // TRANSFER_STEP is ignored when\n                                              // WRAP occurs.\n\n    EDIS;\n}\n\n//\n// DMACH4WrapConfig - DMA channel 4 wrap size configuration\n//\nvoid DMACH4WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize,\n                      int16 deswstep)\n{\n    EALLOW;\n\n    //\n    // Set up WRAP registers:\n    //\n    DmaRegs.CH4.SRC_WRAP_SIZE = srcwsize; // Wrap source address after N bursts\n    DmaRegs.CH4.SRC_WRAP_STEP = srcwstep; // Step for source wrap\n\n    DmaRegs.CH4.DST_WRAP_SIZE = deswsize; // Wrap destination address after\n                                          // N bursts.\n    DmaRegs.CH4.DST_WRAP_STEP = deswstep; // Step for destination wrap\n\n    EDIS;\n}\n\n//\n// DMACH4ModeConfig - DMA Channel 4 mode configuration\n//\nvoid DMACH4ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot,\n                      Uint16 cont, Uint16 synce, Uint16 syncsel,\n                      Uint16 ovrinte, Uint16 datasize, Uint16 chintmode,\n                      Uint16 chinte)\n{\n    EALLOW;\n\n    //\n    // Set up MODE Register:\n    // persel - Source select\n    // PERINTSEL - Should be hard coded to channel, above now selects source\n    // PERINTE - Peripheral interrupt enable\n    // ONESHOT - Oneshot enable\n    // CONTINUOUS - Continuous enable\n    // OVRINTE - Enable/disable the overflow interrupt\n    // DATASIZE - 16-bit/32-bit data size transfers\n    // CHINTMODE - Generate interrupt to CPU at beginning/end of transfer\n    // CHINTE - Channel Interrupt to  CPU enable\n    //\n    DmaClaSrcSelRegs.DMACHSRCSEL1.bit.CH4 = persel;\n    DmaRegs.CH4.MODE.bit.PERINTSEL = 4;\n    DmaRegs.CH4.MODE.bit.PERINTE = perinte;\n    DmaRegs.CH4.MODE.bit.ONESHOT = oneshot;\n    DmaRegs.CH4.MODE.bit.CONTINUOUS = cont;\n    DmaRegs.CH4.MODE.bit.OVRINTE = ovrinte;\n    DmaRegs.CH4.MODE.bit.DATASIZE = datasize;\n    DmaRegs.CH4.MODE.bit.CHINTMODE = chintmode;\n    DmaRegs.CH4.MODE.bit.CHINTE = chinte;\n\n    //\n    // Clear any spurious flags: Interrupt flags and sync error flags\n    //\n    DmaRegs.CH4.CONTROL.bit.PERINTCLR = 1;\n    DmaRegs.CH4.CONTROL.bit.ERRCLR = 1;\n\n    //\n    // Initialize PIE vector for CPU interrupt:\n    // Enable DMA CH4 interrupt in PIE\n    //\n    PieCtrlRegs.PIEIER7.bit.INTx4 = 1;\n\n    EDIS;\n}\n\n//\n// StartDMACH4 - This function starts DMA Channel 4.\n//\nvoid StartDMACH4(void)\n{\n    EALLOW;\n    DmaRegs.CH4.CONTROL.bit.RUN = 1;\n    EDIS;\n}\n\n//\n// DMACH5AddrConfig - DMA channel 5 address configuration\n//\nvoid DMACH5AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH5.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source; // Point to beginning\n                                                          // of source buffer\n    DmaRegs.CH5.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH5.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;  // Point to beginning\n                                                         // of destination\n                                                         // buffer.\n    DmaRegs.CH5.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH5BurstConfig - DMA Channel 5 burst size configuration\n//\nvoid DMACH5BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\n{\n    EALLOW;\n\n    //\n    // Set up BURST registers:\n    //\n    DmaRegs.CH5.BURST_SIZE.all = bsize;     // Number of words(X-1) x-ferred in\n                                            // a burst.\n    DmaRegs.CH5.SRC_BURST_STEP = srcbstep;  // Increment source addr between\n                                            // each word x-ferred.\n    DmaRegs.CH5.DST_BURST_STEP = desbstep;  // Increment dest addr between each\n                                            // word x-ferred.\n\n    EDIS;\n}\n\n//\n// DMACH5TransferConfig - DMA channel 5 transfer size configuration\n//\nvoid DMACH5TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\n{\n    EALLOW;\n\n    //\n    // Set up TRANSFER registers:\n    //\n    DmaRegs.CH5.TRANSFER_SIZE = tsize;        // Number of bursts per transfer,\n                                              // DMA interrupt will occur after\n                                              // completed transfer.\n    DmaRegs.CH5.SRC_TRANSFER_STEP = srctstep; // TRANSFER_STEP is ignored when\n                                              // WRAP occurs.\n    DmaRegs.CH5.DST_TRANSFER_STEP = deststep; // TRANSFER_STEP is ignored when\n                                              // WRAP occurs.\n\n    EDIS;\n}\n\n//\n// DMACH5WrapConfig - DMA Channel 5 wrap size configuration\n//\nvoid DMACH5WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize,\n                      int16 deswstep)\n{\n    EALLOW;\n\n    //\n    // Set up WRAP registers:\n    //\n    DmaRegs.CH5.SRC_WRAP_SIZE = srcwsize; // Wrap source address after N bursts\n    DmaRegs.CH5.SRC_WRAP_STEP = srcwstep; // Step for source wrap\n\n    DmaRegs.CH5.DST_WRAP_SIZE = deswsize; // Wrap destination address after\n                                          // N bursts.\n    DmaRegs.CH5.DST_WRAP_STEP = deswstep; // Step for destination wrap\n\n    EDIS;\n}\n\n//\n// DMACH5ModeConfig - DMA Channel 5 mode configuration\n//\nvoid DMACH5ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot,\n                      Uint16 cont, Uint16 synce, Uint16 syncsel,\n                      Uint16 ovrinte, Uint16 datasize, Uint16 chintmode,\n                      Uint16 chinte)\n{\n    EALLOW;\n\n    //\n    // Set up MODE Register:\n    // persel - Source select\n    // PERINTSEL - Should be hard coded to channel, above now selects source\n    // PERINTE - Peripheral interrupt enable\n    // ONESHOT - Oneshot enable\n    // CONTINUOUS - Continuous enable\n    // OVRINTE - Enable/disable the overflow interrupt\n    // DATASIZE - 16-bit/32-bit data size transfers\n    // CHINTMODE - Generate interrupt to CPU at beginning/end of transfer\n    // CHINTE - Channel Interrupt to  CPU enable\n    //\n    DmaClaSrcSelRegs.DMACHSRCSEL2.bit.CH5 = persel;\n    DmaRegs.CH5.MODE.bit.PERINTSEL = 5;\n    DmaRegs.CH5.MODE.bit.PERINTE = perinte;\n    DmaRegs.CH5.MODE.bit.ONESHOT = oneshot;\n    DmaRegs.CH5.MODE.bit.CONTINUOUS = cont;\n    DmaRegs.CH5.MODE.bit.OVRINTE = ovrinte;\n    DmaRegs.CH5.MODE.bit.DATASIZE = datasize;\n    DmaRegs.CH5.MODE.bit.CHINTMODE = chintmode;\n    DmaRegs.CH5.MODE.bit.CHINTE = chinte;\n\n    //\n    // Clear any spurious flags: Interrupt flags and sync error flags\n    //\n    DmaRegs.CH5.CONTROL.bit.PERINTCLR = 1;\n    DmaRegs.CH5.CONTROL.bit.ERRCLR = 1;\n\n    //\n    // Initialize PIE vector for CPU interrupt:\n    // Enable DMA CH5 interrupt in PIE\n    //\n    PieCtrlRegs.PIEIER7.bit.INTx5 = 1;\n\n    EDIS;\n}\n\n//\n// StartDMACH5 - This function starts DMA Channel 5.\n//\nvoid StartDMACH5(void)\n{\n    EALLOW;\n    DmaRegs.CH5.CONTROL.bit.RUN = 1;\n    EDIS;\n}\n\n//\n// DMACH6AddrConfig - DMA Channel 6 address configuration\n//\nvoid DMACH6AddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH6.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source; // Point to beginning\n                                                          // of source buffer.\n    DmaRegs.CH6.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH6.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;  // Point to beginning\n                                                         // of destination\n                                                         // buffer.\n    DmaRegs.CH6.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH6BurstConfig - DMA Channel 6 burst size configuration\n//\nvoid DMACH6BurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep)\n{\n    EALLOW;\n\n    //\n    // Set up BURST registers:\n    //\n    DmaRegs.CH6.BURST_SIZE.all = bsize;     // Number of words(X-1) x-ferred in\n                                            // a burst.\n    DmaRegs.CH6.SRC_BURST_STEP = srcbstep;  // Increment source addr between\n                                            // each word x-ferred.\n    DmaRegs.CH6.DST_BURST_STEP = desbstep;  // Increment dest addr between each\n                                            // word x-ferred.\n\n    EDIS;\n}\n\n//\n// DMACH6TransferConfig - DMA channel 6 transfer size configuration\n//\nvoid DMACH6TransferConfig(Uint16 tsize, int16 srctstep, int16 deststep)\n{\n    EALLOW;\n\n    //\n    // Set up TRANSFER registers:\n    //\n    DmaRegs.CH6.TRANSFER_SIZE = tsize;        // Number of bursts per transfer,\n                                              // DMA interrupt will occur after\n                                              // completed transfer.\n    DmaRegs.CH6.SRC_TRANSFER_STEP = srctstep; // TRANSFER_STEP is ignored when\n                                              // WRAP occurs.\n    DmaRegs.CH6.DST_TRANSFER_STEP = deststep; // TRANSFER_STEP is ignored when\n                                              // WRAP occurs.\n\n    EDIS;\n}\n\n//\n// DMACH6WrapConfig - DMA Channel 6 wrap size configuration\n//\nvoid DMACH6WrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize,\n                      int16 deswstep)\n{\n    EALLOW;\n\n    //\n    // Set up WRAP registers:\n    //\n    DmaRegs.CH6.SRC_WRAP_SIZE = srcwsize; // Wrap source address after N bursts\n    DmaRegs.CH6.SRC_WRAP_STEP = srcwstep; // Step for source wrap\n\n    DmaRegs.CH6.DST_WRAP_SIZE = deswsize; // Wrap destination address after N\n                                          // bursts.\n    DmaRegs.CH6.DST_WRAP_STEP = deswstep; // Step for destination wrap\n\n    EDIS;\n}\n\n//\n// DMACH6ModeConfig - DMA Channel 6 mode configuration\n//\nvoid DMACH6ModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot,\n                      Uint16 cont, Uint16 synce, Uint16 syncsel,\n                      Uint16 ovrinte, Uint16 datasize, Uint16 chintmode,\n                      Uint16 chinte)\n{\n    EALLOW;\n\n    //\n    // Set up MODE Register:\n    // persel - Source select\n    // PERINTSEL - Should be hard coded to channel, above now selects source\n    // PERINTE - Peripheral interrupt enable\n    // ONESHOT - Oneshot enable\n    // CONTINUOUS - Continuous enable\n    // OVRINTE - Enable/disable the overflow interrupt\n    // DATASIZE - 16-bit/32-bit data size transfers\n    // CHINTMODE - Generate interrupt to CPU at beginning/end of transfer\n    // CHINTE - Channel Interrupt to  CPU enable\n    //\n    DmaClaSrcSelRegs.DMACHSRCSEL2.bit.CH6 = persel;\n    DmaRegs.CH6.MODE.bit.PERINTSEL = 6;\n    DmaRegs.CH6.MODE.bit.PERINTE = perinte;\n    DmaRegs.CH6.MODE.bit.ONESHOT = oneshot;\n    DmaRegs.CH6.MODE.bit.CONTINUOUS = cont;\n    DmaRegs.CH6.MODE.bit.OVRINTE = ovrinte;\n    DmaRegs.CH6.MODE.bit.DATASIZE = datasize;\n    DmaRegs.CH6.MODE.bit.CHINTMODE = chintmode;\n    DmaRegs.CH6.MODE.bit.CHINTE = chinte;\n\n    //\n    // Clear any spurious flags: Interrupt flags and sync error flags\n    //\n    DmaRegs.CH6.CONTROL.bit.PERINTCLR = 1;\n    DmaRegs.CH6.CONTROL.bit.ERRCLR = 1;\n\n    //\n    // Initialize PIE vector for CPU interrupt:\n    // Enable DMA CH6 interrupt in PIE\n    //\n    PieCtrlRegs.PIEIER7.bit.INTx6 = 1;\n\n    EDIS;\n}\n\n//\n// StartDMACH6 - This function starts DMA Channel 6.\n//\nvoid StartDMACH6(void)\n{\n    EALLOW;\n    DmaRegs.CH6.CONTROL.bit.RUN = 1;\n    EDIS;\n}\n\n//\n// NOTE:\n// Following functions are required for EMIF as the address is out of\n// 22bit range\n//\n\n//\n// DMACH1AddrConfig32bit - DMA Channel 1 address configuration for 32bit\n//\nvoid DMACH1AddrConfig32bit(volatile Uint32 *DMA_Dest,\n                           volatile Uint32 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH1.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source; // Point to beginning\n                                                          // of source buffer\n    DmaRegs.CH1.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH1.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;  // Point to beginning\n                                                         // of destination\n                                                         // buffer\n    DmaRegs.CH1.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH2AddrConfig32bit - DMA Channel 2 address configuration for 32bit\n//\nvoid DMACH2AddrConfig32bit(volatile Uint32 *DMA_Dest,\n                           volatile Uint32 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH2.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source; // Point to beginning\n                                                          // of source buffer\n    DmaRegs.CH2.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH2.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;  // Point to beginning\n                                                         // of destination\n                                                         // buffer\n    DmaRegs.CH2.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH3AddrConfig32bit - DMA Channel 3 address configuration for 32bit\n//\nvoid DMACH3AddrConfig32bit(volatile Uint32 *DMA_Dest,\n                           volatile Uint32 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH3.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source; // Point to beginning\n                                                          // of source buffer\n    DmaRegs.CH3.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH3.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;  // Point to beginning\n                                                         // of destination\n                                                         // buffer.\n    DmaRegs.CH3.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH4AddrConfig32bit - DMA Channel 4 address configuration for 32bit\n//\nvoid DMACH4AddrConfig32bit(volatile Uint32 *DMA_Dest,\n                           volatile Uint32 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH4.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source; // Point to beginning\n                                                          // of source buffer\n    DmaRegs.CH4.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH4.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;   // Point to beginning\n                                                          // of destination\n                                                          // buffer\n    DmaRegs.CH4.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH5AddrConfig32bit - DMA Channel 5 address configuration for 32bit\n//\nvoid DMACH5AddrConfig32bit(volatile Uint32 *DMA_Dest,\n                           volatile Uint32 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH5.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source; // Point to beginning\n                                                          // of source buffer\n    DmaRegs.CH5.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH5.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;   // Point to beginning\n                                                          // of destination\n                                                          // buffer\n    DmaRegs.CH5.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// DMACH6AddrConfig32bit - DMA Channel 6 address configuration for 32bit\n//\nvoid DMACH6AddrConfig32bit(volatile Uint32 *DMA_Dest,\n                           volatile Uint32 *DMA_Source)\n{\n    EALLOW;\n\n    //\n    // Set up SOURCE address:\n    //\n    DmaRegs.CH6.SRC_BEG_ADDR_SHADOW = (Uint32)DMA_Source; // Point to beginning\n                                                          // of source buffer\n    DmaRegs.CH6.SRC_ADDR_SHADOW =     (Uint32)DMA_Source;\n\n    //\n    // Set up DESTINATION address:\n    //\n    DmaRegs.CH6.DST_BEG_ADDR_SHADOW = (Uint32)DMA_Dest;   // Point to beginning\n                                                          // of destination\n                                                          // buffer\n    DmaRegs.CH6.DST_ADDR_SHADOW =     (Uint32)DMA_Dest;\n\n    EDIS;\n}\n\n//\n// End of file\n//\n"},{"name":"F2837xD_GlobalVariableDefs.c","type":"source","group":"legacy","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_02_00_00\\device_support\\f2837xd\\headers\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:    F2837xD_globalvariabledefs.c\n//\n// TITLE:   F2837xD Global Variables and Data Section Pragmas.\n//\n//###########################################################################\n//\n// $Release Date:  $\n// $Copyright:\n// Copyright (C) 2013-2024 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n#include \"F2837xD_device.h\"     // F2837xD Headerfile Include File\n\n//---------------------------------------------------------------------------\n// Define Global Peripheral Variables:\n//\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AccessProtectionRegsFile\")\n#else\n#pragma DATA_SECTION(AccessProtectionRegs,\"AccessProtectionRegsFile\");\n#endif\nvolatile struct ACCESS_PROTECTION_REGS AccessProtectionRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdcaRegsFile\")\n#else\n#pragma DATA_SECTION(AdcaRegs,\"AdcaRegsFile\");\n#endif\nvolatile struct ADC_REGS AdcaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdcbRegsFile\")\n#else\n#pragma DATA_SECTION(AdcbRegs,\"AdcbRegsFile\");\n#endif\nvolatile struct ADC_REGS AdcbRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdccRegsFile\")\n#else\n#pragma DATA_SECTION(AdccRegs,\"AdccRegsFile\");\n#endif\nvolatile struct ADC_REGS AdccRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdcdRegsFile\")\n#else\n#pragma DATA_SECTION(AdcdRegs,\"AdcdRegsFile\");\n#endif\nvolatile struct ADC_REGS AdcdRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdcaResultRegsFile\")\n#else\n#pragma DATA_SECTION(AdcaResultRegs,\"AdcaResultRegsFile\");\n#endif\nvolatile struct ADC_RESULT_REGS AdcaResultRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdcbResultRegsFile\")\n#else\n#pragma DATA_SECTION(AdcbResultRegs,\"AdcbResultRegsFile\");\n#endif\nvolatile struct ADC_RESULT_REGS AdcbResultRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdccResultRegsFile\")\n#else\n#pragma DATA_SECTION(AdccResultRegs,\"AdccResultRegsFile\");\n#endif\nvolatile struct ADC_RESULT_REGS AdccResultRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdcdResultRegsFile\")\n#else\n#pragma DATA_SECTION(AdcdResultRegs,\"AdcdResultRegsFile\");\n#endif\nvolatile struct ADC_RESULT_REGS AdcdResultRegs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AnalogSubsysRegsFile\")\n#else\n#pragma DATA_SECTION(AnalogSubsysRegs,\"AnalogSubsysRegsFile\");\n#endif\nvolatile struct ANALOG_SUBSYS_REGS AnalogSubsysRegs;\n#endif // ifdef CPU1\n\n#if __TI_COMPILER_VERSION__ >= 16006000\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CanaRegsFile\")\n#else\n#pragma DATA_SECTION(CanaRegs,\"CanaRegsFile\");\n#endif\nvolatile struct CAN_REGS CanaRegs;\n#endif // __TI_COMPILER_VERSION__ >= 16006000\n\n#if __TI_COMPILER_VERSION__ >= 16006000\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CanbRegsFile\")\n#else\n#pragma DATA_SECTION(CanbRegs,\"CanbRegsFile\");\n#endif\nvolatile struct CAN_REGS CanbRegs;\n#endif // __TI_COMPILER_VERSION__ >= 16006000\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cla1RegsFile\")\n#else\n#pragma DATA_SECTION(Cla1Regs,\"Cla1RegsFile\");\n#endif\nvolatile struct CLA_REGS Cla1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb1DataExchRegsFile\")\n#else\n#pragma DATA_SECTION(Clb1DataExchRegs,\"Clb1DataExchRegsFile\");\n#endif\nvolatile struct CLB_DATA_EXCHANGE_REGS Clb1DataExchRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb2DataExchRegsFile\")\n#else\n#pragma DATA_SECTION(Clb2DataExchRegs,\"Clb2DataExchRegsFile\");\n#endif\nvolatile struct CLB_DATA_EXCHANGE_REGS Clb2DataExchRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb3DataExchRegsFile\")\n#else\n#pragma DATA_SECTION(Clb3DataExchRegs,\"Clb3DataExchRegsFile\");\n#endif\nvolatile struct CLB_DATA_EXCHANGE_REGS Clb3DataExchRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb4DataExchRegsFile\")\n#else\n#pragma DATA_SECTION(Clb4DataExchRegs,\"Clb4DataExchRegsFile\");\n#endif\nvolatile struct CLB_DATA_EXCHANGE_REGS Clb4DataExchRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb1LogicCfgRegsFile\")\n#else\n#pragma DATA_SECTION(Clb1LogicCfgRegs,\"Clb1LogicCfgRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONFIG_REGS Clb1LogicCfgRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb2LogicCfgRegsFile\")\n#else\n#pragma DATA_SECTION(Clb2LogicCfgRegs,\"Clb2LogicCfgRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONFIG_REGS Clb2LogicCfgRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb3LogicCfgRegsFile\")\n#else\n#pragma DATA_SECTION(Clb3LogicCfgRegs,\"Clb3LogicCfgRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONFIG_REGS Clb3LogicCfgRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb4LogicCfgRegsFile\")\n#else\n#pragma DATA_SECTION(Clb4LogicCfgRegs,\"Clb4LogicCfgRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONFIG_REGS Clb4LogicCfgRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb1LogicCtrlRegsFile\")\n#else\n#pragma DATA_SECTION(Clb1LogicCtrlRegs,\"Clb1LogicCtrlRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONTROL_REGS Clb1LogicCtrlRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb2LogicCtrlRegsFile\")\n#else\n#pragma DATA_SECTION(Clb2LogicCtrlRegs,\"Clb2LogicCtrlRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONTROL_REGS Clb2LogicCtrlRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb3LogicCtrlRegsFile\")\n#else\n#pragma DATA_SECTION(Clb3LogicCtrlRegs,\"Clb3LogicCtrlRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONTROL_REGS Clb3LogicCtrlRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb4LogicCtrlRegsFile\")\n#else\n#pragma DATA_SECTION(Clb4LogicCtrlRegs,\"Clb4LogicCtrlRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONTROL_REGS Clb4LogicCtrlRegs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ClbXbarRegsFile\")\n#else\n#pragma DATA_SECTION(ClbXbarRegs,\"ClbXbarRegsFile\");\n#endif\nvolatile struct CLB_XBAR_REGS ClbXbarRegs;\n#endif // ifdef CPU1\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ClkCfgRegsFile\")\n#else\n#pragma DATA_SECTION(ClkCfgRegs,\"ClkCfgRegsFile\");\n#endif\nvolatile struct CLK_CFG_REGS ClkCfgRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss1RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss1Regs,\"Cmpss1RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss2RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss2Regs,\"Cmpss2RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss3RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss3Regs,\"Cmpss3RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss3Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss4RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss4Regs,\"Cmpss4RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss4Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss5RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss5Regs,\"Cmpss5RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss5Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss6RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss6Regs,\"Cmpss6RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss6Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss7RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss7Regs,\"Cmpss7RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss7Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss8RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss8Regs,\"Cmpss8RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss8Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CpuTimer0RegsFile\")\n#else\n#pragma DATA_SECTION(CpuTimer0Regs,\"CpuTimer0RegsFile\");\n#endif\nvolatile struct CPUTIMER_REGS CpuTimer0Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CpuTimer1RegsFile\")\n#else\n#pragma DATA_SECTION(CpuTimer1Regs,\"CpuTimer1RegsFile\");\n#endif\nvolatile struct CPUTIMER_REGS CpuTimer1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CpuTimer2RegsFile\")\n#else\n#pragma DATA_SECTION(CpuTimer2Regs,\"CpuTimer2RegsFile\");\n#endif\nvolatile struct CPUTIMER_REGS CpuTimer2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CpuSysRegsFile\")\n#else\n#pragma DATA_SECTION(CpuSysRegs,\"CpuSysRegsFile\");\n#endif\nvolatile struct CPU_SYS_REGS CpuSysRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DacaRegsFile\")\n#else\n#pragma DATA_SECTION(DacaRegs,\"DacaRegsFile\");\n#endif\nvolatile struct DAC_REGS DacaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DacbRegsFile\")\n#else\n#pragma DATA_SECTION(DacbRegs,\"DacbRegsFile\");\n#endif\nvolatile struct DAC_REGS DacbRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DaccRegsFile\")\n#else\n#pragma DATA_SECTION(DaccRegs,\"DaccRegsFile\");\n#endif\nvolatile struct DAC_REGS DaccRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DcsmCommonRegsFile\")\n#else\n#pragma DATA_SECTION(DcsmCommonRegs,\"DcsmCommonRegsFile\");\n#endif\nvolatile struct DCSM_COMMON_REGS DcsmCommonRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DcsmZ1RegsFile\")\n#else\n#pragma DATA_SECTION(DcsmZ1Regs,\"DcsmZ1RegsFile\");\n#endif\nvolatile struct DCSM_Z1_REGS DcsmZ1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DcsmZ2RegsFile\")\n#else\n#pragma DATA_SECTION(DcsmZ2Regs,\"DcsmZ2RegsFile\");\n#endif\nvolatile struct DCSM_Z2_REGS DcsmZ2Regs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DevCfgRegsFile\")\n#else\n#pragma DATA_SECTION(DevCfgRegs,\"DevCfgRegsFile\");\n#endif\nvolatile struct DEV_CFG_REGS DevCfgRegs;\n#endif // ifdef CPU1\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DmaClaSrcSelRegsFile\")\n#else\n#pragma DATA_SECTION(DmaClaSrcSelRegs,\"DmaClaSrcSelRegsFile\");\n#endif\nvolatile struct DMA_CLA_SRC_SEL_REGS DmaClaSrcSelRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DmaRegsFile\")\n#else\n#pragma DATA_SECTION(DmaRegs,\"DmaRegsFile\");\n#endif\nvolatile struct DMA_REGS DmaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap1RegsFile\")\n#else\n#pragma DATA_SECTION(ECap1Regs,\"ECap1RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap2RegsFile\")\n#else\n#pragma DATA_SECTION(ECap2Regs,\"ECap2RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap3RegsFile\")\n#else\n#pragma DATA_SECTION(ECap3Regs,\"ECap3RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap3Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap4RegsFile\")\n#else\n#pragma DATA_SECTION(ECap4Regs,\"ECap4RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap4Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap5RegsFile\")\n#else\n#pragma DATA_SECTION(ECap5Regs,\"ECap5RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap5Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap6RegsFile\")\n#else\n#pragma DATA_SECTION(ECap6Regs,\"ECap6RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap6Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Emif1ConfigRegsFile\")\n#else\n#pragma DATA_SECTION(Emif1ConfigRegs,\"Emif1ConfigRegsFile\");\n#endif\nvolatile struct EMIF1_CONFIG_REGS Emif1ConfigRegs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Emif2ConfigRegsFile\")\n#else\n#pragma DATA_SECTION(Emif2ConfigRegs,\"Emif2ConfigRegsFile\");\n#endif\nvolatile struct EMIF2_CONFIG_REGS Emif2ConfigRegs;\n#endif // ifdef CPU1\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Emif1RegsFile\")\n#else\n#pragma DATA_SECTION(Emif1Regs,\"Emif1RegsFile\");\n#endif\nvolatile struct EMIF_REGS Emif1Regs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Emif2RegsFile\")\n#else\n#pragma DATA_SECTION(Emif2Regs,\"Emif2RegsFile\");\n#endif\nvolatile struct EMIF_REGS Emif2Regs;\n#endif // ifdef CPU1\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm1RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm1Regs,\"EPwm1RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm2RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm2Regs,\"EPwm2RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm3RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm3Regs,\"EPwm3RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm3Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm4RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm4Regs,\"EPwm4RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm4Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm5RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm5Regs,\"EPwm5RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm5Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm6RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm6Regs,\"EPwm6RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm6Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm7RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm7Regs,\"EPwm7RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm7Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm8RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm8Regs,\"EPwm8RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm8Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm9RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm9Regs,\"EPwm9RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm9Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm10RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm10Regs,\"EPwm10RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm10Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm11RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm11Regs,\"EPwm11RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm11Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm12RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm12Regs,\"EPwm12RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm12Regs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwmXbarRegsFile\")\n#else\n#pragma DATA_SECTION(EPwmXbarRegs,\"EPwmXbarRegsFile\");\n#endif\nvolatile struct EPWM_XBAR_REGS EPwmXbarRegs;\n#endif // ifdef CPU1\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EQep1RegsFile\")\n#else\n#pragma DATA_SECTION(EQep1Regs,\"EQep1RegsFile\");\n#endif\nvolatile struct EQEP_REGS EQep1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EQep2RegsFile\")\n#else\n#pragma DATA_SECTION(EQep2Regs,\"EQep2RegsFile\");\n#endif\nvolatile struct EQEP_REGS EQep2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EQep3RegsFile\")\n#else\n#pragma DATA_SECTION(EQep3Regs,\"EQep3RegsFile\");\n#endif\nvolatile struct EQEP_REGS EQep3Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Flash0CtrlRegsFile\")\n#else\n#pragma DATA_SECTION(Flash0CtrlRegs,\"Flash0CtrlRegsFile\");\n#endif\nvolatile struct FLASH_CTRL_REGS Flash0CtrlRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Flash0EccRegsFile\")\n#else\n#pragma DATA_SECTION(Flash0EccRegs,\"Flash0EccRegsFile\");\n#endif\nvolatile struct FLASH_ECC_REGS Flash0EccRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"FlashPumpSemaphoreRegsFile\")\n#else\n#pragma DATA_SECTION(FlashPumpSemaphoreRegs,\"FlashPumpSemaphoreRegsFile\");\n#endif\nvolatile struct FLASH_PUMP_SEMAPHORE_REGS FlashPumpSemaphoreRegs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"GpioCtrlRegsFile\")\n#else\n#pragma DATA_SECTION(GpioCtrlRegs,\"GpioCtrlRegsFile\");\n#endif\nvolatile struct GPIO_CTRL_REGS GpioCtrlRegs;\n#endif // ifdef CPU1\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"GpioDataRegsFile\")\n#else\n#pragma DATA_SECTION(GpioDataRegs,\"GpioDataRegsFile\");\n#endif\nvolatile struct GPIO_DATA_REGS GpioDataRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"I2caRegsFile\")\n#else\n#pragma DATA_SECTION(I2caRegs,\"I2caRegsFile\");\n#endif\nvolatile struct I2C_REGS I2caRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"I2cbRegsFile\")\n#else\n#pragma DATA_SECTION(I2cbRegs,\"I2cbRegsFile\");\n#endif\nvolatile struct I2C_REGS I2cbRegs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"InputXbarRegsFile\")\n#else\n#pragma DATA_SECTION(InputXbarRegs,\"InputXbarRegsFile\");\n#endif\nvolatile struct INPUT_XBAR_REGS InputXbarRegs;\n#endif // ifdef CPU1\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"IpcRegsFile\")\n#else\n#pragma DATA_SECTION(IpcRegs,\"IpcRegsFile\");\n#endif\nvolatile struct IPC_REGS_CPU1 IpcRegs;\n#endif // ifdef CPU1\n\n#ifdef CPU2\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"IpcRegsFile\")\n#else\n#pragma DATA_SECTION(IpcRegs,\"IpcRegsFile\");\n#endif\nvolatile struct IPC_REGS_CPU2 IpcRegs;\n#endif // ifdef CPU2\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"MemoryErrorRegsFile\")\n#else\n#pragma DATA_SECTION(MemoryErrorRegs,\"MemoryErrorRegsFile\");\n#endif\nvolatile struct MEMORY_ERROR_REGS MemoryErrorRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"MemCfgRegsFile\")\n#else\n#pragma DATA_SECTION(MemCfgRegs,\"MemCfgRegsFile\");\n#endif\nvolatile struct MEM_CFG_REGS MemCfgRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"McbspaRegsFile\")\n#else\n#pragma DATA_SECTION(McbspaRegs,\"McbspaRegsFile\");\n#endif\nvolatile struct McBSP_REGS McbspaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"McbspbRegsFile\")\n#else\n#pragma DATA_SECTION(McbspbRegs,\"McbspbRegsFile\");\n#endif\nvolatile struct McBSP_REGS McbspbRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"NmiIntruptRegsFile\")\n#else\n#pragma DATA_SECTION(NmiIntruptRegs,\"NmiIntruptRegsFile\");\n#endif\nvolatile struct NMI_INTRUPT_REGS NmiIntruptRegs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"OutputXbarRegsFile\")\n#else\n#pragma DATA_SECTION(OutputXbarRegs,\"OutputXbarRegsFile\");\n#endif\nvolatile struct OUTPUT_XBAR_REGS OutputXbarRegs;\n#endif // ifdef CPU1\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"PieCtrlRegsFile\")\n#else\n#pragma DATA_SECTION(PieCtrlRegs,\"PieCtrlRegsFile\");\n#endif\nvolatile struct PIE_CTRL_REGS PieCtrlRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"PieVectTableFile\")\n#else\n#pragma DATA_SECTION(PieVectTable,\"PieVectTableFile\");\n#endif\nvolatile struct PIE_VECT_TABLE PieVectTable;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"RomPrefetchRegsFile\")\n#else\n#pragma DATA_SECTION(RomPrefetchRegs,\"RomPrefetchRegsFile\");\n#endif\nvolatile struct ROM_PREFETCH_REGS RomPrefetchRegs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"RomWaitStateRegsFile\")\n#else\n#pragma DATA_SECTION(RomWaitStateRegs,\"RomWaitStateRegsFile\");\n#endif\nvolatile struct ROM_WAIT_STATE_REGS RomWaitStateRegs;\n#endif // ifdef CPU1\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"SciaRegsFile\")\n#else\n#pragma DATA_SECTION(SciaRegs,\"SciaRegsFile\");\n#endif\nvolatile struct SCI_REGS SciaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ScibRegsFile\")\n#else\n#pragma DATA_SECTION(ScibRegs,\"ScibRegsFile\");\n#endif\nvolatile struct SCI_REGS ScibRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ScicRegsFile\")\n#else\n#pragma DATA_SECTION(ScicRegs,\"ScicRegsFile\");\n#endif\nvolatile struct SCI_REGS ScicRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ScidRegsFile\")\n#else\n#pragma DATA_SECTION(ScidRegs,\"ScidRegsFile\");\n#endif\nvolatile struct SCI_REGS ScidRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Sdfm1RegsFile\")\n#else\n#pragma DATA_SECTION(Sdfm1Regs,\"Sdfm1RegsFile\");\n#endif\nvolatile struct SDFM_REGS Sdfm1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Sdfm2RegsFile\")\n#else\n#pragma DATA_SECTION(Sdfm2Regs,\"Sdfm2RegsFile\");\n#endif\nvolatile struct SDFM_REGS Sdfm2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"SpiaRegsFile\")\n#else\n#pragma DATA_SECTION(SpiaRegs,\"SpiaRegsFile\");\n#endif\nvolatile struct SPI_REGS SpiaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"SpibRegsFile\")\n#else\n#pragma DATA_SECTION(SpibRegs,\"SpibRegsFile\");\n#endif\nvolatile struct SPI_REGS SpibRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"SpicRegsFile\")\n#else\n#pragma DATA_SECTION(SpicRegs,\"SpicRegsFile\");\n#endif\nvolatile struct SPI_REGS SpicRegs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"SyncSocRegsFile\")\n#else\n#pragma DATA_SECTION(SyncSocRegs,\"SyncSocRegsFile\");\n#endif\nvolatile struct SYNC_SOC_REGS SyncSocRegs;\n#endif // ifdef CPU1\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"UidRegsFile\")\n#else\n#pragma DATA_SECTION(UidRegs,\"UidRegsFile\");\n#endif\nvolatile struct UID_REGS UidRegs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"UppRegsFile\")\n#else\n#pragma DATA_SECTION(UppRegs,\"UppRegsFile\");\n#endif\nvolatile struct UPP_REGS UppRegs;\n#endif // ifdef CPU1\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"WdRegsFile\")\n#else\n#pragma DATA_SECTION(WdRegs,\"WdRegsFile\");\n#endif\nvolatile struct WD_REGS WdRegs;\n\n#ifdef CPU1\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"XbarRegsFile\")\n#else\n#pragma DATA_SECTION(XbarRegs,\"XbarRegsFile\");\n#endif\nvolatile struct XBAR_REGS XbarRegs;\n#endif // ifdef CPU1\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"XintRegsFile\")\n#else\n#pragma DATA_SECTION(XintRegs,\"XintRegsFile\");\n#endif\nvolatile struct XINT_REGS XintRegs;\n\n\n\n//===========================================================================\n// End of file.\n//===========================================================================\n\n\n"},{"name":"F2837xD_Gpio.c","type":"source","group":"legacy","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_02_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:    F2837xD_Gpio.c\n//\n// TITLE:    GPIO module support functions\n//\n//###########################################################################\n//\n// $Release Date:  $\n// $Copyright:\n// Copyright (C) 2013-2024 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"F2837xD_device.h\"\n#include \"F2837xD_Examples.h\"\n\n//\n//Low-level functions for GPIO configuration (CPU1 only)\n//\n\n#ifdef CPU1\n    //\n    // InitGpio - Sets all pins to be muxed to GPIO in input mode.\n    //            Also resets CPU control to CPU1 and disables open\n    //            drain and polarity inversion and sets the qualification to\n    //            synchronous. Also unlocks all GPIOs. Only one CPU should call\n    //            this function.\n    //\n    void InitGpio()\n    {\n        volatile Uint32 *gpioBaseAddr;\n        Uint16 regOffset;\n\n        //\n        //Disable pin locks\n        //\n        EALLOW;\n        GpioCtrlRegs.GPALOCK.all = 0x00000000;\n        GpioCtrlRegs.GPBLOCK.all = 0x00000000;\n        GpioCtrlRegs.GPCLOCK.all = 0x00000000;\n        GpioCtrlRegs.GPDLOCK.all = 0x00000000;\n        GpioCtrlRegs.GPELOCK.all = 0x00000000;\n        GpioCtrlRegs.GPFLOCK.all = 0x00000000;\n\n        //\n        // Fill all registers with zeros. Writing to each register separately\n        // for six GPIO modules would make this function *very* long.\n        // Fortunately, we'd be writing them all with zeros anyway, so this\n        // saves a lot of space.\n        //\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n        for (regOffset = 0; regOffset < sizeof(GpioCtrlRegs)/2; regOffset++)\n        {\n            //\n            //Hack to avoid enabling pull-ups on all pins. GPyPUD is offset\n            //0x0C in each register group of 0x40 words. Since this is a\n            //32-bit pointer, the addresses must be divided by 2.\n            //\n            if (regOffset % (0x40/2) != (0x0C/2))\n            {\n                gpioBaseAddr[regOffset] = 0x00000000;\n            }\n        }\n\n        gpioBaseAddr = (Uint32 *)&GpioDataRegs;\n        for (regOffset = 0; regOffset < sizeof(GpioDataRegs)/2; regOffset++)\n        {\n            gpioBaseAddr[regOffset] = 0x00000000;\n        }\n\n        EDIS;\n    }\n\n    //\n    // GPIO_SetupPinMux - Set the peripheral muxing for the specified pin. The\n    //                    appropriate parameters can be found in the GPIO Muxed\n    //                    Pins table(4.4) in the  datasheet. Use the GPIO index\n    //                    row (0 to 15) to select a muxing option for the GPIO.\n    //\n    void GPIO_SetupPinMux(Uint16 gpioNumber, Uint16 cpu, Uint16 muxPosition)\n    {\n        volatile Uint32 *gpioBaseAddr;\n        volatile Uint32 *mux, *gmux, *csel;\n        Uint16 pin32, pin16, pin8;\n\n        pin32 = gpioNumber % 32;\n        pin16 = gpioNumber % 16;\n        pin8 = gpioNumber % 8;\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (gpioNumber/32)*GPY_CTRL_OFFSET;\n\n        //\n        //Sanity check for valid cpu and peripheral values\n        //\n        if (cpu > GPIO_MUX_CPU2CLA || muxPosition > 0xF)\n            return;\n\n        //\n        //Create pointers to the appropriate registers. This is a workaround\n        //for the way GPIO registers are defined. The standard definition\n        //in the header file makes it very easy to do named accesses of one\n        //register or bit, but hard to do arbitrary numerical accesses. It's\n        //easier to have an array of GPIO modules with identical registers,\n        //including arrays for multi-register groups like GPyCSEL1-4. But\n        //the header file doesn't define anything we can turn into an array,\n        //so manual pointer arithmetic is used instead.\n        //\n        mux = gpioBaseAddr + GPYMUX + pin32/16;\n        gmux = gpioBaseAddr + GPYGMUX + pin32/16;\n        csel = gpioBaseAddr + GPYCSEL + pin32/8;\n\n        //\n        //Now for the actual function\n        //\n        EALLOW;\n\n        //\n        //To change the muxing, set the peripheral mux to 0/GPIO first to avoid\n        //glitches, then change the group mux, then set the peripheral mux to\n        //its target value. Finally, set the CPU select. This procedure is\n        //described in the TRM. Unfortunately, since we don't know the pin in\n        //advance we can't hardcode a bitfield reference, so there's some\n        //tricky bit twiddling here.\n        //\n        *mux &= ~(0x3UL << (2*pin16));\n        *gmux &= ~(0x3UL << (2*pin16));\n        *gmux |= (Uint32)((muxPosition >> 2) & 0x3UL) << (2*pin16);\n        *mux |= (Uint32)(muxPosition & 0x3UL) << (2*pin16);\n\n        *csel &= ~(0x3L << (4*pin8));\n        *csel |= (Uint32)(cpu & 0x3L) << (4*pin8);\n\n        //\n        //WARNING: This code does not touch the analog mode select registers,\n        //which are needed to give the USB module control of its IOs.\n        //\n        EDIS;\n    }\n\n    //\n    // GPIO_SetupPinOptions - Setup up the GPIO input/output options for the\n    //                        specified pin.\n    //\n    //The flags are a 16-bit mask produced by ORing together options.\n    //For input pins, the valid flags are:\n    //GPIO_PULLUP    Enable pull-up\n    //GPIO_INVERT    Enable input polarity inversion\n    //GPIO_SYNC        Synchronize the input latch to PLLSYSCLK\n    //               (default -- you don't need to specify this)\n    //GPIO_QUAL3    Use 3-sample qualification\n    //GPIO_QUAL6    Use 6-sample qualification\n    //GPIO_ASYNC    Do not use synchronization or qualification\n    //(Note: only one of SYNC, QUAL3, QUAL6, or ASYNC is allowed)\n    //\n    //For output pins, the valid flags are:\n    //GPIO_OPENDRAIN    Output in open drain mode\n    //GPIO_PULLUP        If open drain enabled, also enable the pull-up\n    //and the input qualification flags (SYNC/QUAL3/QUAL6/SYNC) listed above.\n    //\n    //With no flags, the default input state is synchronous with no\n    //pull-up or polarity inversion. The default output state is\n    //the standard digital output.\n    //\n    void GPIO_SetupPinOptions(Uint16 gpioNumber, Uint16 output, Uint16 flags)\n    {\n        volatile Uint32 *gpioBaseAddr;\n        volatile Uint32 *dir, *pud, *inv, *odr, *qsel;\n        Uint32 pin32, pin16, pinMask, qual;\n\n        pin32 = gpioNumber % 32;\n        pin16 = gpioNumber % 16;\n        pinMask = 1UL << pin32;\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (gpioNumber/32)*GPY_CTRL_OFFSET;\n\n        //\n        //Create pointers to the appropriate registers. This is a workaround\n        //for the way GPIO registers are defined. The standard definition\n        //in the header file makes it very easy to do named accesses of one\n        //register or bit, but hard to do arbitrary numerical accesses. It's\n        //easier to have an array of GPIO modules with identical registers,\n        //including arrays for multi-register groups like GPyQSEL1-2. But\n        //the header file doesn't define anything we can turn into an array,\n        //so manual pointer arithmetic is used instead.\n        //\n        dir = gpioBaseAddr + GPYDIR;\n        pud = gpioBaseAddr + GPYPUD;\n        inv = gpioBaseAddr + GPYINV;\n        odr = gpioBaseAddr + GPYODR;\n        qsel = gpioBaseAddr + GPYQSEL + pin32/16;\n\n        EALLOW;\n\n        //\n        //Set the data direction\n        //\n        *dir &= ~pinMask;\n        if (output == 1)\n        {\n            //\n            //Output, with optional open drain mode and pull-up\n            //\n            *dir |= pinMask;\n\n            //\n            //Enable open drain if necessary\n            //\n            if (flags & GPIO_OPENDRAIN)\n            {\n                *odr |= pinMask;\n            }\n            else\n            {\n                *odr &= ~pinMask;\n            }\n\n            //\n            //Enable pull-up if necessary. Open drain mode must be active.\n            //\n            if (flags & (GPIO_OPENDRAIN | GPIO_PULLUP))\n            {\n                *pud &= ~pinMask;\n            }\n            else\n            {\n                *pud |= pinMask;\n            }\n        }\n        else\n        {\n            //\n            //Input, with optional pull-up, qualification, and polarity\n            //inversion\n            //\n            *dir &= ~pinMask;\n\n            //\n            //Enable pull-up if necessary\n            //\n            if (flags & GPIO_PULLUP)\n            {\n                *pud &= ~pinMask;\n            }\n            else\n            {\n                *pud |= pinMask;\n            }\n\n            //\n            //Invert polarity if necessary\n            //\n            if (flags & GPIO_INVERT)\n            {\n                *inv |= pinMask;\n            }\n            else\n            {\n                *inv &= ~pinMask;\n            }\n        }\n\n        //\n        //Extract the qualification parameter and load it into the register.\n        //This is also needed for open drain outputs, so we might as well do it\n        //all the time.\n        //\n        qual = (flags & GPIO_ASYNC) / GPIO_QUAL3;\n        *qsel &= ~(0x3L << (2 * pin16));\n        if (qual != 0x0)\n        {\n            *qsel |= qual << (2 * pin16);\n        }\n\n        EDIS;\n    }\n\n    //\n    // GPIO_SetupLock - Enable or disable the GPIO register bit lock for the\n    //                  specified pin.\n    //                  The valid flags are:\n    //                  GPIO_UNLOCK - Unlock the pin setup register bits for\n    //                                the specified pin\n    //                  GPIO_LOCK - Lock the pin setup register bits for the\n    //                              specified pin\n    //\n    void GPIO_SetupLock(Uint16 gpioNumber, Uint16 flags)\n    {\n        volatile Uint32 *gpioBaseAddr;\n        volatile Uint32 *lock;\n        Uint32 pin32, pinMask;\n\n        pin32 = gpioNumber % 32;\n        pinMask = 1UL << pin32;\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (gpioNumber/32)*GPY_CTRL_OFFSET;\n\n        //\n        //Create pointers to the appropriate registers. This is a workaround\n        //for the way GPIO registers are defined. The standard definition\n        //in the header file makes it very easy to do named accesses of one\n        //register or bit, but hard to do arbitrary numerical accesses. It's\n        //easier to have an array of GPIO modules with identical registers,\n        //including arrays for multi-register groups like GPyQSEL1-2. But\n        //the header file doesn't define anything we can turn into an array,\n        //so manual pointer arithmetic is used instead.\n        //\n        lock = gpioBaseAddr + GPYLOCK;\n\n        EALLOW;\n        if(flags)\n        {\n            //Lock the pin\n            *lock |= pinMask;\n        }\n        else\n        {\n            //Unlock the pin\n            *lock &= ~pinMask;\n        }\n        EDIS;\n    }\n\n    //\n    //External interrupt setup\n    //\n    void GPIO_SetupXINT1Gpio(Uint16 gpioNumber)\n    {\n        EALLOW;\n        InputXbarRegs.INPUT4SELECT = gpioNumber;      //Set XINT1 source to GPIO-pin\n        EDIS;\n    }\n    void GPIO_SetupXINT2Gpio(Uint16 gpioNumber)\n    {\n        EALLOW;\n        InputXbarRegs.INPUT5SELECT = gpioNumber;      //Set XINT2 source to GPIO-pin\n        EDIS;\n    }\n    void GPIO_SetupXINT3Gpio(Uint16 gpioNumber)\n    {\n        EALLOW;\n        InputXbarRegs.INPUT6SELECT = gpioNumber;      //Set XINT3 source to GPIO-pin\n        EDIS;\n    }\n    void GPIO_SetupXINT4Gpio(Uint16 gpioNumber)\n    {\n        EALLOW;\n        InputXbarRegs.INPUT13SELECT = gpioNumber;     //Set XINT4 source to GPIO-pin\n        EDIS;\n    }\n    void GPIO_SetupXINT5Gpio(Uint16 gpioNumber)\n    {\n        EALLOW;\n        InputXbarRegs.INPUT14SELECT = gpioNumber;     //Set XINT5 source to GPIO-pin\n        EDIS;\n    }\n\n    //\n    //GPIO_EnableUnbondedIOPullupsFor176Pin - Enable pullups for the unbonded\n    //                                        GPIOs on the 176PTP package:\n    //                                        GPIOs     Grp Bits\n    //                                        95-132    C   31\n    //                                                  D   31:0\n    //                                                  E   4:0\n    //                                        134-168   E   31:6\n    //                                                  F   8:0\n    //\n    void GPIO_EnableUnbondedIOPullupsFor176Pin()\n    {\n        EALLOW;\n        GpioCtrlRegs.GPCPUD.all = ~0x80000000;  //GPIO 95\n        GpioCtrlRegs.GPDPUD.all = ~0xFFFFFFF7;  //GPIOs 96-127\n        GpioCtrlRegs.GPEPUD.all = ~0xFFFFFFDF;  //GPIOs 128-159 except for 133\n        GpioCtrlRegs.GPFPUD.all = ~0x000001FF;  //GPIOs 160-168\n        EDIS;\n    }\n\n    //\n    // GPIO_EnableUnbondedIOPullupsFor100Pin - Enable pullups for the unbonded\n    //                                         GPIOs on the 100PZ package:\n    //                                         GPIOs     Grp Bits\n    //                                         0-1       A   1:0\n    //                                         5-9       A   9:5\n    //                                         22-40     A   31:22\n    //                                                   B   8:0\n    //                                         44-57     B   25:12\n    //                                         67-68     C   4:3\n    //                                         74-77     C   13:10\n    //                                         79-83     C   19:15\n    //                                         93-168    C   31:29\n    //                                                   D   31:0\n    //                                                   E   31:0\n    //                                                   F   8:0\n    //\n    void GPIO_EnableUnbondedIOPullupsFor100Pin()\n    {\n        EALLOW;\n        GpioCtrlRegs.GPAPUD.all = ~0xFFC003E3;  //GPIOs 0-1, 5-9, 22-31\n        GpioCtrlRegs.GPBPUD.all = ~0x03FFF1FF;  //GPIOs 32-40, 44-57\n        GpioCtrlRegs.GPCPUD.all = ~0xE10FBC18;  //GPIOs 67-68, 74-77, 79-83, 93-95\n        GpioCtrlRegs.GPDPUD.all = ~0xFFFFFFF7;  //GPIOs 96-127\n        GpioCtrlRegs.GPEPUD.all = ~0xFFFFFFFF;  //GPIOs 128-159\n        GpioCtrlRegs.GPFPUD.all = ~0x000001FF;  //GPIOs 160-168\n        EDIS;\n    }\n\n    //\n    // GPIO_EnableUnbondedIOPullups - InitSysCtrl would call this function\n    //                                this takes care of enabling IO pullups.\n    //\n    void GPIO_EnableUnbondedIOPullups()\n    {\n        //\n        //bits 8-10 have pin count\n        //\n        unsigned char pin_count = ((DevCfgRegs.PARTIDL.all & 0x00000700) >> 8) ;\n\n        //\n        //5 = 100 pin\n        //6 = 176 pin\n        //7 = 337 pin\n        //\n        if(pin_count == 5)\n        {\n            GPIO_EnableUnbondedIOPullupsFor100Pin();\n        }\n        else if (pin_count == 6)\n        {\n            GPIO_EnableUnbondedIOPullupsFor176Pin();\n        }\n        else\n        {\n            //do nothing - this is 337 pin package\n        }\n    }\n\n#endif //CPU1\n\n//\n// GPIO_ReadPin - Read the GPyDAT register bit for the specified pin. Note that\n//                this returns the actual state of the pin, not the state of\n//                the output latch.\n//\nUint16 GPIO_ReadPin(Uint16 gpioNumber)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint16 pinVal;\n\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (gpioNumber/32)*GPY_DATA_OFFSET;\n    pinVal = (gpioDataReg[GPYDAT] >> (gpioNumber % 32)) & 0x1;\n\n    return pinVal;\n}\n\n//\n// GPIO_WritePin - Set the GPyDAT register bit for the specified pin.\n//\nvoid GPIO_WritePin(Uint16 gpioNumber, Uint16 outVal)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;\n\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (gpioNumber/32)*GPY_DATA_OFFSET;\n    pinMask = 1UL << (gpioNumber % 32);\n\n    if (outVal == 0)\n    {\n        gpioDataReg[GPYCLEAR] = pinMask;\n    }\n    else\n    {\n        gpioDataReg[GPYSET] = pinMask;\n    }\n}\n\n//\n// End of file\n//\n"},{"name":"F2837xD_Ipc_Driver_Lite.c","type":"source","group":"legacy","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_02_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   F2837xD_Ipc_Driver_Lite.c\n//\n// TITLE:  F2837xD Inter-Processor Communication (IPC) Lite API Driver\n//         Functions.\n//\n// DESCRIPTION:\n//         API functions for inter-processor communications between\n//         CPU1 control system and CPU2 control system (Lite version). The IPC\n//         Lite functions only allow for basic functions such as data writes,\n//         reads, bit setting, and bit clearing.  The Lite functions do not\n//         require the usage of the MSG RAM's or shared memories and can only\n//         be used with a single IPC interrupt channel.  Commands can only\n//         be processed one at a time without queuing.\n//         The driver functions in this file are available only as\n//         sample functions for application development.  Due to the generic\n//         nature of these functions and the cycle overhead inherent to a\n//         function call, the code is not intended to be used in cases where\n//         maximum efficiency is required in a system.\n//\n// NOTE:   This source code is used by both CPUs. That is both CPU1 and CPU2\n//         cores use this code.\n//         The active debug CPU will be referred to as Local CPU and the other\n//         CPU will be referred to as Remote CPU.\n//         When using this source code in CPU1, the term \"local\"\n//         will mean CPU1 and the term \"remote\" CPU will be mean CPU2.\n//         When using this source code in CPU2, the term \"local\"\n//         will mean CPU2 and the term \"remote\" CPU will be mean CPU1.\n//\n//         The abbreviations LtoR and RtoL  within the function names mean\n//         Local to Remote and Remote to Local respectively.\n//\n//###########################################################################\n//\n// $Release Date: $\n// $Copyright:\n// Copyright (C) 2013-2024 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//*****************************************************************************\n//! \\addtogroup ipc_lite_api IPC-Lite API Drivers\n//! @{\n//*****************************************************************************\n#include \"F2837xD_device.h\"\n#include \"F2837xD_Ipc_drivers.h\"\n\n//\n// Function Prototypes\n//\nvoid DelayLoop (void);\n\n//*****************************************************************************\n//\n//! Reads single word data result of Local to Remote IPC command\n//!\n//! \\param pvData is a pointer to the 16/32-bit variable where the result data\n//! will be stored.\n//! \\param usLength designates 16- or 32-bit read.\n//! \\param ulStatusFlag indicates the Local to Remote CPU Flag number mask used\n//!  to report the status of the command sent back from the Remote CPU. If\n//!  a status flag was not used with the command call, set this parameter to 0.\n//!\n//! Allows the caller to read the 16/32-bit data result of non-blocking IPC\n//! functions from the IPCREMOTEREPLY register if the status flag is cleared\n//! indicating the IPC command was successfully interpreted. If the status flag\n//! is not cleared, the command was not recognized, and the function will\n//! return STATUS_FAIL. To determine what data is read from a call to this\n//! function, see the descriptions of the non-blocking IPC functions.\n//! The \\e usLength parameter accepts the following values: \\b\n//! IPC_LENGTH_16_BITS or \\b IPC_LENGTH_32_BITS. The  \\e ulStatusFlag parameter\n//! accepts any of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b NO_FLAG.\n//! The function returns \\b STATUS_PASS or \\b STATUS_FAIL.\n//!\n//! \\return status of command (0=success, 1=error)\n//\n//*****************************************************************************\nuint16_t\nIPCLiteLtoRGetResult (void *pvData, uint16_t usLength, uint32_t ulStatusFlag)\n{\n    uint16_t returnStatus;\n\n    //\n    // If Remote System never acknowledged Status Task, indicates command\n    // failure.\n    //\n    if (IpcRegs.IPCFLG.all & ulStatusFlag)\n    {\n        returnStatus = STATUS_FAIL;\n    }\n    else\n    {\n        //\n        // Read data.\n        //\n        if (usLength == IPC_LENGTH_16_BITS)\n        {\n            *(uint16_t *)pvData = IpcRegs.IPCREMOTEREPLY;\n        }\n        else if (usLength == IPC_LENGTH_32_BITS)\n        {\n            *(uint32_t *)pvData =  IpcRegs.IPCREMOTEREPLY;\n        }\n\n        returnStatus = STATUS_PASS;\n    }\n\n    return returnStatus;\n}\n\n//*****************************************************************************\n//\n//! Reads either a 16- or 32-bit data word from the remote CPU System address\n//!\n//! \\param ulFlag specifies Local to Remote IPC Flag number mask used to\n//!        indicate a command is being sent.\n//! \\param ulAddress specifies the remote address to read from\n//! \\param usLength designates 16- or 32-bit read (1 = 16-bit, 2 = 32-bit)\n//! \\param ulStatusFlag indicates the Local to Remote Flag number mask used to\n//!  report the status of the command sent back from the remote system.\n//!\n//! This function will allow the Local CPU System to read 16/32-bit data from\n//! the Remote CPU System into the IPCREMOTEREPLY register. After calling this\n//! function, a call to \\e IPCLiteLtoRGetResult() will read the data value in\n//! the IPCREMOTEREPLY register into a 16- or 32-bit variable in the local CPU\n//! application.\n//! The \\e usLength parameter accepts the following values: \\b\n//! IPC_LENGTH_16_BITS or \\b IPC_LENGTH_32_BITS. The \\e ulStatusFlag parameter\n//! accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b\n//! NO_FLAG. The function returns \\b STATUS_PASS if the command is successful\n//! or \\b STATUS_FAIL if the request or status flags are unavailable.\n//!\n//! \\return status of command (0=success, 1=error)\n//\n//*****************************************************************************\nuint16_t\nIPCLiteLtoRDataRead(uint32_t ulFlag, uint32_t ulAddress, uint16_t usLength,\n                    uint32_t ulStatusFlag)\n{\n    uint16_t returnStatus;\n\n    //\n    // Return false if IPC Local to Remote request or status flags are not\n    // available.\n    //\n    if (IpcRegs.IPCFLG.all & (ulFlag | ulStatusFlag))\n    {\n        returnStatus = STATUS_FAIL;\n    }\n    else\n    {\n        //\n        // Set up read command, address, and word length.\n        //\n        if (usLength == IPC_LENGTH_16_BITS)\n        {\n            IpcRegs.IPCSENDCOM = IPC_DATA_READ_16;\n        }\n        else if (usLength == IPC_LENGTH_32_BITS)\n        {\n            IpcRegs.IPCSENDCOM = IPC_DATA_READ_32;\n        }\n        IpcRegs.IPCSENDADDR = ulAddress;\n\n        //\n        // Force IPC event on selected request task and enable status-checking.\n        //\n        IpcRegs.IPCSET.all = (ulFlag | ulStatusFlag);\n\n        returnStatus = STATUS_PASS;\n    }\n\n    return returnStatus;\n}\n\n//*****************************************************************************\n//\n//! Sets the designated bits in a 16/32-bit data word at the remote CPU system\n//! address\n//!\n//! \\param ulFlag specifies Local to Remote IPC Flag number mask used to\n//!        indicate a command is being sent.\n//! \\param ulAddress specifies the Remote address to write to.\n//! \\param ulMask specifies the 16/32-bit mask for bits which should be set at\n//!  remote ulAddress. For 16-bit mask, only the lower 16-bits of ulMask are\n//!  considered.\n//! \\param usLength specifies the length of the \\e ulMask (1 = 16-bit, 2 =\n//! 32-bit).\n//! \\param ulStatusFlag indicates the Local to Remote Flag number mask used to\n//!        report the status of the command sent back from the Remote system.\n//!\n//! This function will allow the Local CPU system to set bits specified by the\n//! \\e usMask variable in a 16/32-bit word on the Remote CPU system. The data\n//! word at /e ulAddress after the set bits command is then read into the\n//! IPCREMOTEREPLY register. After calling this function, a call to \\e\n//! IPCLiteLtoRGetResult() will read the data value in the IPCREMOTEREPLY\n//! register into a 16/32-bit variable in the Local CPU application.\n//! The \\e usLength parameter accepts the following values: \\b\n//! IPC_LENGTH_16_BITS or \\b IPC_LENGTH_32_BITS. The \\e ulStatusFlag parameter\n//! accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b\n//! NO_FLAG. The function returns \\b STATUS_PASS if the command is successful\n//! or \\b STATUS_FAIL if the request or status flags are unavailable.\n//!\n//! \\return status of command (0=success, 1=error)\n//\n//*****************************************************************************\nuint16_t\nIPCLiteLtoRSetBits(uint32_t ulFlag, uint32_t ulAddress, uint32_t ulMask,\n                   uint16_t usLength, uint32_t ulStatusFlag)\n{\n    uint16_t returnStatus;\n\n    //\n    // Return false if IPC Local to Remote request or status flags are not\n    // available.\n    //\n    if (IpcRegs.IPCFLG.all & (ulFlag | ulStatusFlag))\n    {\n        returnStatus = STATUS_FAIL;\n    }\n    else\n    {\n        if (usLength == IPC_LENGTH_16_BITS)\n        {\n            //\n            // Set up 16-bit set bits command, address, and mask.\n            //\n            IpcRegs.IPCSENDCOM = IPC_SET_BITS_16;\n            IpcRegs.IPCSENDADDR = ulAddress;\n            IpcRegs.IPCSENDDATA = ulMask & (0x0000FFFF);\n        }\n        else if (usLength == IPC_LENGTH_32_BITS)\n        {\n            //\n            // Set up 32-bit set bits command, address, and mask.\n            //\n            IpcRegs.IPCSENDCOM = IPC_SET_BITS_32;\n            IpcRegs.IPCSENDADDR = ulAddress;\n            IpcRegs.IPCSENDDATA = ulMask;\n        }\n\n        //\n        // Force IPC event on selected request task and enable status-checking.\n        //\n        IpcRegs.IPCSET.all = (ulFlag | ulStatusFlag);\n\n        returnStatus = STATUS_PASS;\n    }\n\n    return returnStatus;\n}\n\n//*****************************************************************************\n//\n//! Sets the designated bits in a 16/32-bit write-protected data word at\n//! the Remote CPU system address\n//!\n//! \\param ulFlag specifies Local to Remote IPC Flag number mask used to\n//!        indicate a command is being sent.\n//! \\param ulAddress specifies the Remote CPU write-protected address to write\n//!        to.\n//! \\param ulMask specifies the 16/32-bit mask for bits which should be set at\n//!  Remote CPU ulAddress.For 16-bit mask, only the lower 16-bits of ulMask are\n//!  considered.\n//! \\param usLength specifies the length of the \\e ulMask (1 = 16-bit, 2 =\n//! 32-bit).\n//! \\param ulStatusFlag indicates the Local to Remote Flag number mask used to\n//!        report the status of the command sent back from the Master system.\n//!\n//! This function will allow the Local CPU system to set bits specified by the\n//! \\e usMask variable in a write-protected 16/32-bit word on the REmote CPU\n//! system.\n//! The data word at /e ulAddress after the set bits command is then read into\n//! the IPCREMOTEREPLY register. After calling this function, a call to\n//! \\e IPCLiteLtoRGetResult() will read the data value in the IPCREMOTEREPLY\n//! register into a 16/32-bit variable in the Local application.\n//! The \\e usLength parameter accepts the following values: \\b\n//! IPC_LENGTH_16_BITS or \\b IPC_LENGTH_32_BITS. The \\e ulStatusFlag parameter\n//! accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b\n//! NO_FLAG. The function returns \\b STATUS_PASS if the command is successful\n//! or \\b STATUS_FAIL if the request or status flags are unavailable.\n//!\n//! \\return status of command (0=success, 1=error)\n//\n//*****************************************************************************\nuint16_t\nIPCLiteLtoRSetBits_Protected (uint32_t ulFlag, uint32_t ulAddress,\n                              uint32_t ulMask, uint16_t usLength,\n                              uint32_t ulStatusFlag)\n{\n    uint16_t returnStatus;\n\n    //\n    // Return false if IPC Local to Remote request or status flags are not\n    // available.\n    //\n    if (IpcRegs.IPCFLG.all & (ulFlag | ulStatusFlag))\n    {\n        returnStatus = STATUS_FAIL;\n    }\n    else\n    {\n        if (usLength == IPC_LENGTH_16_BITS)\n        {\n            //\n            // Set up 16-bit set bits command, address, and mask.\n            //\n            IpcRegs.IPCSENDCOM = IPC_SET_BITS_16_PROTECTED;\n            IpcRegs.IPCSENDADDR = ulAddress;\n            IpcRegs.IPCSENDDATA = ulMask & (0x0000FFFF);\n        }\n        else if (usLength == IPC_LENGTH_32_BITS)\n        {\n            //\n            // Set up 32-bit set bits command, address, and mask.\n            //\n            IpcRegs.IPCSENDCOM = IPC_SET_BITS_32_PROTECTED;\n            IpcRegs.IPCSENDADDR = ulAddress;\n            IpcRegs.IPCSENDDATA = ulMask;\n        }\n\n        //\n        // Force IPC event on selected request task and enable status-checking.\n        //\n        IpcRegs.IPCSET.all = (ulFlag | ulStatusFlag);\n\n        returnStatus = STATUS_PASS;\n    }\n\n    return returnStatus;\n}\n\n//*****************************************************************************\n//\n//! Sets the designated bits in a 16/32-bit data word at the remote CPU system\n//! address\n//!\n//! \\param ulFlag specifies Local to Remote IPC Flag number mask used to\n//!        indicate a command is being sent.\n//! \\param ulAddress specifies the Remote CPU address to write to.\n//! \\param ulMask specifies the 16/32-bit mask for bits which should be set at\n//! the remote CPU ulAddress. (For 16-bit mask, only the lower 16-bits of\n//! ulMask are considered.\n//! \\param usLength specifies the length of the \\e ulMask (1 = 16-bit, 2 =\n//! 32-bit).\n//! \\param ulStatusFlag indicates the Local to Remote Flag number mask used to\n//! report the status of the command sent back from the Master system.\n//!\n//! This function will allow the Local CPU system to set bits specified by the\n//! \\e usMask variable in a 16/32-bit word on the Remote CPU system. The data\n//! word at /e ulAddress after the set bits command is then read into the\n//! IPCREMOTEREPLY register. After calling this function, a call to \\e\n//! IPCLiteLtoRGetResult() will read the data value in the IPCREMOTEREPLY\n//! register into a 16/32-bit variable in the Local CPU application.\n//! The \\e usLength parameter accepts the following values: \\b\n//! IPC_LENGTH_16_BITS or \\b IPC_LENGTH_32_BITS. The \\e ulStatusFlag parameter\n//! accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b\n//! NO_FLAG. The function returns \\b STATUS_PASS if the command is successful\n//! or \\b STATUS_FAIL if the request or status flags are unavailable.\n//!\n//! \\return status of command (0=success, 1=error)\n//\n//*****************************************************************************\nuint16_t\nIPCLiteLtoRClearBits(uint32_t ulFlag, uint32_t ulAddress, uint32_t ulMask,\n                     uint16_t usLength, uint32_t ulStatusFlag)\n{\n    uint16_t returnStatus;\n\n    //\n    // Return false if IPC Local to Remote request or status flags are not\n    // available.\n    //\n    if (IpcRegs.IPCFLG.all & (ulFlag | ulStatusFlag))\n    {\n        returnStatus = STATUS_FAIL;\n    }\n    else\n    {\n        if (usLength == IPC_LENGTH_16_BITS)\n        {\n            //\n            // Set up 16-bit set bits command, address, and mask.\n            //\n            IpcRegs.IPCSENDCOM = IPC_CLEAR_BITS_16;\n            IpcRegs.IPCSENDADDR = ulAddress;\n            IpcRegs.IPCSENDDATA = ulMask & (0x0000FFFF);\n        }\n        else if (usLength == IPC_LENGTH_32_BITS)\n        {\n            //\n            // Set up 32-bit set bits command, address, and mask.\n            //\n            IpcRegs.IPCSENDCOM = IPC_CLEAR_BITS_32;\n            IpcRegs.IPCSENDADDR = ulAddress;\n            IpcRegs.IPCSENDDATA = ulMask;\n        }\n\n        //\n        // Force IPC event on selected request task and enable status-checking.\n        //\n        IpcRegs.IPCSET.all = (ulFlag | ulStatusFlag);\n\n        returnStatus = STATUS_PASS;\n    }\n\n    return returnStatus;\n}\n\n//*****************************************************************************\n//\n//! Clears the designated bits in a 16/32-bit write-protected data word at\n//! Remote CPU system address\n//!\n//! \\param ulFlag specifies Local to Remote IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulAddress specifies the Remote CPU write-protected address to write\n//! to.\n//! \\param ulMask specifies the 16/32-bit mask for bits which should be cleared\n//! at Remote CPU ulAddress.For 16-bit mask, only the lower 16-bits of ulMask\n//! are considered.\n//! \\param usLength specifies the length of the \\e ulMask (1 = 16-bit, 2 =\n//! 32-bit).\n//! \\param ulStatusFlag indicates the Local to Remote Flag number mask used to\n//! report the status of the command sent back from the Master system.\n//!\n//! This function will allow the Local CPU system to clear bits specified by\n//! the \\e usMask variable in a write-protected 16/32-bit word on the Remote\n//! CPU system.\n//! The data word at /e ulAddress after the clear bits command is then read\n//! into the IPCREMOTEREPLY register. After calling this function, a call to\n//! \\e IPCLiteLtoRGetResult() will read the data value in the IPCREMOTEREPLY\n//! register into a 16/32-bit variable in the Local CPU application.\n//! The \\e usLength parameter accepts the following values: \\b\n//! IPC_LENGTH_16_BITS or \\b IPC_LENGTH_32_BITS. The \\e ulStatusFlag parameter\n//! accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b\n//! NO_FLAG. The function returns \\b STATUS_PASS if the command is successful\n//! or \\b STATUS_FAIL if the request or status flags are unavailable.\n//!\n//! \\return status of command (0=success, 1=error)\n//\n//*****************************************************************************\nuint16_t\nIPCLiteLtoRClearBits_Protected (uint32_t ulFlag, uint32_t ulAddress,\n                                uint32_t ulMask, uint16_t usLength,\n                                uint32_t ulStatusFlag)\n{\n    uint16_t returnStatus;\n\n    //\n    // Return false if IPC Local to Remote request or status flags are not\n    // available.\n    //\n    if (IpcRegs.IPCFLG.all & (ulFlag | ulStatusFlag))\n    {\n        returnStatus = STATUS_FAIL;\n    }\n    else\n    {\n        if (usLength == IPC_LENGTH_16_BITS)\n        {\n            //\n            // Set up 16-bit set bits command, address, and mask.\n            //\n            IpcRegs.IPCSENDCOM = IPC_CLEAR_BITS_16_PROTECTED;\n            IpcRegs.IPCSENDADDR = ulAddress;\n            IpcRegs.IPCSENDDATA = ulMask & (0x0000FFFF);\n        }\n        else if (usLength == IPC_LENGTH_32_BITS)\n        {\n            //\n            // Set up 32-bit set bits command, address, and mask.\n            //\n            IpcRegs.IPCSENDCOM = IPC_CLEAR_BITS_32_PROTECTED;\n            IpcRegs.IPCSENDADDR = ulAddress;\n            IpcRegs.IPCSENDDATA = ulMask;\n        }\n\n        //\n        // Force IPC event on selected request task and enable status-checking.\n        //\n        IpcRegs.IPCSET.all = (ulFlag | ulStatusFlag);\n\n        returnStatus = STATUS_PASS;\n    }\n\n    return returnStatus;\n}\n\n//*****************************************************************************\n//\n//! Writes a 16/32-bit data word to Remote CPU System address\n//!\n//! \\param ulFlag specifies Local to Remote IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulAddress specifies the Remote CPU address to write to\n//! \\param ulData specifies the 16/32-bit word which will be written.\n//! For 16-bit words, only the lower 16-bits of ulData will be considered by\n//! the master system.\n//! \\param usLength is the length of the word to write (0 = 16-bits, 1 =\n//! 32-bits)\n//! \\param ulStatusFlag indicates the Local to Remote Flag number mask used to\n//! report the status of the command sent back from the Remote CPU  system.\n//!\n//! This function will allow the Local CPU System to write a 16/32-bit word\n//! via the \\e ulData variable to an address on the Remote CPU System.\n//! The \\e usLength parameter accepts the following values: \\b\n//! IPC_LENGTH_16_BITS or \\b IPC_LENGTH_32_BITS. The \\e ulStatusFlag parameter\n//! accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b\n//! NO_FLAG. The function returns \\b STATUS_PASS if the command is successful\n//! or \\b STATUS_FAIL if the request or status flags are unavailable.\n//!\n//! \\return status of command (0=success, 1=error)\n//\n//*****************************************************************************\nuint16_t\nIPCLiteLtoRDataWrite(uint32_t ulFlag, uint32_t ulAddress, uint32_t ulData,\n                     uint16_t usLength, uint32_t ulStatusFlag)\n{\n    uint16_t returnStatus;\n\n    //\n    // Return false if IPC Local to Remote request or status flags are not\n    // available.\n    //\n    if (IpcRegs.IPCFLG.all & (ulFlag | ulStatusFlag))\n    {\n        returnStatus = STATUS_FAIL;\n    }\n    else\n    {\n        //\n        // Set up data write command, address, and data. For 16-bit write,\n        // Master system will look at lower 16-bits only.\n        //\n        if (usLength == IPC_LENGTH_16_BITS)\n        {\n            IpcRegs.IPCSENDCOM = IPC_DATA_WRITE_16;\n        }\n        else if (usLength == IPC_LENGTH_32_BITS)\n        {\n            IpcRegs.IPCSENDCOM = IPC_DATA_WRITE_32;\n        }\n        IpcRegs.IPCSENDADDR = ulAddress;\n        IpcRegs.IPCSENDDATA = ulData;\n\n        //\n        // Force IPC event on selected request task and enable status-checking\n        //\n        IpcRegs.IPCSET.all = (ulFlag | ulStatusFlag);\n\n        returnStatus = STATUS_PASS;\n    }\n\n    return returnStatus;\n}\n\n//*****************************************************************************\n//\n//! Writes a 16/32-bit data word to a protected Remote CPU System address\n//!\n//! \\param ulFlag specifies Local to Remote IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulAddress specifies the Remote CPU address to write to\n//! \\param ulData specifies the 16/32-bit word which will be written.\n//! For 16-bit words, only the lower 16-bits of ulData will be considered by\n//! the master system.\n//! \\param usLength is the length of the word to write (0 = 16-bits, 1 =\n//! 32-bits)\n//! \\param ulStatusFlag indicates the Local to Remote Flag number mask used to\n//! report the status of the command sent back from the Master  system.\n//!\n//! This function will allow the Local CPU System to write a 16/32-bit word\n//! via the \\e ulData variable to a write-protected address on the Remote CPU\n//! System. The \\e usLength parameter accepts the following values: \\b\n//! IPC_LENGTH_16_BITS or \\b IPC_LENGTH_32_BITS. The \\e ulStatusFlag parameter\n//! accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b\n//! NO_FLAG. The function returns \\b STATUS_PASS if the command is successful\n//! or \\b STATUS_FAIL if the request or status flags are unavailable.\n//!\n//! \\return status of command (0=success, 1=error)\n//\n//*****************************************************************************\nuint16_t\nIPCLiteLtoRDataWrite_Protected(uint32_t ulFlag, uint32_t ulAddress,\n                               uint32_t ulData, uint16_t usLength,\n                               uint32_t ulStatusFlag)\n{\n    uint16_t returnStatus;\n\n    //\n    // Return false if IPC Local to Remote request or status flags are not\n    // available.\n    //\n    if (IpcRegs.IPCFLG.all & (ulFlag | ulStatusFlag))\n    {\n        returnStatus = STATUS_FAIL;\n    }\n    else\n    {\n        //\n        // Set up data write command, address, and data. For 16-bit write, Master\n        // system will look at lower 16-bits only.\n        //\n        if (usLength == IPC_LENGTH_16_BITS)\n        {\n            IpcRegs.IPCSENDCOM = IPC_DATA_WRITE_16_PROTECTED;\n        }\n        else if (usLength == IPC_LENGTH_32_BITS)\n        {\n            IpcRegs.IPCSENDCOM = IPC_DATA_WRITE_32_PROTECTED;\n        }\n        IpcRegs.IPCSENDADDR = ulAddress;\n        IpcRegs.IPCSENDDATA = ulData;\n\n        //\n        // Force IPC event on selected request task and enable status-checking\n        //\n        IpcRegs.IPCSET.all = (ulFlag | ulStatusFlag);\n\n        returnStatus = STATUS_PASS;\n    }\n\n    return returnStatus;\n}\n\n//*****************************************************************************\n//\n//! Calls a Remote CPU function with 1 optional parameter and an optional\n//! return value.\n//!\n//! \\param ulFlag specifies Local to Remote IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulAddress specifies the Remote CPU function address\n//! \\param ulParam specifies the 32-bit optional parameter value\n//! \\param ulStatusFlag indicates the Local to Remote Flag number mask used to\n//! report the status of the command sent back from the control  system.\n//!\n//! This function will allow the Local CPU system to call a function on the\n//! Remote CPU. The \\e ulParam variable is a single optional 32-bit parameter\n//! to pass to the function. The \\e ulFlag parameter accepts any one of the\n//! flag values \\b IPC_FLAG1 - \\b IPC_FLAG32. The \\e ulStatusFlag parameter\n//! accepts any other one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32\n//! and \\b NO_FLAG. The function returns \\b STATUS_PASS if the command is\n//! successful or \\b STATUS_FAIL if the request or status flags are unavailable.\n//!\n//! \\return status of command (0=success, 1=error)\n//\n//*****************************************************************************\nuint16_t\nIPCLiteLtoRFunctionCall(uint32_t ulFlag, uint32_t ulAddress, uint32_t ulParam,\n                        uint32_t ulStatusFlag)\n{\n    uint16_t returnStatus;\n\n    //\n    // Return false if IPC Remote to Local request or status flags are not\n    // available.\n    //\n    if (IpcRegs.IPCFLG.all & (ulFlag | ulStatusFlag))\n    {\n        returnStatus = STATUS_FAIL;\n    }\n    else\n    {\n        //\n        // Set up function call command, address, and parameter.\n        //\n        IpcRegs.IPCSENDCOM = IPC_FUNC_CALL;\n        IpcRegs.IPCSENDADDR = ulAddress;\n        IpcRegs.IPCSENDDATA = ulParam;\n\n        //\n        // Force IPC event on selected request task and enable status-checking\n        //\n        IpcRegs.IPCSET.all = (ulFlag | ulStatusFlag);\n\n        returnStatus = STATUS_PASS;\n    }\n\n    return returnStatus;\n}\n\n//*****************************************************************************\n//\n//! Slave Requests Master R/W/Exe Access to Shared SARAM.\n//!\n//! \\param ulFlag specifies Local to Remote IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulMask specifies the 32-bit mask for the GSxMEMSEL RAM control\n//! register to indicate which GSx SARAM blocks the Slave is requesting master\n//! access to.\n//! \\param ulMaster specifies whether CPU1 or CPU2 should be the master of the\n//! GSx RAM.\n//! \\param ulStatusFlag indicates the Local to Remote Flag number mask used to\n//! report the status of the command sent back from the Master  system.\n//!\n//! This function will allow the slave CPU System to request slave or master\n//! mastership of any of the GSx Shared SARAM blocks.\n//! The \\e ulMaster parameter accepts the following values:\n//! \\b IPC_GSX_CPU2_MASTER or \\b IPC_GSX_CPU1_MASTER. The \\e ulStatusFlag\n//! parameter accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32\n//! and \\b NO_FLAG. The function returns \\b STATUS_PASS if the command is\n//! successful or \\b STATUS_FAIL if the request or status flags are unavailable.\n//! \\note This function calls the \\e IPCLiteLtoRSetBits_Protected() or the\n//! \\e IPCLiteLtoRClearBits_Protected function, and therefore in order to\n//! process this function, the above 2 functions should be ready to be called\n//! on the master system to process this command.\n//!\n//! \\return status of command (0=success, 1=error)\n//\n//*****************************************************************************\nuint16_t\nIPCLiteReqMemAccess (uint32_t ulFlag, uint32_t ulMask, uint16_t ulMaster,\n                     uint32_t ulStatusFlag)\n{\n    uint16_t status;\n    uint32_t GSxMSEL_REGaddress = (uint32_t)(&MemCfgRegs.GSxMSEL.all);\n    if (ulMaster == IPC_GSX_CPU2_MASTER)\n    {\n        status =\n            IPCLiteLtoRSetBits_Protected (ulFlag, GSxMSEL_REGaddress, ulMask,\n                                          IPC_LENGTH_32_BITS,\n                                          ulStatusFlag);\n    }\n    else if (ulMaster == IPC_GSX_CPU1_MASTER)\n    {\n        status =\n            IPCLiteLtoRClearBits_Protected (ulFlag, GSxMSEL_REGaddress, ulMask,\n                                            IPC_LENGTH_32_BITS,\n                                            ulStatusFlag);\n    }\n\n    return status;\n}\n\n//*****************************************************************************\n//\n//! Reads either a 16- or 32-bit data word from the Local CPU system address\n//!\n//! \\param ulFlag specifies Remote to Local IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulStatusFlag indicates the Remote to Local Flag number mask used to\n//! report the status of the command sent back from the control  system.\n//!\n//! This function will allow the Remote CPU system to read 16/32-bit data from\n//! the Local CPU system. The \\e ulFlag parameter accepts any one of the\n//! flag values \\b IPC_FLAG1 - \\b IPC_FLAG32, and the \\e ulStatusFlag parameter\n//! accepts any other one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32 and\n//! \\b NO_FLAG.\n//\n//*****************************************************************************\nvoid\nIPCLiteRtoLDataRead(uint32_t ulFlag, uint32_t ulStatusFlag)\n{\n\n    uint32_t* pulRAddress;\n    uint16_t* pusRAddress;\n\n    //\n    // Wait until IPC Remote to Local request task is flagged\n    //\n    while (!(IpcRegs.IPCSTS.all & ulFlag))\n    {\n    }\n\n    //\n    // If the command and data length are correct for this function:\n    // Then read from requested address and write 16/32-bit data\n    // to IPCLOCALREPLY. Acknowledge the status flag\n    // and the task flag.\n    //\n    if (IpcRegs.IPCRECVCOM == IPC_DATA_READ_16)\n    {\n        //\n        // Perform 16-bit read.\n        //\n        pusRAddress = (uint16_t *)IpcRegs.IPCRECVADDR;\n        IpcRegs.IPCLOCALREPLY = (uint32_t)(*pusRAddress);\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n    else if (IpcRegs.IPCRECVCOM == IPC_DATA_READ_32)\n    {\n        pulRAddress = (uint32_t *)IpcRegs.IPCRECVADDR;\n        IpcRegs.IPCLOCALREPLY = *pulRAddress;\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n\n    //\n    // Otherwise, only acknowledge the task flag.\n    //(Indicates to Remote CPU there was an error)\n    //\n    else\n    {\n        IpcRegs.IPCACK.all = (ulFlag);\n    }\n}\n\n//*****************************************************************************\n//\n//! Sets the designated bits in a 16/32-bit data word at the Local CPU system\n//! address\n//!\n//! \\param ulFlag specifies Remote to Local IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulStatusFlag indicates the Remote to Local Flag number mask used to\n//! report the status of the command sent back from the control system.\n//!\n//! This function will allow the Remote CPU system to set bits specified by a\n//! mask variable in a 16/32-bit word on the Local CPU system, and then read\n//! back the word into the IPCLOCALREPLY register. The \\e ulFlag parameter\n//! accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32, and the\n//! \\e ulStatusFlag parameter accepts any other one of the flag values \\b\n//! IPC_FLAG1 - \\b IPC_FLAG32 and \\b NO_FLAG.\n//\n//*****************************************************************************\nvoid\nIPCLiteRtoLSetBits(uint32_t ulFlag, uint32_t ulStatusFlag)\n{\n\n    uint16_t* pusAddress;\n    uint32_t* pulAddress;\n\n    //\n    // Wait until IPC Remote to Local request task is flagged\n    //\n    while (!(IpcRegs.IPCSTS.all & ulFlag))\n    {\n    }\n\n    //\n    // If the command is correct for this function:\n    // Then set the mask bits at the requested address\n    // and write back the 16/32-bit data to IPCLOCALREPLY.\n    // Acknowledge the status flag and the task flag.\n    //\n    if (IpcRegs.IPCRECVCOM == IPC_SET_BITS_16)\n    {\n        pusAddress = (uint16_t *)IpcRegs.IPCRECVADDR;;\n        *pusAddress |= (uint16_t)IpcRegs.IPCRECVDATA;\n        IpcRegs.IPCLOCALREPLY = (uint32_t)*pusAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n    else if (IpcRegs.IPCRECVCOM == IPC_SET_BITS_32)\n    {\n        pulAddress = (uint32_t *)IpcRegs.IPCRECVADDR;;\n        *pulAddress |= (uint32_t)IpcRegs.IPCRECVDATA;\n        IpcRegs.IPCLOCALREPLY = *pulAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n\n    //\n    // Otherwise, only acknowledge the task flag.\n    // (Indicates to Remote CPU there was an error)\n    //\n    else\n    {\n        IpcRegs.IPCACK.all = (ulFlag);\n    }\n}\n\n//*****************************************************************************\n//\n//! Sets the designated bits in a 16-bit data word at the Local CPU system\n//! write-protected address\n//!\n//! \\param ulFlag specifies Remote to Local IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulStatusFlag indicates the Remote to Local Flag number mask used to\n//! report the status of the command sent back from the control system.\n//!\n//! This function will allow the Remote CPU system to set bits specified by a\n//! mask variable in a write-protected 16/32-bit word on the Local CPU system,\n//! and then read back the word into the IPCLOCALREPLY register. The \\e ulFlag\n//! parameter accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32,\n//! and the \\e ulStatusFlag parameter accepts any other one of the flag values\n//! \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b NO_FLAG.\n//\n//*****************************************************************************\nvoid\nIPCLiteRtoLSetBits_Protected (uint32_t ulFlag, uint32_t ulStatusFlag)\n{\n\n    uint16_t* pusAddress;\n    uint32_t* pulAddress;\n\n    //\n    // Wait until IPC Remote to Local request task is flagged\n    //\n    while (!(IpcRegs.IPCSTS.all & ulFlag))\n    {\n    }\n\n    //\n    // If the command is correct for this function:\n    // Then enable write access with EALLOW and\n    // set the mask bits at the requested address.\n    // Write back the 16-bit data to IPCLOCALREPLY.\n    // Restore write-protection with EDIS.\n    // Acknowledge the status flag and the task flag.\n    //\n\n    EALLOW;\n\n    if (IpcRegs.IPCRECVCOM == IPC_SET_BITS_16_PROTECTED)\n    {\n        pusAddress = (uint16_t *)IpcRegs.IPCRECVADDR;\n        *pusAddress |= (uint16_t)IpcRegs.IPCRECVDATA;\n        IpcRegs.IPCLOCALREPLY = (uint32_t)*pusAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n    else if (IpcRegs.IPCRECVCOM == IPC_SET_BITS_32_PROTECTED)\n    {\n        pulAddress = (uint32_t *)IpcRegs.IPCRECVADDR;\n        *pulAddress |= (uint32_t)IpcRegs.IPCRECVDATA;\n        IpcRegs.IPCLOCALREPLY = *pulAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n\n    //\n    // Otherwise, only acknowledge the task flag.\n    //(Indicates to the Remote CPU there was an error)\n    //\n    else\n    {\n        IpcRegs.IPCACK.all = (ulFlag);\n    }\n\n    EDIS;\n}\n\n//*****************************************************************************\n//\n//! Clears the designated bits in a 16/32-bit data word at Local CPU system\n//! address\n//!\n//! \\param ulFlag specifies Remote to Local IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulStatusFlag indicates the Remote to Local Flag number mask used to\n//! report the status of the command sent back from the control system.\n//!\n//! This function will allow the Remote CPU system to clear bits specified by a\n//! mask variable in a 16/32-bit word on the Local CPU system, and then read\n//! back the word into the IPCLOCALREPLY register. The \\e ulFlag\n//! parameter accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32,\n//! and the \\e ulStatusFlag parameter accepts any other one of the flag values\n//! \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b NO_FLAG.\n//\n//*****************************************************************************\nvoid\nIPCLiteRtoLClearBits(uint32_t ulFlag, uint32_t ulStatusFlag)\n{\n    uint16_t* pusAddress;\n    uint32_t* pulAddress;\n\n    //\n    // Wait until IPC Remote to Local request task is flagged\n    //\n    while (!(IpcRegs.IPCSTS.all & ulFlag))\n    {\n    }\n\n    //\n    // If the command is correct for this function:\n    // Then clear the mask bits at the requested address\n    // and write back the 16/32-bit data to IPCLOCALREPLY.\n    // Acknowledge the status flag and the task flag.\n    //\n    if (IpcRegs.IPCRECVCOM == IPC_CLEAR_BITS_16)\n    {\n        pusAddress = (uint16_t *)IpcRegs.IPCRECVADDR;;\n        *pusAddress &= ~((uint16_t)IpcRegs.IPCRECVDATA);\n        IpcRegs.IPCLOCALREPLY = (uint32_t)*pusAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n    else if (IpcRegs.IPCRECVCOM == IPC_CLEAR_BITS_32)\n    {\n        pulAddress = (uint32_t *)IpcRegs.IPCRECVADDR;\n        *pulAddress &= ~((uint32_t)IpcRegs.IPCRECVDATA);\n        IpcRegs.IPCLOCALREPLY = *pulAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n\n    //\n    // Otherwise, only acknowledge the task flag.\n    // (Indicates to Remote CPU there was an error)\n    //\n    else\n    {\n        IpcRegs.IPCACK.all = (ulFlag);\n    }\n}\n\n//*****************************************************************************\n//\n//! Clears the designated bits in a 16/32-bit data word at the Local CPU system\n//! write-protected address\n//!\n//! \\param ulFlag specifies Remote to Local IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulStatusFlag indicates the Remote to Local Flag number mask used to\n//! report the status of the command sent back from the control system.\n//!\n//! This function will allow the Remote CPU system to clear bits specified by a\n//! mask variable in a 16/32-bit word on the Local CPU system, and then read\n//! back the word into the IPCLOCALREPLY register. The \\e ulFlag\n//! parameter accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32,\n//! and the \\e ulStatusFlag parameter accepts any other one of the flag values\n//! \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b NO_FLAG.\n//\n//*****************************************************************************\nvoid\nIPCLiteRtoLClearBits_Protected (uint32_t ulFlag, uint32_t ulStatusFlag)\n{\n    uint16_t* pusAddress;\n    uint32_t* pulAddress;\n\n    //\n    // Wait until IPC Remote to Local request task is flagged\n    //\n    while (!(IpcRegs.IPCSTS.all & ulFlag))\n    {\n    }\n\n    //\n    // If the command is correct for this function:\n    // Then enable write access with EALLOW and\n    // clear the mask bits at the requested address.\n    // Write back the 16/32-bit data to IPCLOCALREPLY.\n    // Restore the status of the EALLOW register.\n    // Acknowledge the status flag and the task flag.\n    //\n    EALLOW;\n\n    if (IpcRegs.IPCRECVCOM == IPC_CLEAR_BITS_16_PROTECTED)\n    {\n\n        pusAddress = (uint16_t *)IpcRegs.IPCRECVADDR;;\n        *pusAddress &= ~((uint16_t)IpcRegs.IPCRECVDATA);\n        IpcRegs.IPCLOCALREPLY = (uint32_t)*pusAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n    else if (IpcRegs.IPCRECVCOM == IPC_CLEAR_BITS_32_PROTECTED)\n    {\n\n        pulAddress = (uint32_t *)IpcRegs.IPCRECVADDR;;\n        *pulAddress &= ~((uint32_t)IpcRegs.IPCRECVDATA);\n        IpcRegs.IPCLOCALREPLY = (uint32_t)*pulAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n\n    //\n    // Otherwise, only acknowledge the task flag.\n    // (Indicates to Remote CPU there was an error)\n    //\n    else\n    {\n        IpcRegs.IPCACK.all = (ulFlag);\n    }\n\n    EDIS;\n}\n\n//*****************************************************************************\n//\n//! Writes a 16/32-bit data word to Local CPU system address\n//!\n//! \\param ulFlag specifies Remote to Local IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulStatusFlag indicates the Remote to Local Flag number mask used to\n//! report the status of the command sent back from the control system.\n//!\n//! This function will allow the Remote CPU system to write a 16/32-bit word\n//! to an address on the Local CPU system. The \\e ulFlag\n//! parameter accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32,\n//! and the \\e ulStatusFlag parameter accepts any other one of the flag values\n//! \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b NO_FLAG.\n//\n//*****************************************************************************\nvoid\nIPCLiteRtoLDataWrite(uint32_t ulFlag, uint32_t ulStatusFlag)\n{\n    uint32_t* pulAddress;\n    uint16_t* pusAddress;\n\n    //\n    // Wait until IPC Remote to Local request task is flagged\n    //\n    while (!(IpcRegs.IPCSTS.all & ulFlag))\n    {\n    }\n\n    //\n    // If the command is correct for this function:\n    // Then write the 16/32-bit data to the requested address\n    // and write back the 16/32-bit data to IPCLOCALREPLY.\n    // Acknowledge the status flag and the task flag.\n    //\n    if (IpcRegs.IPCRECVCOM == IPC_DATA_WRITE_16)\n    {\n        pusAddress = (uint16_t *)IpcRegs.IPCRECVADDR;;\n        *pusAddress = (uint16_t)IpcRegs.IPCRECVDATA;\n        IpcRegs.IPCLOCALREPLY = (uint32_t)*pusAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n    else if (IpcRegs.IPCRECVCOM == IPC_DATA_WRITE_32)\n    {\n        pulAddress = (uint32_t *)IpcRegs.IPCRECVADDR;;\n        *pulAddress = IpcRegs.IPCRECVDATA;\n        IpcRegs.IPCLOCALREPLY = *pulAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n\n    }\n\n    //\n    // Otherwise, only acknowledge the task flag.\n    // (Indicates to Remote CPU there was an error)\n    //\n    else\n    {\n        IpcRegs.IPCACK.all = (ulFlag);\n    }\n}\n\n//*****************************************************************************\n//\n//! Writes a 16/32-bit data word to a write-protected Local CPU system address\n//!\n//! \\param ulFlag specifies Remote to Local IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulStatusFlag indicates the Remote to Local Flag number mask used to\n//! report the status of the command sent back from the control system.\n//!\n//! This function will allow the Remote CPU system to write a 16/32-bit word\n//! to an address on the Local CPU system. The \\e ulFlag\n//! parameter accepts any one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32,\n//! and the \\e ulStatusFlag parameter accepts any other one of the flag values\n//! \\b IPC_FLAG1 - \\b IPC_FLAG32 and \\b NO_FLAG.\n//\n//*****************************************************************************\nvoid\nIPCLiteRtoLDataWrite_Protected(uint32_t ulFlag, uint32_t ulStatusFlag)\n{\n    uint32_t* pulAddress;\n    uint16_t* pusAddress;\n\n    //\n    // Wait until IPC Remote to Local request task is flagged\n    //\n    while (!(IpcRegs.IPCSTS.all & ulFlag))\n    {\n    }\n\n    //\n    // If the command is correct for this function:\n    // Then enable write access with EALLOW and\n    // write the 16/32-bit data to the requested address\n    // and write back the 16/32-bit data to IPCLOCALREPLY.\n    // Acknowledge the status flag and the task flag.\n    //\n    EALLOW;\n\n    if (IpcRegs.IPCRECVCOM == IPC_DATA_WRITE_16_PROTECTED)\n    {\n        pusAddress = (uint16_t *)IpcRegs.IPCRECVADDR;;\n        *pusAddress = (uint16_t)IpcRegs.IPCRECVDATA;\n        IpcRegs.IPCLOCALREPLY = (uint32_t)*pusAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n    else if (IpcRegs.IPCRECVCOM == IPC_DATA_WRITE_32_PROTECTED)\n    {\n        pulAddress = (uint32_t *)IpcRegs.IPCRECVADDR;\n        *pulAddress = IpcRegs.IPCRECVDATA;\n        IpcRegs.IPCLOCALREPLY = *pulAddress;\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n\n    }\n\n    //\n    // Otherwise, only acknowledge the task flag.\n    // (Indicates to Remote CPU there was an error)\n    //\n    else\n    {\n        IpcRegs.IPCACK.all = (ulFlag);\n    }\n\n    //\n    // Restore write-protection status.\n    //\n    EDIS;\n}\n\n//*****************************************************************************\n//\n//! Calls a Local CPU function with a single optional parameter and return\n//! value.\n//!\n//! \\param ulFlag specifies Remote to Local IPC Flag number mask used to\n//! indicate a command is being sent.\n//! \\param ulStatusFlag indicates the Remote to Local Flag number mask used to\n//! report the status of the command sent back from the control system.\n//!\n//! This function will allow the Remote CPU system to call a Local CPU function\n//! with a single optional parameter and places an optional return value in the\n//! IPCLOCALREPLY register. The \\e ulFlag parameter accepts any one of the flag\n//! values \\b IPC_FLAG1 - \\b IPC_FLAG32, and  the \\e ulStatusFlag parameter\n//! accepts any other one of the flag values \\b IPC_FLAG1 - \\b IPC_FLAG32 and\n//! \\b NO_FLAG.\n//\n//*****************************************************************************\nvoid\nIPCLiteRtoLFunctionCall(uint32_t ulFlag, uint32_t ulStatusFlag)\n{\n    //\n    // Wait until IPC Remote to Local request task is flagged\n    //\n    while (!(IpcRegs.IPCSTS.all & ulFlag))\n    {\n    }\n\n    //\n    // If the command is correct for this function:\n    // Then call function at requested address\n    // and if there is a return value, insert into\n    // IPCLOCALREPLY register.\n    // Acknowledge the status flag and the task flag.\n    //\n    if (IpcRegs.IPCRECVCOM == IPC_FUNC_CALL)\n    {\n        tfIpcFuncCall func_call = (tfIpcFuncCall)IpcRegs.IPCRECVADDR;\n        IpcRegs.IPCLOCALREPLY = func_call(IpcRegs.IPCRECVDATA);\n\n        IpcRegs.IPCACK.all = (ulStatusFlag | ulFlag);\n    }\n\n    //\n    // Otherwise, only acknowledge the task flag.\n    //(Indicates to Remote CPU there was an error)\n    //\n    else\n    {\n        IpcRegs.IPCACK.all = (ulFlag);\n    }\n}\n\nvoid DelayLoop (void)\n{\n    __asm(\" nop\");\n    __asm(\" nop\");\n    __asm(\" nop\");\n    __asm(\" nop\");\n    __asm(\" nop\");\n}\n\n//*****************************************************************************\n// Close the Doxygen group.\n//! @}\n//*****************************************************************************\n\n\n"},{"name":"F2837xD_PieCtrl.c","type":"source","group":"legacy","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_02_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:\tF2837xD_PieCtrl.c\n//\n// TITLE:\tF2837xD Device PIE Control Register Initialization Functions.\n//\n//###########################################################################\n//\n// $Release Date:  $\n// $Copyright:\n// Copyright (C) 2013-2024 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"F2837xD_device.h\"     // F2837xD Headerfile Include File\n#include \"F2837xD_Examples.h\"   // F2837xD Examples Include File\n\n//\n// InitPieCtrl - This function initializes the PIE control registers to a\n//               known state.\n//\nvoid InitPieCtrl(void)\n{\n    //\n    // Disable Interrupts at the CPU level:\n    //\n    DINT;\n\n    //\n    // Disable the PIE\n    //\n    PieCtrlRegs.PIECTRL.bit.ENPIE = 0;\n\n\t//\n    // Clear all PIEIER registers:\n    //\n\tPieCtrlRegs.PIEIER1.all = 0;\n\tPieCtrlRegs.PIEIER2.all = 0;\n\tPieCtrlRegs.PIEIER3.all = 0;\n\tPieCtrlRegs.PIEIER4.all = 0;\n\tPieCtrlRegs.PIEIER5.all = 0;\n\tPieCtrlRegs.PIEIER6.all = 0;\n\tPieCtrlRegs.PIEIER7.all = 0;\n\tPieCtrlRegs.PIEIER8.all = 0;\n\tPieCtrlRegs.PIEIER9.all = 0;\n\tPieCtrlRegs.PIEIER10.all = 0;\n\tPieCtrlRegs.PIEIER11.all = 0;\n\tPieCtrlRegs.PIEIER12.all = 0;\n\n\t//\n    // Clear all PIEIFR registers:\n    //\n\tPieCtrlRegs.PIEIFR1.all = 0;\n\tPieCtrlRegs.PIEIFR2.all = 0;\n\tPieCtrlRegs.PIEIFR3.all = 0;\n\tPieCtrlRegs.PIEIFR4.all = 0;\n\tPieCtrlRegs.PIEIFR5.all = 0;\n\tPieCtrlRegs.PIEIFR6.all = 0;\n\tPieCtrlRegs.PIEIFR7.all = 0;\n\tPieCtrlRegs.PIEIFR8.all = 0;\n\tPieCtrlRegs.PIEIFR9.all = 0;\n\tPieCtrlRegs.PIEIFR10.all = 0;\n\tPieCtrlRegs.PIEIFR11.all = 0;\n\tPieCtrlRegs.PIEIFR12.all = 0;\n}\n\n//\n// EnableInterrupts - This function enables the PIE module and CPU __interrupts\n//\nvoid EnableInterrupts()\n{\n    //\n    // Enable the PIE\n    //\n    PieCtrlRegs.PIECTRL.bit.ENPIE = 1;\n\n\t//\n    // Enables PIE to drive a pulse into the CPU\n    //\n\tPieCtrlRegs.PIEACK.all = 0xFFFF;\n\n\t//\n    // Enable Interrupts at the CPU level\n    //\n    EINT;\n}\n\n//\n// End of file\n//\n"},{"name":"F2837xD_PieVect.c","type":"source","group":"legacy","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_02_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   F2837xD_PieVect.c\n//\n// TITLE:  F2837xD Device PIE Vector Initialization Functions\n//\n//###########################################################################\n//   $\n// $Release Date:   $\n// $Copyright:\n// Copyright (C) 2013-2024 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"F2837xD_device.h\"\n#include \"F2837xD_Examples.h\"\n\n//\n// Globals\n//\nconst struct PIE_VECT_TABLE PieVectTableInit = {\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    PIE_RESERVED_ISR,             // Reserved\n    TIMER1_ISR,                   // CPU Timer 1 Interrupt\n    TIMER2_ISR,                   // CPU Timer 2 Interrupt\n    DATALOG_ISR,                  // Datalogging Interrupt\n    RTOS_ISR,                     // RTOS Interrupt\n    EMU_ISR,                      // Emulation Interrupt\n    NMI_ISR,                      // Non-Maskable Interrupt\n    ILLEGAL_ISR,                  // Illegal Operation Trap\n    USER1_ISR,                    // User Defined Trap 1\n    USER2_ISR,                    // User Defined Trap 2\n    USER3_ISR,                    // User Defined Trap 3\n    USER4_ISR,                    // User Defined Trap 4\n    USER5_ISR,                    // User Defined Trap 5\n    USER6_ISR,                    // User Defined Trap 6\n    USER7_ISR,                    // User Defined Trap 7\n    USER8_ISR,                    // User Defined Trap 8\n    USER9_ISR,                    // User Defined Trap 9\n    USER10_ISR,                   // User Defined Trap 10\n    USER11_ISR,                   // User Defined Trap 11\n    USER12_ISR,                   // User Defined Trap 12\n    ADCA1_ISR,                    // 1.1 - ADCA Interrupt 1\n    ADCB1_ISR,                    // 1.2 - ADCB Interrupt 1\n    ADCC1_ISR,                    // 1.3 - ADCC Interrupt 1\n    XINT1_ISR,                    // 1.4 - XINT1 Interrupt\n    XINT2_ISR,                    // 1.5 - XINT2 Interrupt\n    ADCD1_ISR,                    // 1.6 - ADCD Interrupt 1\n    TIMER0_ISR,                   // 1.7 - Timer 0 Interrupt\n    WAKE_ISR,                     // 1.8 - Standby and Halt Wakeup Interrupt\n    EPWM1_TZ_ISR,                 // 2.1 - ePWM1 Trip Zone Interrupt\n    EPWM2_TZ_ISR,                 // 2.2 - ePWM2 Trip Zone Interrupt\n    EPWM3_TZ_ISR,                 // 2.3 - ePWM3 Trip Zone Interrupt\n    EPWM4_TZ_ISR,                 // 2.4 - ePWM4 Trip Zone Interrupt\n    EPWM5_TZ_ISR,                 // 2.5 - ePWM5 Trip Zone Interrupt\n    EPWM6_TZ_ISR,                 // 2.6 - ePWM6 Trip Zone Interrupt\n    EPWM7_TZ_ISR,                 // 2.7 - ePWM7 Trip Zone Interrupt\n    EPWM8_TZ_ISR,                 // 2.8 - ePWM8 Trip Zone Interrupt\n    EPWM1_ISR,                    // 3.1 - ePWM1 Interrupt\n    EPWM2_ISR,                    // 3.2 - ePWM2 Interrupt\n    EPWM3_ISR,                    // 3.3 - ePWM3 Interrupt\n    EPWM4_ISR,                    // 3.4 - ePWM4 Interrupt\n    EPWM5_ISR,                    // 3.5 - ePWM5 Interrupt\n    EPWM6_ISR,                    // 3.6 - ePWM6 Interrupt\n    EPWM7_ISR,                    // 3.7 - ePWM7 Interrupt\n    EPWM8_ISR,                    // 3.8 - ePWM8 Interrupt\n    ECAP1_ISR,                    // 4.1 - eCAP1 Interrupt\n    ECAP2_ISR,                    // 4.2 - eCAP2 Interrupt\n    ECAP3_ISR,                    // 4.3 - eCAP3 Interrupt\n    ECAP4_ISR,                    // 4.4 - eCAP4 Interrupt\n    ECAP5_ISR,                    // 4.5 - eCAP5 Interrupt\n    ECAP6_ISR,                    // 4.6 - eCAP6 Interrupt\n    PIE_RESERVED_ISR,             // 4.7 - Reserved\n    PIE_RESERVED_ISR,             // 4.8 - Reserved\n    EQEP1_ISR,                    // 5.1 - eQEP1 Interrupt\n    EQEP2_ISR,                    // 5.2 - eQEP2 Interrupt\n    EQEP3_ISR,                    // 5.3 - eQEP3 Interrupt\n    PIE_RESERVED_ISR,             // 5.4 - Reserved\n    PIE_RESERVED_ISR,             // 5.5 - Reserved\n    PIE_RESERVED_ISR,             // 5.6 - Reserved\n    PIE_RESERVED_ISR,             // 5.7 - Reserved\n    PIE_RESERVED_ISR,             // 5.8 - Reserved\n    SPIA_RX_ISR,                  // 6.1 - SPIA Receive Interrupt\n    SPIA_TX_ISR,                  // 6.2 - SPIA Transmit Interrupt\n    SPIB_RX_ISR,                  // 6.3 - SPIB Receive Interrupt\n    SPIB_TX_ISR,                  // 6.4 - SPIB Transmit Interrupt\n    MCBSPA_RX_ISR,                // 6.5 - McBSPA Receive Interrupt\n    MCBSPA_TX_ISR,                // 6.6 - McBSPA Transmit Interrupt\n    MCBSPB_RX_ISR,                // 6.7 - McBSPB Receive Interrupt\n    MCBSPB_TX_ISR,                // 6.8 - McBSPB Transmit Interrupt\n    DMA_CH1_ISR,                  // 7.1 - DMA Channel 1 Interrupt\n    DMA_CH2_ISR,                  // 7.2 - DMA Channel 2 Interrupt\n    DMA_CH3_ISR,                  // 7.3 - DMA Channel 3 Interrupt\n    DMA_CH4_ISR,                  // 7.4 - DMA Channel 4 Interrupt\n    DMA_CH5_ISR,                  // 7.5 - DMA Channel 5 Interrupt\n    DMA_CH6_ISR,                  // 7.6 - DMA Channel 6 Interrupt\n    PIE_RESERVED_ISR,             // 7.7 - Reserved\n    PIE_RESERVED_ISR,             // 7.8 - Reserved\n    I2CA_ISR,                     // 8.1 - I2CA Interrupt 1\n    I2CA_FIFO_ISR,                // 8.2 - I2CA Interrupt 2\n    I2CB_ISR,                     // 8.3 - I2CB Interrupt 1\n    I2CB_FIFO_ISR,                // 8.4 - I2CB Interrupt 2\n    SCIC_RX_ISR,                  // 8.5 - SCIC Receive Interrupt\n    SCIC_TX_ISR,                  // 8.6 - SCIC Transmit Interrupt\n    SCID_RX_ISR,                  // 8.7 - SCID Receive Interrupt\n    SCID_TX_ISR,                  // 8.8 - SCID Transmit Interrupt\n    SCIA_RX_ISR,                  // 9.1 - SCIA Receive Interrupt\n    SCIA_TX_ISR,                  // 9.2 - SCIA Transmit Interrupt\n    SCIB_RX_ISR,                  // 9.3 - SCIB Receive Interrupt\n    SCIB_TX_ISR,                  // 9.4 - SCIB Transmit Interrupt\n    CANA0_ISR,                    // 9.5 - CANA Interrupt 0\n    CANA1_ISR,                    // 9.6 - CANA Interrupt 1\n    CANB0_ISR,                    // 9.7 - CANB Interrupt 0\n    CANB1_ISR,                    // 9.8 - CANB Interrupt 1\n    ADCA_EVT_ISR,                 // 10.1 - ADCA Event Interrupt\n    ADCA2_ISR,                    // 10.2 - ADCA Interrupt 2\n    ADCA3_ISR,                    // 10.3 - ADCA Interrupt 3\n    ADCA4_ISR,                    // 10.4 - ADCA Interrupt 4\n    ADCB_EVT_ISR,                 // 10.5 - ADCB Event Interrupt\n    ADCB2_ISR,                    // 10.6 - ADCB Interrupt 2\n    ADCB3_ISR,                    // 10.7 - ADCB Interrupt 3\n    ADCB4_ISR,                    // 10.8 - ADCB Interrupt 4\n    CLA1_1_ISR,                   // 11.1 - CLA1 Interrupt 1\n    CLA1_2_ISR,                   // 11.2 - CLA1 Interrupt 2\n    CLA1_3_ISR,                   // 11.3 - CLA1 Interrupt 3\n    CLA1_4_ISR,                   // 11.4 - CLA1 Interrupt 4\n    CLA1_5_ISR,                   // 11.5 - CLA1 Interrupt 5\n    CLA1_6_ISR,                   // 11.6 - CLA1 Interrupt 6\n    CLA1_7_ISR,                   // 11.7 - CLA1 Interrupt 7\n    CLA1_8_ISR,                   // 11.8 - CLA1 Interrupt 8\n    XINT3_ISR,                    // 12.1 - XINT3 Interrupt\n    XINT4_ISR,                    // 12.2 - XINT4 Interrupt\n    XINT5_ISR,                    // 12.3 - XINT5 Interrupt\n    PIE_RESERVED_ISR,             // 12.4 - Reserved\n    PIE_RESERVED_ISR,             // 12.5 - Reserved\n    VCU_ISR,                      // 12.6 - VCU Interrupt\n    FPU_OVERFLOW_ISR,             // 12.7 - FPU Overflow Interrupt\n    FPU_UNDERFLOW_ISR,            // 12.8 - FPU Underflow Interrupt\n    PIE_RESERVED_ISR,             // 1.9 - Reserved\n    PIE_RESERVED_ISR,             // 1.10 - Reserved\n    PIE_RESERVED_ISR,             // 1.11 - Reserved\n    PIE_RESERVED_ISR,             // 1.12 - Reserved\n    IPC0_ISR,                     // 1.13 - IPC Interrupt 0\n    IPC1_ISR,                     // 1.14 - IPC Interrupt 1\n    IPC2_ISR,                     // 1.15 - IPC Interrupt 2\n    IPC3_ISR,                     // 1.16 - IPC Interrupt 3\n    EPWM9_TZ_ISR,                 // 2.9 - ePWM9 Trip Zone Interrupt\n    EPWM10_TZ_ISR,                // 2.10 - ePWM10 Trip Zone Interrupt\n    EPWM11_TZ_ISR,                // 2.11 - ePWM11 Trip Zone Interrupt\n    EPWM12_TZ_ISR,                // 2.12 - ePWM12 Trip Zone Interrupt\n    PIE_RESERVED_ISR,             // 2.13 - Reserved\n    PIE_RESERVED_ISR,             // 2.14 - Reserved\n    PIE_RESERVED_ISR,             // 2.15 - Reserved\n    PIE_RESERVED_ISR,             // 2.16 - Reserved\n    EPWM9_ISR,                    // 3.9 - ePWM9 Interrupt\n    EPWM10_ISR,                   // 3.10 - ePWM10 Interrupt\n    EPWM11_ISR,                   // 3.11 - ePWM11 Interrupt\n    EPWM12_ISR,                   // 3.12 - ePWM12 Interrupt\n    PIE_RESERVED_ISR,             // 3.13 - Reserved\n    PIE_RESERVED_ISR,             // 3.14 - Reserved\n    PIE_RESERVED_ISR,             // 3.15 - Reserved\n    PIE_RESERVED_ISR,             // 3.16 - Reserved\n    PIE_RESERVED_ISR,             // 4.9 - Reserved\n    PIE_RESERVED_ISR,             // 4.10 - Reserved\n    PIE_RESERVED_ISR,             // 4.11 - Reserved\n    PIE_RESERVED_ISR,             // 4.12 - Reserved\n    PIE_RESERVED_ISR,             // 4.13 - Reserved\n    PIE_RESERVED_ISR,             // 4.14 - Reserved\n    PIE_RESERVED_ISR,             // 4.15 - Reserved\n    PIE_RESERVED_ISR,             // 4.16 - Reserved\n    SD1_ISR,                      // 5.9 - SD1 Interrupt\n    SD2_ISR,                      // 5.10 - SD2 Interrupt\n    PIE_RESERVED_ISR,             // 5.11 - Reserved\n    PIE_RESERVED_ISR,             // 5.12 - Reserved\n    PIE_RESERVED_ISR,             // 5.13 - Reserved\n    PIE_RESERVED_ISR,             // 5.14 - Reserved\n    PIE_RESERVED_ISR,             // 5.15 - Reserved\n    PIE_RESERVED_ISR,             // 5.16 - Reserved\n    SPIC_RX_ISR,                  // 6.9 - SPIC Receive Interrupt\n    SPIC_TX_ISR,                  // 6.10 - SPIC Transmit Interrupt\n    PIE_RESERVED_ISR,             // 6.11 - Reserved\n    PIE_RESERVED_ISR,             // 6.12 - Reserved\n    PIE_RESERVED_ISR,             // 6.13 - Reserved\n    PIE_RESERVED_ISR,             // 6.14 - Reserved\n    PIE_RESERVED_ISR,             // 6.15 - Reserved\n    PIE_RESERVED_ISR,             // 6.16 - Reserved\n    PIE_RESERVED_ISR,             // 7.9 - Reserved\n    PIE_RESERVED_ISR,             // 7.10 - Reserved\n    PIE_RESERVED_ISR,             // 7.11 - Reserved\n    PIE_RESERVED_ISR,             // 7.12 - Reserved\n    PIE_RESERVED_ISR,             // 7.13 - Reserved\n    PIE_RESERVED_ISR,             // 7.14 - Reserved\n    PIE_RESERVED_ISR,             // 7.15 - Reserved\n    PIE_RESERVED_ISR,             // 7.16 - Reserved\n    PIE_RESERVED_ISR,             // 8.9 - Reserved\n    PIE_RESERVED_ISR,             // 8.10 - Reserved\n    PIE_RESERVED_ISR,             // 8.11 - Reserved\n    PIE_RESERVED_ISR,             // 8.12 - Reserved\n    PIE_RESERVED_ISR,             // 8.13 - Reserved\n    PIE_RESERVED_ISR,             // 8.14 - Reserved\n#ifdef CPU1    \n    UPPA_ISR,                     // 8.15 - uPPA Interrupt\n    PIE_RESERVED_ISR,             // 8.16 - Reserved\n#elif defined(CPU2)\n    PIE_RESERVED_ISR,             // 8.15 - Reserved\n    PIE_RESERVED_ISR,             // 8.16 - Reserved\n#endif    \n    PIE_RESERVED_ISR,             // 9.9 - Reserved\n    PIE_RESERVED_ISR,             // 9.10 - Reserved\n    PIE_RESERVED_ISR,             // 9.11 - Reserved\n    PIE_RESERVED_ISR,             // 9.12 - Reserved\n    PIE_RESERVED_ISR,             // 9.13 - Reserved\n    PIE_RESERVED_ISR,             // 9.14 - Reserved\n#ifdef CPU1    \n    USBA_ISR,                     // 9.15 - USBA Interrupt\n#elif defined(CPU2)\n    PIE_RESERVED_ISR,             // 9.15 - Reserved\n#endif    \n    PIE_RESERVED_ISR,             // 9.16 - Reserved\n    ADCC_EVT_ISR,                 // 10.9 - ADCC Event Interrupt\n    ADCC2_ISR,                    // 10.10 - ADCC Interrupt 2\n    ADCC3_ISR,                    // 10.11 - ADCC Interrupt 3\n    ADCC4_ISR,                    // 10.12 - ADCC Interrupt 4\n    ADCD_EVT_ISR,                 // 10.13 - ADCD Event Interrupt\n    ADCD2_ISR,                    // 10.14 - ADCD Interrupt 2\n    ADCD3_ISR,                    // 10.15 - ADCD Interrupt 3\n    ADCD4_ISR,                    // 10.16 - ADCD Interrupt 4\n    PIE_RESERVED_ISR,             // 11.9 - Reserved\n    PIE_RESERVED_ISR,             // 11.10 - Reserved\n    PIE_RESERVED_ISR,             // 11.11 - Reserved\n    PIE_RESERVED_ISR,             // 11.12 - Reserved\n    PIE_RESERVED_ISR,             // 11.13 - Reserved\n    PIE_RESERVED_ISR,             // 11.14 - Reserved\n    PIE_RESERVED_ISR,             // 11.15 - Reserved\n    PIE_RESERVED_ISR,             // 11.16 - Reserved\n    EMIF_ERROR_ISR,               // 12.9 - EMIF Error Interrupt\n    RAM_CORRECTABLE_ERROR_ISR,    // 12.10 - RAM Correctable Error Interrupt\n    FLASH_CORRECTABLE_ERROR_ISR,  // 12.11 - Flash Correctable Error Interrupt\n    RAM_ACCESS_VIOLATION_ISR,     // 12.12 - RAM Access Violation Interrupt\n    SYS_PLL_SLIP_ISR,             // 12.13 - System PLL Slip Interrupt\n    AUX_PLL_SLIP_ISR,             // 12.14 - Auxiliary PLL Slip Interrupt\n    CLA_OVERFLOW_ISR,             // 12.15 - CLA Overflow Interrupt\n    CLA_UNDERFLOW_ISR             // 12.16 - CLA Underflow Interrupt\n};\n\n//\n// InitPieVectTable - This function initializes the PIE vector table to a\n//                    known state and must be executed after boot time.\n//\nvoid InitPieVectTable(void)\n{\n    Uint16 i;\n    Uint32 *Source = (void *) &PieVectTableInit;\n    Uint32 *Dest = (void *) &PieVectTable;\n\n    //\n    // Do not write over first 3 32-bit locations (these locations are\n    // initialized by Boot ROM with boot variables)\n    //\n    Source = Source + 3;\n    Dest = Dest + 3;\n\n    EALLOW;\n    for(i = 0; i < 221; i++)\n    {\n    \t*Dest++ = *Source++;\n    }\n    EDIS;\n\n    //\n    // Enable the PIE Vector Table\n    //\n    PieCtrlRegs.PIECTRL.bit.ENPIE = 1;\n}\n\n//\n// End of file\n//\n"},{"name":"F2837xD_SysCtrl.c","type":"source","group":"legacy","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_02_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   F2837xD_SysCtrl.c\n//\n// TITLE:  F2837xD Device System Control Initialization & Support Functions.\n//\n// DESCRIPTION:\n//\n//         Example initialization of system resources.\n//\n//###########################################################################\n//\n// $Release Date:  $\n// $Copyright:\n// Copyright (C) 2013-2024 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"F2837xD_device.h\"\n#include \"F2837xD_Examples.h\"\n#ifdef __cplusplus\nusing std::memcpy;\n#endif\n\n#define STATUS_FAIL          0\n#define STATUS_SUCCESS       1\n#define TMR1SYSCLKCTR        0xF0000000\n#define TMR2INPCLKCTR        0x800\n\n//\n// Functions that will be run from RAM need to be assigned to a different\n// section.  This section will then be mapped to a load and run address using\n// the linker cmd file.\n//\n//      *IMPORTANT*\n//\n//  IF RUNNING FROM FLASH, PLEASE COPY OVER THE SECTION \".TI.ramfunc\" FROM\n//  FLASH TO RAM PRIOR TO CALLING InitSysCtrl(). THIS PREVENTS THE MCU FROM\n//  THROWING AN EXCEPTION WHEN A CALL TO DELAY_US() IS MADE.\n//\n#ifndef __cplusplus\n    #ifdef __TI_COMPILER_VERSION__\n        #if __TI_COMPILER_VERSION__ >= 15009000\n            #pragma CODE_SECTION(InitFlash, \".TI.ramfunc\");\n            #pragma CODE_SECTION(FlashOff, \".TI.ramfunc\");\n        #else\n            #pragma CODE_SECTION(InitFlash, \"ramfuncs\");\n            #pragma CODE_SECTION(FlashOff, \"ramfuncs\");\n        #endif\n    #endif\n#endif\n\n//\n// Macro used for adding delay between 2 consecutive writes to CLKSRCCTL1\n// register.\n// Delay = 300 NOPs\n//\n#define SYSCTRL_CLKSRCCTL1_DELAY  asm(\" RPT #250 || NOP \\n RPT #50 || NOP\")\n\n//\n// InitSysCtrl - Initialization of system resources.\n//\nvoid InitSysCtrl(void)\n{\n    //\n    // Disable the watchdog\n    //\n    DisableDog();\n\n#ifdef _FLASH\n    //\n    // Copy time critical code and Flash setup code to RAM. This includes the\n    // following functions: InitFlash()\n    //\n    // The  RamfuncsLoadStart, RamfuncsLoadSize, and RamfuncsRunStart\n    // symbols are created by the linker. Refer to the device .cmd file.\n    //\n    memcpy(&RamfuncsRunStart, &RamfuncsLoadStart, (size_t)&RamfuncsLoadSize);\n\n    //\n    // Call Flash Initialization to setup flash waitstates. This function must\n    // reside in RAM.\n    //\n    InitFlash();\n#endif\n\n    //\n    //      *IMPORTANT*\n    //\n    // The Device_cal function, which copies the ADC & oscillator calibration\n    // values from TI reserved OTP into the appropriate trim registers, occurs\n    // automatically in the Boot ROM. If the boot ROM code is bypassed during\n    // the debug process, the following function MUST be called for the ADC and\n    // oscillators to function according to specification. The clocks to the\n    // ADC MUST be enabled before calling this function.\n    //\n    // See the device data manual and/or the ADC Reference Manual for more\n    // information.\n    //\n#ifdef CPU1\n    EALLOW;\n\n    //\n    // Enable pull-ups on unbonded IOs as soon as possible to reduce power\n    // consumption.\n    //\n    GPIO_EnableUnbondedIOPullups();\n\n    //\n    // Check if the device is trimmed\n    //\n    if((DevCfgRegs.PARTIDL.bit.QUAL == 0x0) &&\n       (AnalogSubsysRegs.ANAREFTRIMA.all == 0x0))\n    {\n        ConfigureTMXAnalogTrim();\n    }\n\n    EDIS;\n\n    //\n    // Initialize the PLL control: SYSPLLMULT and SYSCLKDIVSEL.\n    //\n    // Defined options to be passed as arguments to this function are defined\n    // in F2837xD_Examples.h.\n    //\n    // Note: The internal oscillator CANNOT be used as the PLL source if the\n    // PLLSYSCLK is configured to frequencies above 194 MHz.\n    //\n    //  PLLSYSCLK = (XTAL_OSC) * (IMULT + FMULT) / (PLLSYSCLKDIV)\n    //\n#ifdef _LAUNCHXL_F28379D\n    InitSysPll(XTAL_OSC,IMULT_40,FMULT_0,PLLCLK_BY_2);\n#else\n    InitSysPll(XTAL_OSC, IMULT_20, FMULT_0, PLLCLK_BY_2);\n#endif // _LAUNCHXL_F28379D\n\n#ifndef _FLASH\n    //\n    // Call Device_cal function when run using debugger\n    // This function is called as part of the Boot code. The function is called\n    // in the InitSysCtrl function since during debug time resets, the boot code\n    // will not be executed and the gel script will reinitialize all the\n    // registers and the calibrated values will be lost.\n    //\n    Device_cal();\n#endif\n#endif // CPU1\n\n    //\n    // Turn on all peripherals\n    //\n    InitPeripheralClocks();\n}\n\n//\n// InitPeripheralClocks - Initializes the clocks for the peripherals.\n//\n// Note: In order to reduce power consumption, turn off the clocks to any\n// peripheral that is not specified for your part-number or is not used in the\n// application\n//\nvoid InitPeripheralClocks(void)\n{\n    EALLOW;\n\n    CpuSysRegs.PCLKCR0.bit.CLA1 = 1;\n    CpuSysRegs.PCLKCR0.bit.DMA = 1;\n    CpuSysRegs.PCLKCR0.bit.CPUTIMER0 = 1;\n    CpuSysRegs.PCLKCR0.bit.CPUTIMER1 = 1;\n    CpuSysRegs.PCLKCR0.bit.CPUTIMER2 = 1;\n\n#ifdef CPU1\n    CpuSysRegs.PCLKCR0.bit.HRPWM = 1;\n#endif\n\n    CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1;\n\n#ifdef CPU1\n    CpuSysRegs.PCLKCR1.bit.EMIF1 = 1;\n    CpuSysRegs.PCLKCR1.bit.EMIF2 = 1;\n#endif\n\n    CpuSysRegs.PCLKCR2.bit.EPWM1 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM2 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM3 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM4 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM5 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM6 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM7 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM8 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM9 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM10 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM11 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM12 = 1;\n\n    CpuSysRegs.PCLKCR3.bit.ECAP1 = 1;\n    CpuSysRegs.PCLKCR3.bit.ECAP2 = 1;\n    CpuSysRegs.PCLKCR3.bit.ECAP3 = 1;\n    CpuSysRegs.PCLKCR3.bit.ECAP4 = 1;\n    CpuSysRegs.PCLKCR3.bit.ECAP5 = 1;\n    CpuSysRegs.PCLKCR3.bit.ECAP6 = 1;\n\n    CpuSysRegs.PCLKCR4.bit.EQEP1 = 1;\n    CpuSysRegs.PCLKCR4.bit.EQEP2 = 1;\n    CpuSysRegs.PCLKCR4.bit.EQEP3 = 1;\n\n    CpuSysRegs.PCLKCR6.bit.SD1 = 1;\n    CpuSysRegs.PCLKCR6.bit.SD2 = 1;\n\n    CpuSysRegs.PCLKCR7.bit.SCI_A = 1;\n    CpuSysRegs.PCLKCR7.bit.SCI_B = 1;\n    CpuSysRegs.PCLKCR7.bit.SCI_C = 1;\n    CpuSysRegs.PCLKCR7.bit.SCI_D = 1;\n\n    CpuSysRegs.PCLKCR8.bit.SPI_A = 1;\n    CpuSysRegs.PCLKCR8.bit.SPI_B = 1;\n    CpuSysRegs.PCLKCR8.bit.SPI_C = 1;\n\n    CpuSysRegs.PCLKCR9.bit.I2C_A = 1;\n    CpuSysRegs.PCLKCR9.bit.I2C_B = 1;\n\n    CpuSysRegs.PCLKCR10.bit.CAN_A = 1;\n    CpuSysRegs.PCLKCR10.bit.CAN_B = 1;\n\n    CpuSysRegs.PCLKCR11.bit.McBSP_A = 1;\n    CpuSysRegs.PCLKCR11.bit.McBSP_B = 1;\n\n#ifdef CPU1\n    CpuSysRegs.PCLKCR11.bit.USB_A = 1;\n\n    CpuSysRegs.PCLKCR12.bit.uPP_A = 1;\n#endif\n\n    CpuSysRegs.PCLKCR13.bit.ADC_A = 1;\n    CpuSysRegs.PCLKCR13.bit.ADC_B = 1;\n    CpuSysRegs.PCLKCR13.bit.ADC_C = 1;\n    CpuSysRegs.PCLKCR13.bit.ADC_D = 1;\n\n    CpuSysRegs.PCLKCR14.bit.CMPSS1 = 1;\n    CpuSysRegs.PCLKCR14.bit.CMPSS2 = 1;\n    CpuSysRegs.PCLKCR14.bit.CMPSS3 = 1;\n    CpuSysRegs.PCLKCR14.bit.CMPSS4 = 1;\n    CpuSysRegs.PCLKCR14.bit.CMPSS5 = 1;\n    CpuSysRegs.PCLKCR14.bit.CMPSS6 = 1;\n    CpuSysRegs.PCLKCR14.bit.CMPSS7 = 1;\n    CpuSysRegs.PCLKCR14.bit.CMPSS8 = 1;\n\n    CpuSysRegs.PCLKCR16.bit.DAC_A = 1;\n    CpuSysRegs.PCLKCR16.bit.DAC_B = 1;\n    CpuSysRegs.PCLKCR16.bit.DAC_C = 1;\n\n    EDIS;\n}\n\n//\n// DisablePeripheralClocks - Gates-off all peripheral clocks.\n//\nvoid DisablePeripheralClocks(void)\n{\n    EALLOW;\n\n    CpuSysRegs.PCLKCR0.all = 0;\n    CpuSysRegs.PCLKCR1.all = 0;\n    CpuSysRegs.PCLKCR2.all = 0;\n    CpuSysRegs.PCLKCR3.all = 0;\n    CpuSysRegs.PCLKCR4.all = 0;\n    CpuSysRegs.PCLKCR6.all = 0;\n    CpuSysRegs.PCLKCR7.all = 0;\n    CpuSysRegs.PCLKCR8.all = 0;\n    CpuSysRegs.PCLKCR9.all = 0;\n    CpuSysRegs.PCLKCR10.all = 0;\n    CpuSysRegs.PCLKCR11.all = 0;\n    CpuSysRegs.PCLKCR12.all = 0;\n    CpuSysRegs.PCLKCR13.all = 0;\n    CpuSysRegs.PCLKCR14.all = 0;\n    CpuSysRegs.PCLKCR16.all = 0;\n\n    EDIS;\n}\n\n//\n// InitFlash - This function initializes the Flash Control registers.\n//\n//      *CAUTION*\n// This function MUST be executed out of RAM. Executing it out of OTP/Flash\n// will yield unpredictable results.\n//\n#ifdef __cplusplus\n    #ifdef __TI_COMPILER_VERSION__\n        #if __TI_COMPILER_VERSION__ >= 15009000\n            #pragma CODE_SECTION(\".TI.ramfunc\");\n        #else\n            #pragma CODE_SECTION(\"ramfuncs\");\n        #endif\n    #endif\n#endif\nvoid InitFlash(void)\n{\n    EALLOW;\n\n    //\n    // The default value of VREADST is good enough for the flash to power up\n    // properly at the INTOSC frequency. Below VREADST configuration covers up\n    // to the max frequency possible for this device. This is required for\n    // proper flash wake up at the higher frequencies if users put it to sleep\n    // for power saving reason.\n    //\n    Flash0CtrlRegs.FBAC.bit.VREADST = 0x14;\n\n    //\n    // At reset bank and pump are in sleep. A Flash access will power up the\n    // bank and pump automatically.\n    //\n    // Power up Flash bank and pump. This also sets the fall back mode of\n    // flash and pump as active.\n    //\n    Flash0CtrlRegs.FPAC1.bit.PMPPWR = 0x1;\n    Flash0CtrlRegs.FBFALLBACK.bit.BNKPWR0 = 0x3;\n\n    //\n    // Disable Cache and prefetch mechanism before changing wait states\n    //\n    Flash0CtrlRegs.FRD_INTF_CTRL.bit.DATA_CACHE_EN = 0;\n    Flash0CtrlRegs.FRD_INTF_CTRL.bit.PREFETCH_EN = 0;\n\n    //\n    // Set waitstates according to frequency\n    //\n    //      *CAUTION*\n    // Minimum waitstates required for the flash operating at a given CPU rate\n    // must be characterized by TI. Refer to the datasheet for the latest\n    // information.\n    //\n    #if CPU_FRQ_200MHZ\n    Flash0CtrlRegs.FRDCNTL.bit.RWAIT = 0x3;\n    #endif\n\n    #if CPU_FRQ_150MHZ\n    Flash0CtrlRegs.FRDCNTL.bit.RWAIT = 0x2;\n    #endif\n\n    #if CPU_FRQ_120MHZ\n    Flash0CtrlRegs.FRDCNTL.bit.RWAIT = 0x2;\n    #endif\n\n    //\n    // Enable Cache and prefetch mechanism to improve performance of code\n    // executed from Flash.\n    //\n    Flash0CtrlRegs.FRD_INTF_CTRL.bit.DATA_CACHE_EN = 1;\n    Flash0CtrlRegs.FRD_INTF_CTRL.bit.PREFETCH_EN = 1;\n\n    //\n    // At reset, ECC is enabled. If it is disabled by application software and\n    // if application again wants to enable ECC.\n    //\n    Flash0EccRegs.ECC_ENABLE.bit.ENABLE = 0xA;\n\n    EDIS;\n\n    //\n    // Force a pipeline flush to ensure that the write to the last register\n    // configured occurs before returning.\n    //\n    __asm(\" RPT #7 || NOP\");\n}\n\n//\n// FlashOff - This function powers down the flash\n//\n//      *CAUTION*\n// This function MUST be executed out of RAM. Executing it out of OTP/Flash\n// will yield unpredictable results. Also you must seize the flash pump in\n// order to power it down.\n//\n#ifdef __cplusplus\n    #ifdef __TI_COMPILER_VERSION__\n        #if __TI_COMPILER_VERSION__ >= 15009000\n            #pragma CODE_SECTION(\".TI.ramfunc\");\n        #else\n            #pragma CODE_SECTION(\"ramfuncs\");\n        #endif\n    #endif\n#endif\nvoid FlashOff(void)\n{\n    EALLOW;\n\n    //\n    // Set VREADST to the proper value for the flash banks to power up properly\n    //\n    Flash0CtrlRegs.FBAC.bit.VREADST = 0x14;\n\n    //\n    // Power down bank\n    //\n    Flash0CtrlRegs.FBFALLBACK.bit.BNKPWR0 = 0;\n\n    //\n    // Power down pump\n    //\n    Flash0CtrlRegs.FPAC1.bit.PMPPWR = 0;\n\n    EDIS;\n}\n\n//\n// SeizeFlashPump - Wait until the flash pump is available. Then take control\n//                  of it using the flash pump Semaphore.\n//\nvoid SeizeFlashPump(void)\n{\n    EALLOW;\n    #ifdef CPU1\n        while (FlashPumpSemaphoreRegs.PUMPREQUEST.bit.PUMP_OWNERSHIP != 0x2)\n        {\n            FlashPumpSemaphoreRegs.PUMPREQUEST.all = IPC_PUMP_KEY | 0x2;\n        }\n    #elif defined(CPU2)\n        while (FlashPumpSemaphoreRegs.PUMPREQUEST.bit.PUMP_OWNERSHIP != 0x1)\n        {\n            FlashPumpSemaphoreRegs.PUMPREQUEST.all = IPC_PUMP_KEY | 0x1;\n        }\n    #endif\n    EDIS;\n}\n\n//\n// ReleaseFlashPump - Release control of the flash pump using the flash pump\n//                    semaphore.\n//\nvoid ReleaseFlashPump(void)\n{\n    EALLOW;\n    FlashPumpSemaphoreRegs.PUMPREQUEST.all = IPC_PUMP_KEY | 0x0;\n    EDIS;\n}\n\n//\n// ServiceDog - This function resets the watchdog timer.\n//\n// Enable this function for using ServiceDog in the application.\n//\nvoid ServiceDog(void)\n{\n    EALLOW;\n    WdRegs.WDKEY.bit.WDKEY = 0x0055;\n    WdRegs.WDKEY.bit.WDKEY = 0x00AA;\n    EDIS;\n}\n\n//\n// DisableDog - This function disables the watchdog timer.\n//\nvoid DisableDog(void)\n{\n    volatile Uint16 temp;\n\n    //\n    // Grab the clock config first so we don't clobber it\n    //\n    EALLOW;\n    temp = WdRegs.WDCR.all & 0x0007;\n    WdRegs.WDCR.all = 0x0068 | temp;\n    EDIS;\n}\n\n#ifdef CPU1\n//\n// InitSysPll()\n// This function initializes the PLL registers.\n// Note:\n//  - The internal oscillator CANNOT be used as the PLL source if the\n//    PLLSYSCLK is configured to frequencies above 194 MHz.\n//\n//  - This function uses the Watchdog as a monitor for the PLL. The user\n//  watchdog settings will be modified and restored upon completion.  Function\n//  allows for a minimum re lock attempt for 5 tries.  Re lock attempt is carried\n//  out if either SLIP condition occurs or SYSCLK to Input Clock ratio is off by 10%\n//\n//  - This function uses the following resources to support PLL initialization:\n//          o Watchdog\n//          o CPU Timer 1\n//          o CPU Timer 2\n//\nvoid InitSysPll(Uint16 clock_source, Uint16 imult, Uint16 fmult, Uint16 divsel)\n{\n    Uint16 SCSR, WDCR, WDWCR, intStatus,  t1TCR, t1TPR, t1TPRH;\n    Uint16 t2TCR, t2TPR, t2TPRH, t2SRC, t2Prescale;\n    Uint32 t1PRD, t2PRD, ctr1;\n    float sysclkToInClkError, mult, div;\n    bool sysclkInvalidFreq=true;\n\n    if((clock_source == ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL)    &&\n       (imult        == ClkCfgRegs.SYSPLLMULT.bit.IMULT)           &&\n       (fmult        == ClkCfgRegs.SYSPLLMULT.bit.FMULT)           &&\n       (divsel       == ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV))\n    {\n        //\n        // Everything is set as required, so just return\n        //\n        return;\n    }\n\n    if(clock_source != ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL)\n    {\n        switch (clock_source)\n        {\n            case INT_OSC1:\n                SysIntOsc1Sel();\n                break;\n\n            case INT_OSC2:\n                SysIntOsc2Sel();\n                break;\n\n            case XTAL_OSC:\n                SysXtalOscSel();\n                break;\n        }\n    }\n\n    EALLOW;\n    if(imult != ClkCfgRegs.SYSPLLMULT.bit.IMULT ||\n       fmult != ClkCfgRegs.SYSPLLMULT.bit.FMULT)\n    {\n        Uint16 i;\n\n        //\n        // This bit is reset only by POR\n        //\n        if(DevCfgRegs.SYSDBGCTL.bit.BIT_0 == 1)\n        {\n            //\n            // The user can optionally insert handler code here. This will only\n            // be executed if a watchdog reset occurred after a failed system\n            // PLL initialization. See your device user's guide for more\n            // information.\n            //\n            // If the application has a watchdog reset handler, this bit should\n            // be checked to determine if the watchdog reset occurred because\n            // of the PLL.\n            //\n            // No action here will continue with retrying the PLL as normal.\n            //\n            // Failed PLL initialization is due to any of the following:\n            //      - No PLL clock\n            //      - SLIP condition\n            //      - Wrong Frequency\n            //\n        }\n\n        //\n        // Bypass PLL and set dividers to /1\n        //\n        ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 0;\n\n        //\n        // Delay of at least 120 OSCCLK cycles required post PLL bypass\n        //\n        asm(\" RPT #120 || NOP\");\n        ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV = 0;\n\n        //\n        // Lock the PLL five times. This helps ensure a successful start.\n        // Five is the minimum recommended number. The user can increase this\n        // number according to allotted system initialization time.\n        //\n        for(i = 0; i < 5; i++)\n        {\n            //\n            // Turn off PLL\n            //\n            ClkCfgRegs.SYSPLLCTL1.bit.PLLEN = 0;\n            asm(\" RPT #20 || NOP\");\n\n            //\n            // Write multiplier, which automatically turns on the PLL\n            //\n            ClkCfgRegs.SYSPLLMULT.all = ((fmult << 8U) | imult);\n\n            //\n            // Wait for the SYSPLL lock counter\n            //\n            while(ClkCfgRegs.SYSPLLSTS.bit.LOCKS != 1)\n            {\n                //\n                // Uncomment to service the watchdog\n                //\n                // ServiceDog();\n            }\n        }\n    }\n\n    //\n    // Set divider to produce slower output frequency to limit current increase\n    //\n    if(divsel != PLLCLK_BY_126)\n    {\n         ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV = divsel + 1;\n    }\n    else\n    {\n         ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV = divsel;\n    }\n\n    //\n    //      *CAUTION*\n    // It is recommended to use the following watchdog code to monitor the PLL\n    // startup sequence. If your application has already cleared the watchdog\n    // SCRS[WDOVERRIDE] bit this cannot be done. It is recommended not to clear\n    // this bit until after the PLL has been initiated.\n    //\n\n    //\n    // Backup User Watchdog\n    //\n    SCSR = WdRegs.SCSR.all;\n    WDCR = WdRegs.WDCR.all;\n    WDWCR = WdRegs.WDWCR.all;\n\n    //\n    // Disable windowed functionality, reset counter\n    //\n    EALLOW;\n    WdRegs.WDWCR.all = 0x0;\n    WdRegs.WDKEY.bit.WDKEY = 0x55;\n    WdRegs.WDKEY.bit.WDKEY = 0xAA;\n\n    //\n    // Disable global interrupts\n    //\n    intStatus = __disable_interrupts();\n\n    //\n    // Configure for watchdog reset and to run at max frequency\n    //\n    WdRegs.SCSR.all = 0x0;\n    WdRegs.WDCR.all = 0x28;\n\n    //\n    // This bit is reset only by power-on-reset (POR) and will not be cleared\n    // by a WD reset\n    //\n    DevCfgRegs.SYSDBGCTL.bit.BIT_0 = 1;\n\n    //\n    // Enable PLLSYSCLK is fed from system PLL clock\n    //\n    ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 1;\n\n    //\n    // Delay to ensure system is clocking from PLL prior to clearing status bit\n    //\n    asm(\" RPT #20 || NOP\");\n\n    //\n    // Service watchdog\n    //\n    ServiceDog();\n\n    //\n    // Slip Bit Monitor and SYSCLK Frequency Check using timers\n    // Re-lock routine for SLIP condition or if SYSCLK and CLKSRC timer counts\n    // are off by +/- 10%.\n    // At a minimum, SYSCLK check is performed.  Re lock attempt is carried out\n    // if SLIPS bit is set. This while loop is monitored by watchdog.\n    // In the event that the PLL does not successfully lock, the loop will be\n    // aborted by watchdog reset.\n    //\n    EALLOW;\n    while(sysclkInvalidFreq == true)\n    {\n        if(ClkCfgRegs.SYSPLLSTS.bit.SLIPS == 1)\n        {\n            //\n            // Bypass PLL\n            //\n            ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 0;\n\n            //\n            // Delay of at least 120 OSCCLK cycles required post PLL bypass\n            //\n            asm(\" RPT #120 || NOP\");\n\n            //\n            // Turn off PLL\n            //\n            ClkCfgRegs.SYSPLLCTL1.bit.PLLEN = 0;\n            asm(\" RPT #20 || NOP\");\n\n            //\n            // Write multipliers, which automatically turns on the PLL\n            //\n            ClkCfgRegs.SYSPLLMULT.all = ((fmult << 8U) | imult);\n\n            //\n            // Wait for the SYSPLL lock counter to expire\n            //\n            while(ClkCfgRegs.SYSPLLSTS.bit.LOCKS != 1);\n\n            //\n            // Enable PLLSYSCLK is fed from system PLL clock\n            //\n            ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 1;\n\n            //\n            // Delay to ensure system is clocking from PLL\n            //\n            asm(\" RPT #20 || NOP\");\n        }\n\n        //\n        // Backup timer1 and timer2 settings\n        //\n        t1TCR = CpuTimer1Regs.TCR.all;\n        t1PRD = CpuTimer1Regs.PRD.all;\n        t1TPR = CpuTimer1Regs.TPR.all;\n        t1TPRH = CpuTimer1Regs.TPRH.all;\n        t2SRC = CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL;\n        t2Prescale = CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKPRESCALE;\n        t2TCR = CpuTimer2Regs.TCR.all;\n        t2PRD = CpuTimer2Regs.PRD.all;\n        t2TPR = CpuTimer2Regs.TPR.all;\n        t2TPRH = CpuTimer2Regs.TPRH.all;\n\n        //\n        // Set up timers 1 and 2\n        // Configure timer1 to count SYSCLK cycles\n        //\n        CpuTimer1Regs.TCR.bit.TSS = 1;                                    // stop timer1\n        CpuTimer1Regs.PRD.all = TMR1SYSCLKCTR;                            // seed timer1 counter\n        CpuTimer1Regs.TPR.bit.TDDR = 0x0;                                 // sysclock divider\n        CpuTimer1Regs.TCR.bit.TRB = 1;                                    // reload timer with value in PRD\n        CpuTimer1Regs.TCR.bit.TIF = 1;                                    // clear interrupt flag\n        CpuTimer1Regs.TCR.bit.TIE = 1;                                    // enable interrupt\n\n        //\n        // Configure timer2 to count Input clock cycles\n        //\n        switch(clock_source)\n        {\n            case INT_OSC1:\n                // Clk Src = INT_OSC1\n                CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL = 0x1;\n                break;\n            case INT_OSC2:\n                // Clk Src = INT_OSC2\n                CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL = 0x2;\n                break;\n            case XTAL_OSC:\n                // Clk Src = XTAL\n                CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL = 0x3;\n                break;\n\n        }\n        CpuTimer2Regs.TCR.bit.TIF = 1;                                    // clear interrupt flag\n        CpuTimer2Regs.TCR.bit.TIE = 1;                                    // enable interrupt\n        CpuTimer2Regs.TCR.bit.TSS = 1;                                    // stop timer2\n        CpuTimer2Regs.PRD.all = TMR2INPCLKCTR;                            // seed timer2 counter\n        CpuTimer2Regs.TPR.bit.TDDR = 0x0;                                 // sysclock divider\n        CpuTimer2Regs.TCR.bit.TRB = 1;                                    // reload timer with value in PRD\n\n        //\n        // Stop/Start timer counters\n        //\n        CpuTimer1Regs.TCR.bit.TSS = 1;                                    // stop timer1\n        CpuTimer2Regs.TCR.bit.TSS = 1;                                    // stop timer2\n        CpuTimer1Regs.TCR.bit.TRB = 1;                                    // reload timer1 with value in PRD\n        CpuTimer2Regs.TCR.bit.TRB = 1;                                    // reload timer2 with value in PRD\n        CpuTimer2Regs.TCR.bit.TIF = 1;                                    // clear timer2 interrupt flag\n        CpuTimer2Regs.TCR.bit.TSS = 0;                                    // start timer2\n        CpuTimer1Regs.TCR.bit.TSS = 0;                                    // start timer1\n\n        //\n        // Stop timers if either timer1 or timer2 counters overflow\n        //\n        while((CpuTimer2Regs.TCR.bit.TIF == 0) && (CpuTimer1Regs.TCR.bit.TIF == 0));\n\n        CpuTimer1Regs.TCR.bit.TSS = 1;                                    // stop timer1\n        CpuTimer2Regs.TCR.bit.TSS = 1;                                    // stop timer2\n\n        //\n        // Calculate elapsed counts on timer1\n        //\n        ctr1 = TMR1SYSCLKCTR - CpuTimer1Regs.TIM.all;\n\n        //\n        // Restore timer settings\n        //\n        CpuTimer1Regs.TCR.all = t1TCR;\n        CpuTimer1Regs.PRD.all = t1PRD;\n        CpuTimer1Regs.TPR.all = t1TPR;\n        CpuTimer1Regs.TPRH.all = t1TPRH;\n        CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL = t2SRC;\n        CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKPRESCALE = t2Prescale;\n        CpuTimer2Regs.TCR.all = t2TCR;\n        CpuTimer2Regs.PRD.all = t2PRD;\n        CpuTimer2Regs.TPR.all = t2TPR;\n        CpuTimer2Regs.TPRH.all = t2TPRH;\n\n        //\n        // Calculate Clock Error:\n        // Error = (mult/div) - (timer1 count/timer2 count)\n        //\n        mult = (float)(imult) + (float)(fmult)/4;\n        div = (float)((!ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV) ? 1 : (ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV << 1));\n\n        sysclkToInClkError = (mult/div) - ((float)ctr1/(float)TMR2INPCLKCTR);\n\n        //\n        // sysclkInvalidFreq will be set to true if sysclkToInClkError is off by 10%\n        //\n        sysclkInvalidFreq = ((sysclkToInClkError > 0.10) || (sysclkToInClkError < -0.10));\n    }\n\n    //\n    // Clear bit\n    //\n    DevCfgRegs.SYSDBGCTL.bit.BIT_0 = 0;\n\n    //\n    // Restore user watchdog, first resetting counter\n    //\n    WdRegs.WDKEY.bit.WDKEY = 0x55;\n    WdRegs.WDKEY.bit.WDKEY = 0xAA;\n\n    WDCR |= 0x28;                     // Setup WD key--KEY bits always read 0\n    WdRegs.WDCR.all = WDCR;\n    WdRegs.WDWCR.all = WDWCR;\n    WdRegs.SCSR.all = SCSR & 0xFFFE;  // Mask write to bit 0 (W1toClr)\n\n    //\n    // Restore state of ST1[INTM]. This was set by the __disable_interrupts()\n    // intrinsic previously.\n    //\n    if(!(intStatus & 0x1))\n    {\n        EINT;\n    }\n\n    //\n    // Restore state of ST1[DBGM]. This was set by the __disable_interrupts()\n    // intrinsic previously.\n    //\n    if(!(intStatus & 0x2))\n    {\n        asm(\" CLRC DBGM\");\n    }\n\n    //\n    // 200 PLLSYSCLK delay to allow voltage regulator to stabilize prior\n    // to increasing entire system clock frequency.\n    //\n    asm(\" RPT #200 || NOP\");\n\n    //\n    // Set the divider to user value\n    //\n    ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV = divsel;\n\n    EDIS;\n}\n#endif // CPU1\n\n//\n// InitAuxPll - This function initializes the AUXPLL registers.\n//\n// Note: For this function to properly detect PLL startup,\n// SYSCLK >= 2*AUXPLLCLK after the AUXPLL is selected as the clocking source.\n//\n// This function will use CPU Timer 2 to monitor a successful lock of the\n// AUXPLL.\n//\nvoid InitAuxPll(Uint16 clock_source, Uint16 imult, Uint16 fmult, Uint16 divsel)\n{\n    Uint16 i;\n    Uint16 counter = 0;\n    Uint16 started = 0;\n    Uint16 t2TCR, t2TPR, t2TPRH, t2SRC, t2Prescale, attempts;\n    Uint32 t2PRD;\n\n    if((clock_source == ClkCfgRegs.CLKSRCCTL2.bit.AUXOSCCLKSRCSEL) &&\n       (imult        == ClkCfgRegs.AUXPLLMULT.bit.IMULT)           &&\n       (fmult        == ClkCfgRegs.AUXPLLMULT.bit.FMULT)           &&\n       (divsel       == ClkCfgRegs.AUXCLKDIVSEL.bit.AUXPLLDIV))\n    {\n        //\n        // Everything is set as required, so just return\n        //\n        return;\n    }\n\n    switch (clock_source)\n    {\n        case INT_OSC2:\n            AuxIntOsc2Sel();\n            break;\n\n        case XTAL_OSC:\n            AuxXtalOscSel();\n            break;\n\n        case AUXCLKIN:\n            AuxAuxClkSel();\n            break;\n    }\n\n    EALLOW;\n    ClkCfgRegs.AUXPLLCTL1.bit.PLLCLKEN = 0;    // Bypass AUXPLL\n    EDIS;\n\n    //\n    // Delay of at least 120 OSCCLK cycles required post PLL bypass\n    //\n    asm(\" RPT #120 || NOP\");\n\n    //\n    // Backup Timer 2 settings\n    //\n    t2SRC = CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL;\n    t2Prescale = CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKPRESCALE;\n    t2TCR = CpuTimer2Regs.TCR.all;\n    t2PRD = CpuTimer2Regs.PRD.all;\n    t2TPR = CpuTimer2Regs.TPR.all;\n    t2TPRH = CpuTimer2Regs.TPRH.all;\n\n    //\n    // Configure Timer 2 for AUXPLL as source in known configuration\n    //\n    EALLOW;\n    CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL = 0x6;\n    CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKPRESCALE = 0x0;    // Divide by 1\n\n    CpuTimer2Regs.TCR.bit.TSS = 1;      // Stop timer\n    CpuTimer2Regs.PRD.all = 10;         // Small PRD value to detect overflow\n    CpuTimer2Regs.TPR.all = 0;\n    CpuTimer2Regs.TPRH.all = 0;\n    CpuTimer2Regs.TCR.bit.TIE = 0;      // Disable timer interrupts\n\n    //\n    // Set AUX Divide by 8 to ensure that AUXPLLCLK <= SYSCLK/2 while using\n    // Timer 2\n    //\n    ClkCfgRegs.AUXCLKDIVSEL.bit.AUXPLLDIV = 0x3;\n    EDIS;\n\n    while((counter < 5) && (started == 0))\n    {\n        EALLOW;\n        ClkCfgRegs.AUXPLLCTL1.bit.PLLEN = 0;    // Turn off AUXPLL\n        asm(\" RPT #20 || NOP\");                 // Small delay for power down\n\n        //\n        // Set integer and fractional multiplier, which automatically turns on\n        // the PLL\n        //\n        ClkCfgRegs.AUXPLLMULT.all = ((fmult << 8U) | imult);\n\n        //\n        // Enable AUXPLL\n        //\n        ClkCfgRegs.AUXPLLCTL1.bit.PLLEN = 1;\n        EDIS;\n\n        //\n        // Wait for the AUXPLL lock counter\n        //\n        while(ClkCfgRegs.AUXPLLSTS.bit.LOCKS != 1)\n        {\n            //\n            // Uncomment to service the watchdog\n            //\n            // ServiceDog();\n        }\n\n        //\n        // Enable AUXPLLCLK to be fed from AUX PLL\n        //\n        EALLOW;\n        ClkCfgRegs.AUXPLLCTL1.bit.PLLCLKEN = 1;\n        asm(\" RPT #20 || NOP\");\n\n        //\n        // CPU Timer 2 will now be setup to be clocked from AUXPLLCLK. This is\n        // used to test that the PLL has successfully started.\n        //\n        CpuTimer2Regs.TCR.bit.TRB = 1;      // Reload period value\n        CpuTimer2Regs.TCR.bit.TSS = 0;      // Start Timer\n\n        //\n        // Check to see timer is counting properly\n        //\n        for(i = 0; i < 1000; i++)\n        {\n            //\n            // Check overflow flag\n            //\n            if(CpuTimer2Regs.TCR.bit.TIF)\n            {\n                //\n                // Clear overflow flag\n                //\n                CpuTimer2Regs.TCR.bit.TIF = 1;\n\n                //\n                // Set flag to indicate PLL started and break out of for-loop\n                //\n                started = 1;\n                break;\n            }\n        }\n\n        //\n        // Stop timer\n        //\n        CpuTimer2Regs.TCR.bit.TSS = 1;\n        counter++;\n        EDIS;\n    }\n\n    if(started == 0)\n    {\n        //\n        // AUX PLL may not have started. Reset multiplier to 0 (bypass PLL).\n        //\n        EALLOW;\n        ClkCfgRegs.AUXPLLMULT.all = 0;\n        EDIS;\n\n        //\n        // The user should put some handler code here based on how this\n        // condition should be handled in their application.\n        //\n        asm(\" ESTOP0\");\n    }\n\n    //\n    // Slip Bit Monitor\n    // Re-lock routine for SLIP condition\n    //\n    attempts = 0;\n    while(ClkCfgRegs.AUXPLLSTS.bit.SLIPS && (attempts < 10))\n    {\n        EALLOW;\n        //\n        // Bypass AUXPLL\n        //\n        ClkCfgRegs.AUXPLLCTL1.bit.PLLCLKEN = 0;\n\n        //\n        // Delay of at least 120 OSCCLK cycles required post PLL bypass\n        //\n        asm(\" RPT #120 || NOP\");\n\n        //\n        // Turn off AUXPLL\n        //\n        ClkCfgRegs.AUXPLLCTL1.bit.PLLEN = 0;\n        asm(\" RPT #20 || NOP\");\n\n        //\n        // Set integer and fractional multiplier, which automatically turns\n        // on the PLL\n        //\n        ClkCfgRegs.AUXPLLMULT.all = ((fmult << 8U) | imult);\n\n        //\n        // Wait for the AUXPLL lock counter\n        //\n        while(ClkCfgRegs.AUXPLLSTS.bit.LOCKS != 1);\n\n        //\n        // Enable AUXPLLCLK to be fed from AUXPLL\n        //\n        ClkCfgRegs.AUXPLLCTL1.bit.PLLCLKEN = 1;\n        asm(\" RPT #20 || NOP\");\n\n        attempts++;\n        EDIS;\n    }\n\n    //\n    // Set divider to desired value\n    //\n    EALLOW;\n    ClkCfgRegs.AUXCLKDIVSEL.bit.AUXPLLDIV = divsel;\n\n    //\n    // Restore Timer 2 configuration\n    //\n    CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKSRCSEL = t2SRC;\n    CpuSysRegs.TMR2CLKCTL.bit.TMR2CLKPRESCALE = t2Prescale;\n    CpuTimer2Regs.TCR.all = t2TCR;\n    CpuTimer2Regs.PRD.all = t2PRD;\n    CpuTimer2Regs.TPR.all = t2TPR;\n    CpuTimer2Regs.TPRH.all = t2TPRH;\n\n    //\n    // Reload period value\n    //\n    CpuTimer2Regs.TCR.bit.TRB = 1;\n    EDIS;\n}\n\n//\n// CsmUnlock - This function unlocks the CSM. User must replace 0xFFFF's with\n//             current password for the DSP. Returns 1 if unlock is successful.\n//\nUint16 CsmUnlock(void)\n{\n    volatile Uint16 temp;\n\n    //\n    // Load the key registers with the current password. The 0xFFFF's are dummy\n    // passwords.  User should replace them with the correct password for the\n    // DSP.\n    //\n    EALLOW;\n    DcsmZ1Regs.Z1_CSMKEY0 = 0xFFFFFFFF;\n    DcsmZ1Regs.Z1_CSMKEY1 = 0xFFFFFFFF;\n    DcsmZ1Regs.Z1_CSMKEY2 = 0xFFFFFFFF;\n    DcsmZ1Regs.Z1_CSMKEY3 = 0xFFFFFFFF;\n\n    DcsmZ2Regs.Z2_CSMKEY0 = 0xFFFFFFFF;\n    DcsmZ2Regs.Z2_CSMKEY1 = 0xFFFFFFFF;\n    DcsmZ2Regs.Z2_CSMKEY2 = 0xFFFFFFFF;\n    DcsmZ2Regs.Z2_CSMKEY3 = 0xFFFFFFFF;\n    EDIS;\n\n    return(0);\n}\n\n//\n// SysIntOsc1Sel - This function switches to Internal Oscillator 1.\n//\nvoid SysIntOsc1Sel(void)\n{\n    EALLOW;\n    ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL = 2;     // Clk Src = INTOSC1\n    SYSCTRL_CLKSRCCTL1_DELAY;\n    ClkCfgRegs.CLKSRCCTL1.bit.XTALOFF=1;            // Turn off XTALOSC\n    EDIS;\n}\n\n//\n// SysIntOsc2Sel - This function switches to Internal oscillator 2.\n//\nvoid SysIntOsc2Sel(void)\n{\n    EALLOW;\n    ClkCfgRegs.CLKSRCCTL1.bit.INTOSC2OFF=0;         // Turn on INTOSC2\n    SYSCTRL_CLKSRCCTL1_DELAY;\n    ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL = 0;     // Clk Src = INTOSC2\n    SYSCTRL_CLKSRCCTL1_DELAY;\n    ClkCfgRegs.CLKSRCCTL1.bit.XTALOFF=1;            // Turn off XTALOSC\n    EDIS;\n}\n\n//\n// SysXtalOscSel - This function switches to External CRYSTAL oscillator.\n//\nvoid SysXtalOscSel(void)\n{\n    EALLOW;\n    ClkCfgRegs.CLKSRCCTL1.bit.XTALOFF=0;            // Turn on XTALOSC\n    SYSCTRL_CLKSRCCTL1_DELAY;\n    ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL = 1;     // Clk Src = XTAL\n    EDIS;\n}\n\n//\n// AuxIntOsc2Sel - This function switches to Internal oscillator 2.\n//\nvoid AuxIntOsc2Sel(void)\n{\n    EALLOW;\n    ClkCfgRegs.CLKSRCCTL1.bit.INTOSC2OFF=0;         // Turn on INTOSC2\n    ClkCfgRegs.CLKSRCCTL2.bit.AUXOSCCLKSRCSEL = 0;  // Clk Src = INTOSC2\n    EDIS;\n}\n\n//\n// AuxXtalOscSel - This function switches to External CRYSTAL oscillator.\n//\nvoid AuxXtalOscSel(void)\n{\n    EALLOW;\n    ClkCfgRegs.CLKSRCCTL1.bit.XTALOFF=0;            // Turn on XTALOSC\n    ClkCfgRegs.CLKSRCCTL2.bit.AUXOSCCLKSRCSEL = 1;  // Clk Src = XTAL\n    EDIS;\n}\n\n//\n// AuxAUXCLKOscSel - This function switches to AUXCLKIN (from a GPIO).\n//\nvoid AuxAuxClkSel(void)\n{\n    EALLOW;\n    ClkCfgRegs.CLKSRCCTL2.bit.AUXOSCCLKSRCSEL = 2; // Clk Src = XTAL\n    EDIS;\n}\n\n//\n// IDLE - Enter IDLE mode (single CPU).\n//\nvoid IDLE(void)\n{\n    EALLOW;\n    CpuSysRegs.LPMCR.bit.LPM = LPM_IDLE;\n    EDIS;\n    asm(\" IDLE\");\n}\n\n//\n// STANDBY - Enter STANDBY mode (single CPU).\n//\nvoid STANDBY(void)\n{\n    EALLOW;\n    CpuSysRegs.LPMCR.bit.LPM = LPM_STANDBY;\n    EDIS;\n    asm(\" IDLE\");\n}\n\n//\n// HALT - Enter HALT mode (dual CPU). Puts CPU2 in IDLE mode first.\n//\nvoid HALT(void)\n{\n#if defined(CPU2)\n    IDLE();\n#elif defined(CPU1)\n    EALLOW;\n    CpuSysRegs.LPMCR.bit.LPM = LPM_HALT;\n    EDIS;\n\n    while(DevCfgRegs.LPMSTAT.bit.CPU2LPMSTAT != 0x1);\n\n    EALLOW;\n    ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 0;\n    ClkCfgRegs.SYSPLLCTL1.bit.PLLEN = 0;\n    EDIS;\n    asm(\" IDLE\");\n#endif\n}\n\n//\n// HIB - Enter HIB mode (dual CPU). Puts CPU2 in STANDBY first. Alternately,\n//       CPU2 may be in reset.\nvoid HIB(void)\n{\n#if defined(CPU2)\n    STANDBY();\n#elif defined(CPU1)\n    EALLOW;\n    CpuSysRegs.LPMCR.bit.LPM = LPM_HIB;\n    EDIS;\n\n    while((DevCfgRegs.LPMSTAT.bit.CPU2LPMSTAT == 0x0) &&\n          (DevCfgRegs.RSTSTAT.bit.CPU2RES == 1));\n\n    DisablePeripheralClocks();\n    EALLOW;\n    ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 0;\n    ClkCfgRegs.SYSPLLCTL1.bit.PLLEN = 0;\n    EDIS;\n    asm(\" IDLE\");\n#endif\n}\n\n#ifdef CPU1\n//\n// Function to implement Analog trim of TMX devices. This function should be\n// called post enabling the EALLOW protected writes.\n//\nvoid ConfigureTMXAnalogTrim(void)\n{\n    //\n    // Enable ADC clock\n    //\n    CpuSysRegs.PCLKCR13.bit.ADC_A = 1;\n    CpuSysRegs.PCLKCR13.bit.ADC_B = 1;\n    CpuSysRegs.PCLKCR13.bit.ADC_C = 1;\n    CpuSysRegs.PCLKCR13.bit.ADC_D = 1;\n\n\n    //\n    // Device is not trimmed--apply static calibration values\n    //\n    AnalogSubsysRegs.ANAREFTRIMA.all = 0x7BDD;\n    AnalogSubsysRegs.ANAREFTRIMB.all = 0x7BDD;\n    AnalogSubsysRegs.ANAREFTRIMC.all = 0x7BDD;\n    AnalogSubsysRegs.ANAREFTRIMD.all = 0x7BDD;\n\n    //\n    // Configure ADC offset trim. The user should generate the trim values\n    // by following the instructions in the \"ADC Zero Offset Calibration\"\n    // section in device TRM. The below lines needs to be uncommented and\n    // updated with the correct trim values.\n    //\n//    AdcaRegs.ADCOFFTRIM.all = 0x0;\n//    AdcbRegs.ADCOFFTRIM.all = 0x0;\n//    AdccRegs.ADCOFFTRIM.all = 0x0;\n//    AdcdRegs.ADCOFFTRIM.all = 0x0;\n\n    //\n    // Configure internal oscillator trim. If the internal oscillator trim\n    // contains all zeros, the user can adjust the lowest 10 bits of the\n    // oscillator trim register between 1 (minimum) and 1023 (maximum)\n    // while observing the system clock on the XCLOCKOUT pin. The below\n    // lines needs to be uncommented and updated with the correct trim values.\n    //\n//    if(AnalogSubsysRegs.INTOSC1TRIM.all == 0x0)\n//    {\n//        AnalogSubsysRegs.INTOSC1TRIM.all = 0x0;\n//    }\n//\n//    if(AnalogSubsysRegs.INTOSC2TRIM.all == 0x0)\n//    {\n//        AnalogSubsysRegs.INTOSC2TRIM.all = 0x0;\n//    }\n\n    //\n    // Disable ADC clock\n    //\n    CpuSysRegs.PCLKCR13.bit.ADC_A = 0;\n    CpuSysRegs.PCLKCR13.bit.ADC_B = 0;\n    CpuSysRegs.PCLKCR13.bit.ADC_C = 0;\n    CpuSysRegs.PCLKCR13.bit.ADC_D = 0;\n}\n#endif\n"},{"name":"F2837xD_usDelay.asm","type":"other","group":"legacy","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_02_00_00\\device_support\\f2837xd\\common\\source","tag":"","groupDisplay":"Other files","code":";//###########################################################################\n;//\n;// FILE: F2837xD_usDelay.asm\n;//\n;// TITLE: Simple delay function\n;//\n;// DESCRIPTION:\n;// This is a simple delay function that can be used to insert a specified\n;// delay into code.\n;// This function is only accurate if executed from internal zero-waitstate\n;// SARAM. If it is executed from waitstate memory then the delay will be\n;// longer then specified.\n;// To use this function:\n;//  1 - update the CPU clock speed in the F2837xD_Examples.h\n;//    file. For example:\n;//    #define CPU_RATE 6.667L // for a 150MHz CPU clock speed\n;//  2 - Call this function by using the DELAY_US(A) macro\n;//    that is defined in the F2837xD_Device.h file.  This macro\n;//    will convert the number of microseconds specified\n;//    into a loop count for use with this function.\n;//    This count will be based on the CPU frequency you specify.\n;//  3 - For the most accurate delay\n;//    - Execute this function in 0 waitstate RAM.\n;//    - Disable interrupts before calling the function\n;//      If you do not disable interrupts, then think of\n;//      this as an \"at least\" delay function as the actual\n;//      delay may be longer.\n;//  The C assembly call from the DELAY_US(time) macro will\n;//  look as follows:\n;//  extern void Delay(long LoopCount);\n;//        MOV   AL,#LowLoopCount\n;//        MOV   AH,#HighLoopCount\n;//        LCR   _Delay\n;//  Or as follows (if count is less then 16-bits):\n;//        MOV   ACC,#LoopCount\n;//        LCR   _Delay\n;//\n;//###########################################################################\n;//\n;// $Release Date: $\n;// $Copyright:\n;// Copyright (C) 2013-2024 Texas Instruments Incorporated - http://www.ti.com/\n;//\n;// Redistribution and use in source and binary forms, with or without \n;// modification, are permitted provided that the following conditions \n;// are met:\n;// \n;//   Redistributions of source code must retain the above copyright \n;//   notice, this list of conditions and the following disclaimer.\n;// \n;//   Redistributions in binary form must reproduce the above copyright\n;//   notice, this list of conditions and the following disclaimer in the \n;//   documentation and/or other materials provided with the   \n;//   distribution.\n;// \n;//   Neither the name of Texas Instruments Incorporated nor the names of\n;//   its contributors may be used to endorse or promote products derived\n;//   from this software without specific prior written permission.\n;// \n;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n;// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n;// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n;// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n;// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n;// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n;// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n;// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n;// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n;// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n;// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n;// $\n;//###########################################################################\n\n\t   .if __TI_EABI__\n\t   .asg F28x_usDelay, _F28x_usDelay\n\t   .endif\n\n       .def _F28x_usDelay\n\n       .cdecls LIST ;;Used to populate __TI_COMPILER_VERSION__ macro\n       %{\n       %}\n\n       .if __TI_COMPILER_VERSION__\n       .if __TI_COMPILER_VERSION__ >= 15009000\n       .sect \".TI.ramfunc\"      ;;Used with compiler v15.9.0 and newer\n       .else\n       .sect \"ramfuncs\"         ;;Used with compilers older than v15.9.0\n       .endif\n       .endif\n\n        .global  __F28x_usDelay\n_F28x_usDelay:\n        SUB    ACC,#1\n        BF     _F28x_usDelay,GEQ    ;; Loop if ACC >= 0\n        LRETR\n\n;There is a 9/10 cycle overhead and each loop\n;takes five cycles. The LoopCount is given by\n;the following formula:\n;  DELAY_CPU_CYCLES = 9 + 5*LoopCount\n; LoopCount = (DELAY_CPU_CYCLES - 9) / 5\n; The macro DELAY_US(A) performs this calculation for you\n;\n;\n\n;//\n;// End of file\n;//\n"},{"name":"MW_SPI.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\c2b\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2017-2024 The MathWorks, Inc. */\n#ifndef MATLAB_MEX_FILE\n#include \"MW_c28xSPI.h\"\n#endif\n#include \"MW_SPI.h\"\n\n/* Intialize SPI device */\nMW_Handle_Type MW_SPI_Open(uint32_T SPIModule, uint32_T MosiPin, uint32_T MisoPin, uint32_T ClockPin, uint32_T SlaveSelectPin, uint8_T ActiveLowSSPin, uint8_T IsSPIDeviceMaster)\n{\n#ifndef MATLAB_MEX_FILE\n    MW_SpiHandle mySpi;\n    mySpi = SPI_init(SPIModule);\n#ifndef MW_F281X\n    if(SlaveSelectPin != MW_UNDEFINED_VALUE)\n    {\n        Set_GPIOPin(SlaveSelectPin, GPIO_MUX_CPU1, 0, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC);\n    }\n#endif\n    return (MW_Handle_Type)mySpi;\n#else\n    return (MW_Handle_Type)NULL;\n#endif //MATLAB_MEX_FILE\n}\n\n/* Set SPI Communication format for the processor */\n/* TargetPrecision: Bits/frame for processor */\n/* SPIMode: Clock polarity and clock phase */\n/* TargetFirstBitToTransfer: First bit to be transferred by processor */\nMW_SPI_Status_Type MW_SPI_SetFormat(MW_Handle_Type SPIModuleHandle, uint8_T TargetPrecision, MW_SPI_Mode_type SPIMode, MW_SPI_FirstBitTransfer_Type TargetFirstBitToTransfer)\n{\n#ifndef MATLAB_MEX_FILE\n    MW_SpiHandle mySpiConfig  = (MW_SpiHandle)SPIModuleHandle;\n    if((mySpiConfig ->spi_clk_mode == (Uint16)SPIMode) && (mySpiConfig->charLength == TargetPrecision))\n    {\n        // Do nothing when there is no change in the parameters\n        return MW_SPI_SUCCESS;\n    }\n    else\n    {\n        volatile struct SPI_REGS *SPI = (struct SPI_REGS *)mySpiConfig->spi_base_address;\n        // Update the SPI clock mode and Charecter length\n        mySpiConfig ->charLength = TargetPrecision;\n        mySpiConfig ->spi_clk_mode = (Uint16)SPIMode;\n        \n        (*SPI).SPICCR.bit.SPISWRESET = 0;\n        if (mySpiConfig ->spi_clk_mode == MW_SPI_MODE_0)\n        {        \n            (*SPI).SPICCR.bit.CLKPOLARITY = 0;\n            (*SPI).SPICTL.bit.CLK_PHASE = 0;\n        }\n        else if (mySpiConfig ->spi_clk_mode == MW_SPI_MODE_1)\n        {        \n            (*SPI).SPICCR.bit.CLKPOLARITY = 0;\n            (*SPI).SPICTL.bit.CLK_PHASE = 1;\n        }\n        else if (mySpiConfig ->spi_clk_mode == MW_SPI_MODE_2)\n        {        \n            (*SPI).SPICCR.bit.CLKPOLARITY = 1;\n            (*SPI).SPICTL.bit.CLK_PHASE = 0;\n        }\n        else\n        {        \n            (*SPI).SPICCR.bit.CLKPOLARITY = 1;\n            (*SPI).SPICTL.bit.CLK_PHASE = 1;\n        }\n        (*SPI).SPICCR.bit.SPICHAR = (uint16_T)((mySpiConfig->charLength) - 1);\n        (*SPI).SPICCR.bit.SPISWRESET = 1;\n        \n        return MW_SPI_SUCCESS;\n    }\n#else\n    return MW_SPI_SUCCESS;\n#endif //MATLAB_MEX_FILE\n}\n\n/* Set SPI bus speed */\nMW_SPI_Status_Type MW_SPI_SetBusSpeed(MW_Handle_Type SPIModuleHandle, uint32_T BusSpeedInHz)\n{\n#ifndef MATLAB_MEX_FILE\n    return MW_SPI_SUCCESS;\n#else\n    return MW_SPI_SUCCESS;\n#endif //MATLAB_MEX_FILE\n}\n\n/* Configure SPI peripheral select pin before starting the transmission if the peripheral select Pin is not custom */\nMW_SPI_Status_Type MW_SPI_SetSlaveSelect(MW_Handle_Type SPIModuleHandle, uint32_T SlaveSelectPin, uint8_T ActiveLowSSPin)\n{\n#ifndef MATLAB_MEX_FILE\n    return MW_SPI_SUCCESS;\n#else\n    return MW_SPI_SUCCESS;\n#endif //MATLAB_MEX_FILE\n}\n\n/* Initiate combined SPI transmission from controller to peripheral */\nMW_SPI_Status_Type MW_SPI_MasterWriteRead_8bits(MW_Handle_Type SPIModuleHandle, const uint8_T * WriteDataPtr, uint8_T * ReadDataPtr, uint32_T DataLength)\n{\n#ifndef MATLAB_MEX_FILE\n    MW_SpiHandle mySpi = (MW_SpiHandle)SPIModuleHandle;\n    volatile struct SPI_REGS *SPI = (struct SPI_REGS *)mySpi->spi_base_address;\n    uint32_T localVar;\n    uint16_T *readdata = (uint16_T*) ReadDataPtr;\n    uint16_T *writedata = (uint16_T*) WriteDataPtr;\n    \n    for (localVar = 0; localVar < DataLength; localVar++)\n    {\n        while ((*SPI).SPIFFTX.bit.TXFFST == mySpi->fifoLevel)\n        {\n            /*Wait until Tx buffer is cleared*/\n        }\n        (*SPI).SPITXBUF = writedata[localVar] << (16 - mySpi->charLength);\n        \n        while ((*SPI).SPIFFRX.bit.RXFFST == 0)\n        {\n            /*Wait until Rx buffer has data*/\n        }\n        readdata[localVar] = (*SPI).SPIRXBUF & (((Uint32)1 << mySpi->charLength) - 1);\n    }\n    \n    return MW_SPI_SUCCESS;\n#else\n    return MW_SPI_SUCCESS;\n#endif //MATLAB_MEX_FILE\n}\n\n/* Initiate data communication from controller to peripheral in peripheral mode */\nMW_SPI_Status_Type MW_SPI_SlaveWriteRead_8bits(MW_Handle_Type SPIModuleHandle, const uint8_T * WriteDataPtr, uint8_T * ReadDataPtr, uint32_T DataLength)\n{\n#ifndef MATLAB_MEX_FILE\n    return MW_SPI_SUCCESS;\n#else\n    return MW_SPI_SUCCESS;\n#endif //MATLAB_MEX_FILE\n}\n\n/* Get the status of SPI */\nMW_SPI_Status_Type MW_SPI_GetStatus(MW_Handle_Type SPIModuleHandle)\n{\n#ifndef MATLAB_MEX_FILE\n    return MW_SPI_SUCCESS;\n#else\n    return MW_SPI_SUCCESS;\n#endif //MATLAB_MEX_FILE\n}\n\n/* De-initialize or release the SPI */\nvoid MW_SPI_Close(MW_Handle_Type SPIModuleHandle, uint32_T MosiPin, uint32_T MisoPin, uint32_T ClockPin, uint32_T SlaveSelectPin)\n{\n}\n"},{"name":"MW_c2000GPIO.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\c2b\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"/*####################################################\n * FILE: MW_c2000GPIO.c\n * TITLE: APIs for GPIO module for C2000 target\n * Copyright 2017 The MathWorks, Inc.\n * ####################################################*/\n\n#include \"MW_c2000GPIO.h\"\n\n/* ***************************************************************************/\n/* the defines */\n\n/* ***************************************************************************/\n/* the globals */\n\n/* ***************************************************************************/\n/* the functions*/\n\n/* Called for each GPIO pin */\nvoid MW_digitalIOPin_open(Uint32 pin, Uint16 direction)\n{\n    if (direction == GPIO_OUTPUT)\n    {\n        Set_GPIOPin(pin, GPIO_MUX_CPU1, 0, GPIO_OUTPUT, GPIO_PULLUP);\n    }\n    else\n    {\n        Set_GPIOPin(pin, GPIO_MUX_CPU1, 0, GPIO_INPUT, GPIO_SYNC);\n    }\n}\n\n/* Read the logical state of a GPIO input pin */\nUint16 MW_digitalIOPin_read(Uint32 pin)\n{\n    Uint16 ret = 0;\n    ret = GPIO_ReadPin(pin);\n    return ret;\n}\n\n/* Set the logical state of a GPIO output pin */\nvoid MW_digitalIOPin_write(Uint32 pin, Uint16 value)\n{\n    GPIO_WritePin(pin, value);\n}\n\n/* Release resources used */\nvoid MW_digitalIOPin_close(Uint32 pin)\n{\n}\n"},{"name":"MW_c2000ISR.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\c2b\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2021-2023 The MathWorks, Inc. */\n\n#include \"MW_target_hardware_resources.h\"\n#include \"MW_c2000ISR.h\"\n#include \"MW_ipc_helper.h\"\n\n#define CIPC0_IRQNUM 132\n#define CMTOCPUxIPCINTR0_IRQNUM 208\n\nvoid HWI_TIC28x_ConfigureIRQ(uint16_T irqnumber, void (*isrfcn)(void), uint16_T priority)\n{\n    #if (defined(MW_F2838X) || defined(MW_F2837XD) || defined(MW_F28P65X)) && defined(CPU1)\n            /* For 38x, 37x, p65 CPU1*/\n            if (irqnumber == CIPC0_IRQNUM)\n                CIPC0_INT_fptr = isrfcn;\n        #if defined(MW_F2838X)\n            /* For 38x CPU1*/\n            else if (irqnumber == CMTOCPUxIPCINTR0_IRQNUM)\n                CMTOCPUXIPC0_INT_fptr = isrfcn;\n        #endif\n            /* For 38x, 37x, p65 CPU1 non IPC0 */\n            else\n            {\n                EALLOW;\n                ((PINT *)&PieVectTable)[irqnumber] = isrfcn; /* Map ISR to vector table */\n                EDIS;\n            }\n    #else \n            /* For 38x, 37x, p65 non CPU1 or for non 38x, 37x, p65 */\n            EALLOW;\n            ((PINT *)&PieVectTable)[irqnumber] = isrfcn; /* Map ISR to vector table */\n            EDIS;\n    #endif\n\n    (void)priority;\n}\n\nvoid HWI_TIC28x_EnableIRQ(uint16_T irqnumber)\n{\n    /* Interrupt groups */\n    if ((1 == irqnumber) \n    ||  (1 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER1.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        IER |= (0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((2 == irqnumber) \n    || (2 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER2.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        IER |= (0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((3 == irqnumber)\n    ||  (3 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER3.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        IER |= (0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((4 == irqnumber)\n    ||  (4 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER4.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        IER |= (0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((5 == irqnumber)\n    ||  (5 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER5.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        IER |= (0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((6 == irqnumber)\n    ||  (6 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER6.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        IER |= (0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((7 == irqnumber)\n    ||  (7 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER7.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        IER |= (0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((8 == irqnumber)\n    ||  (8 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER8.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        IER |= (0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((9 == irqnumber)\n    ||  (9 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER9.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        IER |= (0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((10 == irqnumber)\n    ||  (10 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER10.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        IER |= (0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((11 == irqnumber)\n    ||  (11 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER11.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        IER |= (0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((12 == irqnumber)\n    ||  (12 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER12.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        IER |= (0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    /* CPU Timer 1 */\n    else if (13 == irqnumber)\n    {\n    }\n    /* CPU Timer 2 */\n    else if (14 == irqnumber)\n    {\n    }\n    /* DATALOG */\n    else if (15 == irqnumber)\n    {\n    }\n    /* RTOSINT */\n    else if (16 == irqnumber)\n    {\n    }\n    /* EMUINT */\n    else if (17 == irqnumber)\n    {\n    }\n    /* NMI */\n    else if (18 == irqnumber)\n    {\n    }\n    /* 18 - ILLEGAL, 20 to 31 - User-defined trap */\n    else if ((irqnumber >= 19) && (irqnumber <= 31))\n    {\n    }\n    else\n    {\n        /* do nothing */\n    }\n}\n\nvoid HWI_TIC28x_DisableIRQ(uint16_T irqnumber)\n{\n    /* Interrupt groups */\n    if ((1 == irqnumber) \n    ||  (1 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER1.all &= ~(1U << GET_PIE_OFFSET_IN_GROUP(irqnumber));\n        IER &= ~(0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((2 == irqnumber) \n    || (2 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER2.all &= ~(1U << GET_PIE_OFFSET_IN_GROUP(irqnumber));\n        IER &= ~(0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((3 == irqnumber)\n    ||  (3 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER3.all &= ~(1U << GET_PIE_OFFSET_IN_GROUP(irqnumber));\n        IER &= ~(0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((4 == irqnumber)\n    ||  (4 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER4.all &= ~(1U << GET_PIE_OFFSET_IN_GROUP(irqnumber));\n        IER &= ~(0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((5 == irqnumber)\n    ||  (5 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER5.all &= ~(1U << GET_PIE_OFFSET_IN_GROUP(irqnumber));\n        IER &= ~(0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((6 == irqnumber)\n    ||  (6 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER6.all &= ~(1U << GET_PIE_OFFSET_IN_GROUP(irqnumber));\n        IER |= (0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((7 == irqnumber)\n    ||  (7 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER7.all &= ~(1U << GET_PIE_OFFSET_IN_GROUP(irqnumber));\n        IER &= ~(0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((8 == irqnumber)\n    ||  (8 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER8.all &= ~(1 << GET_PIE_OFFSET_IN_GROUP(irqnumber));\n        IER &= ~(0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((9 == irqnumber)\n    ||  (9 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER9.all &= ~(1U << GET_PIE_OFFSET_IN_GROUP(irqnumber));\n        IER &= ~(0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((10 == irqnumber)\n    ||  (10 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER10.all &= ~(1U << GET_PIE_OFFSET_IN_GROUP(irqnumber));\n        IER &= ~(0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((11 == irqnumber)\n    ||  (11 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER11.all &= ~(1U << GET_PIE_OFFSET_IN_GROUP(irqnumber));\n        IER &= ~(0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    else if ((12 == irqnumber)\n    ||  (12 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIER12.all &= ~(1 << GET_PIE_OFFSET_IN_GROUP(irqnumber));\n        IER &= ~(0x1U << GET_PIE_GROUP(irqnumber));\n    }\n    /* CPU Timer 1 */\n    else if (13 == irqnumber)\n    {\n    }\n    /* CPU Timer 2 */\n    else if (14 == irqnumber)\n    {\n    }\n    /* DATALOG */\n    else if (15 == irqnumber)\n    {\n    }\n    /* RTOSINT */\n    else if (16 == irqnumber)\n    {\n    }\n    /* EMUINT */\n    else if (17 == irqnumber)\n    {\n    }\n    /* NMI */\n    else if (18 == irqnumber)\n    {\n    }\n    /* 18 - ILLEGAL, 20 to 31 - User-defined trap */\n    else if ((irqnumber >= 19) && (irqnumber <= 31))\n    {\n    }\n    else\n    {\n        /* do nothing */\n    }\n}\nvoid HWI_TIC28x_EnablePendingIRQ(uint16_T irqnumber)\n{\n    /* Interrupt groups */\n    if ((1 == irqnumber) \n    ||  (1 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIFR1.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        asm(\" RPT #1 || NOP\");               /*wait 1 cycles        */\n    }\n    else if ((2 == irqnumber) \n    || (2 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIFR2.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        asm(\" RPT #1 || NOP\");               /*wait 1 cycles        */\n    }\n    else if ((3 == irqnumber)\n    ||  (3 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIFR3.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        asm(\" RPT #1 || NOP\");               /*wait 1 cycles        */\n    }\n    else if ((4 == irqnumber)\n    ||  (4 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIFR4.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        asm(\" RPT #1 || NOP\");               /*wait 1 cycles        */\n    }\n    else if ((5 == irqnumber)\n    ||  (5 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIFR5.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        asm(\" RPT #1 || NOP\");               /*wait 1 cycles        */\n    }\n    else if ((6 == irqnumber)\n    ||  (6 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIFR6.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        asm(\" RPT #1 || NOP\");               /*wait 1 cycles        */\n    }\n    else if ((7 == irqnumber)\n    ||  (7 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIFR7.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        asm(\" RPT #1 || NOP\");               /*wait 1 cycles        */\n    }\n    else if ((8 == irqnumber)\n    ||  (8 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIFR8.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        asm(\" RPT #1 || NOP\");               /*wait 1 cycles        */\n    }\n    else if ((9 == irqnumber)\n    ||  (9 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIFR9.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        asm(\" RPT #1 || NOP\");               /*wait 1 cycles        */\n    }\n    else if ((10 == irqnumber)\n    ||  (10 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIFR10.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        asm(\" RPT #1 || NOP\");               /*wait 1 cycles        */\n    }\n    else if ((11 == irqnumber)\n    ||  (11 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIFR11.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        asm(\" RPT #1 || NOP\");               /*wait 1 cycles        */\n    }\n    else if ((12 == irqnumber)\n    ||  (12 == GET_PIE_GROUP(irqnumber)+1))\n    {\n        /* Enable PIE interrupt */\n        PieCtrlRegs.PIEIFR12.all |= 1 << GET_PIE_OFFSET_IN_GROUP(irqnumber);\n        asm(\" RPT #1 || NOP\");               /*wait 1 cycles        */\n    }\n    /* CPU Timer 1 */\n    else if (13 == irqnumber)\n    {\n    }\n    /* CPU Timer 2 */\n    else if (14 == irqnumber)\n    {\n    }\n    /* DATALOG */\n    else if (15 == irqnumber)\n    {\n    }\n    /* RTOSINT */\n    else if (16 == irqnumber)\n    {\n    }\n    /* EMUINT */\n    else if (17 == irqnumber)\n    {\n    }\n    /* NMI */\n    else if (18 == irqnumber)\n    {\n    }\n    /* 18 - ILLEGAL, 20 to 31 - User-defined trap */\n    else if ((irqnumber >= 19) && (irqnumber <= 31))\n    {\n    }\n    else\n    {\n        /* do nothing */\n    }\n}\n\nvoid HWI_TIC28x_AcknowledgeIrq(uint16_T irqnumber)\n{\n    /* Acknowledge Corresponding PIE Interrupt groups */\n    uint16_T intrgrp = GET_PIE_GROUP(irqnumber)+1;\n\n    if ((irqnumber>=1 && irqnumber<=12) || (intrgrp>=1 && intrgrp <=12))\n    {\n        PieCtrlRegs.PIEACK.all = 1 << (intrgrp-1);\n    }\n}\n"},{"name":"MW_c28xGPIO.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\c2b\\tic2000_shared\\src","tag":"","groupDisplay":"Other files","code":"/*####################################################\n * FILE: MW_c28xGPIO.c\n * TITLE: GPIO functions to access the GPIO specific registers for C2000 target\n * Copyright 2017-2024 The MathWorks, Inc.\n * ####################################################*/\n\n/* ***************************************************************************/\n/* the includes */\n\n#include \"MW_c28xGPIO.h\"\n#ifdef CPU2\n#ifdef MW_F2837XD\n#include \"MW_f2837xD_includes.h\"\n#endif //MW_F2837XD\n#ifdef MW_F2838X\n#include \"MW_f2838x_includes.h\"\n#endif //MW_F2838X\n#ifdef MW_F28P65X\n#include \"MW_f28p65x_includes.h\"\n#endif //MW_F28P65X\n#endif //CPU2\n\n/* ***************************************************************************/\n/* the defines */\n\n/* ***************************************************************************/\n/* the globals */\n\nUint16 GPIO_oneTimeInit = 0;\n\n/* ***************************************************************************/\n/* the functions*/\nvoid InitGpio(void);\n/* One time initialization of all GPIOs */\nvoid OneTimeGpioInit(void)\n{    \n    if(GPIO_oneTimeInit == 0U)\n    {\n#ifdef CPU1\n        InitGpio();\n#endif //End of CPU1\n        GPIO_oneTimeInit = 1U;\n    }\n}\n\n#ifndef MW_F281X /*GPIO implementation not supported for C281x */\n#ifndef F2837X_REG_FORMAT /*GPIO functions are provided by TI*/\n#ifndef MW_F2804X /*GPIO initialization is provided by TI for F2804x*/\n\n/*Sets all pins to be muxed to GPIO in input mode with pull-ups enabled.\n * Also sets the qualification to synchronous.*/\nvoid InitGpio(void)\n{\n    volatile Uint32 *gpioBaseAddr;\n    Uint16 regOffset;\n    EALLOW;\n    /*Fill all registers with zeros. Writing to each register separately\n     * for all GPIO modules would make this function *very* long. Fortunately,\n     * we'd be writing them all with zeros anyway, so this saves a lot of space.*/\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n    for (regOffset = 0U; regOffset < sizeof(GpioCtrlRegs)/2; regOffset++)\n    {\n        /*Hack to avoid enabling pull-ups on all pins. GPyPUD is offset\n         * 0x0C in each register group of 0x40 words. Since this is a\n         * 32-bit pointer, the addresses must be divided by 2.*/\n        if (regOffset % (0x10/2) != (0x0C/2))\n        {\n            gpioBaseAddr[regOffset] = 0x00000000U;\n        }\n    }\n    \n    gpioBaseAddr = (Uint32 *)&GpioDataRegs;\n    for (regOffset = 0; regOffset < sizeof(GpioDataRegs)/2; regOffset++)\n    {\n        gpioBaseAddr[regOffset] = 0x00000000U;\n    }\n    \n    /* For concerto additional registers needs to be initialized*/\n    #ifdef MW_PIL_TIC2000_CONCERTO\n    /*Fill all registers with zeros. Writing to each register separately\n     * for all GPIO modules would make this function *very* long. Fortunately,\n     * we'd be writing them all with zeros anyway, so this saves a lot of space.*/\n    gpioBaseAddr = (Uint32 *)&GpioG1CtrlRegs;\n    for (regOffset = 0U; regOffset < sizeof(GpioG1CtrlRegs)/2; regOffset++)\n    {\n        /*Hack to avoid enabling pull-ups on all pins. GPyPUD is offset\n         * 0x0C in each register group of 0x40 words. Since this is a\n         * 32-bit pointer, the addresses must be divided by 2.*/\n        if (regOffset % (0x10/2) != (0x0C/2))\n        {\n            gpioBaseAddr[regOffset] = 0x00000000U;\n        }\n    }\n    \n    gpioBaseAddr = (Uint32 *)&GpioG1DataRegs;\n    for (regOffset = 0U; regOffset < sizeof(GpioG1DataRegs)/2; regOffset++)\n    {\n        gpioBaseAddr[regOffset] = 0x00000000U;\n    }\n    #endif //End of MW_PIL_TIC2000_CONCERTO\n    EDIS;\n}\n#endif // End of MW_F2804X\n\n/*Set the peripheral muxing for the specified pin.\n * The appropriate parameters can be found in the GPIO Muxed Pins table.\n * Use the GPIO index row (0 to 4) to select a muxing option for the GPIO.*/\nvoid GPIO_SetupPinMux(Uint16 pin, Uint16 cpu, Uint16 peripheral)\n{\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *mux;\n    Uint16 pin32, pin16;\n    \n    pin32 = pin % 32;\n    pin16 = pin % 16;\n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128U)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n        }\n        else if (pin >=192U && pin <= 199U)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x1080/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x80/2) + (pin/32)*GPY_CTRL_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (pin/32)*GPY_CTRL_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (pin/32)*GPY_CTRL_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    \n    /*Sanity check for valid peripheral values*/\n    if (peripheral > 0x4)\n    {\n        return;\n    }\n    /*Create pointers to the appropriate registers. This is a workaround\n     * for the way GPIO registers are defined. The standard definition\n     * in the header file makes it very easy to do named accesses of one\n     * register or bit, but hard to do arbitrary numerical accesses. It's\n     * easier to have an array of GPIO modules with identical registers,\n     * including arrays for multi-register groups like GPyCSEL1-4. But\n     * the header file doesn't define anything we can turn into an array,\n     * so manual pointer arithmetic is used instead.*/\n    mux = gpioBaseAddr + GPYMUX + pin32/16;\n    \n    //Now for the actual function\n    EALLOW;\n    \n    /* Unfortunately, since we don't know the pin in\n     * advance we can't hardcode a bitfield reference, so there's some tricky\n     * bit twiddling here.*/\n    *mux &= ~(0x3UL << (2*pin16));\n    *mux |= (Uint32)(peripheral & 0x3UL) << (2*pin16);\n    \n    //WARNING: This code does not touch the analog mode select registers,\n    //which are needed to give the USB module control of its IOs.\n    EDIS;\n}\n\n/*Setup up the GPIO input/output options for the specified pin.\n * The flags are a 16-bit mask produced by ORing together options.\n * For input pins, the valid flags are:\n * GPIO_PULLUP    Enable pull-up\n * GPIO_SYNC        Synchronize the input latch to PLLSYSCLK (default -- you don't need to specify this)\n * GPIO_QUAL3    Use 3-sample qualification\n * GPIO_QUAL6    Use 6-sample qualification\n * GPIO_ASYNC    Do not use synchronization or qualification\n * (Note: only one of SYNC, QUAL3, QUAL6, or ASYNC is allowed)\n * For output pins, the valid flags are:\n * GPIO_PULLUP        If open drain enabled, also enable the pull-up\n * and the input qualification flags (SYNC/QUAL3/QUAL6/SYNC) listed above.\n * With no flags, the default input state is synchronous with no pull-up or polarity inversion.\n * The default output state is the standard digital output.*/\nvoid GPIO_SetupPinOptions(Uint16 pin, Uint16 output, Uint16 flags)\n{\n    {\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *dir, *pud, *qsel;\n    Uint32 pin32, pin16, pinMask, qual;\n    \n    pin32 = pin % 32;\n    pin16 = pin % 16;\n    pinMask = 1UL << pin32;\n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128U)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n        }\n        else if (pin >=192U && pin <= 199U)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x1080/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x80/2) + (pin/32)*GPY_CTRL_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (pin/32)*GPY_CTRL_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (pin/32)*GPY_CTRL_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    \n    /*Create pointers to the appropriate registers. This is a workaround\n     * for the way GPIO registers are defined. The standard definition\n     * in the header file makes it very easy to do named accesses of one\n     * register or bit, but hard to do arbitrary numerical accesses. It's\n     * easier to have an array of GPIO modules with identical registers,\n     * including arrays for multi-register groups like GPyQSEL1-2. But\n     * the header file doesn't define anything we can turn into an array,\n     * so manual pointer arithmetic is used instead.*/\n    dir = gpioBaseAddr + GPYDIR;\n    pud = gpioBaseAddr + GPYPUD;\n    qsel = gpioBaseAddr + GPYQSEL + pin32/16;\n    \n    EALLOW;\n    \n    /*Set the data direction*/\n    *dir &= ~pinMask;\n    if (output == 1U)\n    {\n        /*Output, with optional open drain mode and pull-up*/\n        *dir |= pinMask;\n        \n        /*Enable pull-up if necessary. Open drain mode must be active.*/\n        if (flags & GPIO_PULLUP){\n            *pud &= ~pinMask;\n        }\n        else{\n            *pud |= pinMask;\n        }\n    } else\n    {\n        /*Input, with optional pull-up, qualification, and polarity inversion*/\n        *dir &= ~pinMask;\n        \n        /*Enable pull-up if necessary*/\n        if (flags & GPIO_PULLUP){\n            *pud &= ~pinMask;\n        }\n        else{\n            *pud |= pinMask;\n        }\n    }\n    \n    /*Extract the qualification parameter and load it into the register. This is\n     * also needed for open drain outputs, so we might as well do it all the time.*/\n    qual = (flags & GPIO_ASYNC) / GPIO_QUAL3;\n    *qsel &= ~(0x3L << (2 * pin16));\n    if (qual != 0x0){\n        *qsel |= qual << (2 * pin16);\n    }\n    \n    EDIS;\n    }\n}\n\n/*Read the GPyDAT register bit for the specified pin.\n * Note that this returns the actual state of the pin, not the state of the output latch.*/\nUint16 GPIO_ReadPin(Uint16 pin)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint16 pinVal;\n\n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128U)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x40/2);\n        }\n        else if (pin >=192U && pin <= 199U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x10C0/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (0xC0/2) + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    pinVal = (gpioDataReg[GPYDAT] >> (pin % 32)) & 0x1;\n    \n    return pinVal;\n}\n\n/*Set the GPyDAT register bit for the specified pin.*/\nvoid GPIO_WritePin(Uint16 pin, Uint16 outVal)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;\n    \n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128U)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x40/2);\n        }\n        else if (pin >=192U && pin <= 199U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x10C0/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (0xC0/2) + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n\n        #ifdef F28M35x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    pinMask = 1UL << (pin % 32);\n    \n    if (outVal == 0U){        \n        gpioDataReg[GPYCLEAR] = pinMask;\n    }\n    else{\n        gpioDataReg[GPYSET] = pinMask;\n    }\n}\n\n/*Toggle the GPyDAT register bit for the specified pin.*/\nvoid GPIO_TogglePin(Uint16 pin)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;\n    \n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128U)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x40/2);\n        }\n        else if (pin >=192U && pin <= 199U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x10C0/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135U)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (0xC0/2) + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    pinMask = 1UL << (pin % 32);\n    \n    \n    gpioDataReg[GPYTOGGLE] = pinMask;\n\n}\n\n#else // for F2837X_REG_FORMAT\n#if defined(MW_F2838X) \n#if defined(CPU1)\n\nvoid InitGpio(void)\n{\n    volatile Uint32 *gpioBaseAddr;\n    Uint16 regOffset;\n\n    /*Disable pin locks*/\n    EALLOW;\n    GpioCtrlRegs.GPALOCK.all = 0x00000000U;\n    GpioCtrlRegs.GPBLOCK.all = 0x00000000U;\n    GpioCtrlRegs.GPCLOCK.all = 0x00000000U;\n    GpioCtrlRegs.GPDLOCK.all = 0x00000000U;\n    GpioCtrlRegs.GPELOCK.all = 0x00000000U;\n    GpioCtrlRegs.GPFLOCK.all = 0x00000000U;\n\n    /* Fill all registers with zeros. Writing to each register separately\n     * for six GPIO modules would make this function *very* long.\n     * Fortunately, we'd be writing them all with zeros anyway, so this\n     * saves a lot of space.*/\n  \n    gpioBaseAddr = (volatile Uint32 *)&GpioCtrlRegs;\n\n    for (regOffset = 0U; regOffset < sizeof(GpioCtrlRegs)/2; regOffset++)\n    {\n        /* Hack to avoid enabling pull-ups on all pins. GPyPUD is offset\n         * 0x0C in each register group of 0x40 words. Since this is a\n         * 32-bit pointer, the addresses must be divided by 2.*/\n        if (regOffset % (0x40/2) != (0x0C/2))\n        {\n            gpioBaseAddr[regOffset] = 0x00000000U;\n        }\n    }\n\n    gpioBaseAddr = (volatile Uint32 *)&GpioDataRegs;\n    for (regOffset = 0U; regOffset < sizeof(GpioDataRegs)/2; regOffset++)\n    {\n        gpioBaseAddr[regOffset] = 0x00000000U;\n    }\n\n    EDIS;\n}\n\nvoid GPIO_SetupPinMux(Uint16 gpioNumber, Uint16 cpu, Uint16 muxPosition)\n{\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *mux, *gmux, *csel;\n    Uint16 pin32, pin16, pin8;\n\n    pin32 = gpioNumber % 32;\n    pin16 = gpioNumber % 16;\n    pin8 = gpioNumber % 8;\n\n    gpioBaseAddr = (volatile Uint32 *)&GpioCtrlRegs + (gpioNumber / 32) * (GPY_CTRL_OFFSET);\n\n    /*Sanity check for valid cpu and peripheral values*/\n    if (cpu > GPIO_MUX_CM || muxPosition > 0xF)\n    {\n        return;\n    }\n    /* Create pointers to the appropriate registers. This is a workaround\n     * for the way GPIO registers are defined. The standard definition\n     * in the header file makes it very easy to do named accesses of one\n     * register or bit, but hard to do arbitrary numerical accesses. It's\n     * easier to have an array of GPIO modules with identical registers,\n     * including arrays for multi-register groups like GPyCSEL1-4. But\n     * the header file doesn't define anything we can turn into an array,\n     * so manual pointer arithmetic is used instead.*/\n    mux = gpioBaseAddr + GPYMUX + pin32/16;\n    gmux = gpioBaseAddr + GPYGMUX + pin32/16;\n    csel = gpioBaseAddr + GPYCSEL + pin32/8;\n\n    /* Now for the actual function */\n    EALLOW;\n\n    /* To change the muxing, set the peripheral mux to 0/GPIO first to avoid\n     * glitches, then change the group mux, then set the peripheral mux to\n     * its target value. Finally, set the CPU select. This procedure is\n     * described in the TRM. Unfortunately, since we don't know the pin in\n     * advance we can't hardcode a bitfield reference, so there's some\n     * tricky bit twiddling here.*/\n    *mux &= ~(0x3UL << (2*pin16));\n    *gmux &= ~(0x3UL << (2*pin16));\n    *gmux |= (Uint32)((muxPosition >> 2) & 0x3UL) << (2*pin16);\n    *mux |= (Uint32)(muxPosition & 0x3UL) << (2*pin16);\n \n    *csel &= ~((Uint32)((Uint32)0x7u << ((Uint32) (4u * (Uint32)pin8))));\n    *csel |= (Uint32)(cpu & 0x7L) << (4*pin8);\n\n    /* WARNING: This code does not touch the analog mode select registers,\n     * which are needed to give the USB module control of its IOs.*/\n    EDIS;\n}\n\nvoid GPIO_SetupPinOptions(Uint16 gpioNumber, Uint16 output, Uint16 flags)\n{\n\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *dir, *pud, *inv, *odr, *qsel;\n    Uint32 pin32, pin16, pinMask, qual;\n\n    pin32 = gpioNumber % 32;\n    pin16 = gpioNumber % 16;\n    pinMask = 1UL << pin32;\n\n    gpioBaseAddr = (volatile Uint32 *)&GpioCtrlRegs + (gpioNumber / 32) * (GPY_CTRL_OFFSET);\n    \n\n    /* Create pointers to the appropriate registers. This is a workaround\n     * for the way GPIO registers are defined. The standard definition\n     * in the header file makes it very easy to do named accesses of one\n     * register or bit, but hard to do arbitrary numerical accesses. It's\n     * easier to have an array of GPIO modules with identical registers,\n     * including arrays for multi-register groups like GPyQSEL1-4. But\n     * the header file doesn't define anything we can turn into an array,\n     * so manual pointer arithmetic is used instead.*/\n    dir = gpioBaseAddr + GPYDIR;\n    pud = gpioBaseAddr + GPYPUD;\n    inv = gpioBaseAddr + GPYINV;\n    odr = gpioBaseAddr + GPYODR;\n    qsel = gpioBaseAddr + GPYQSEL + pin32/16;\n\n    EALLOW;\n\n    /*Set the data direction*/\n    *dir &= ~pinMask;\n    if (output == 1)\n    {        \n        /* Output, with optional open drain mode and pull-up */        \n        *dir |= pinMask;\n\n        /* Enable open drain if necessary */\n        if (flags & GPIO_OPENDRAIN)\n        {\n            *odr |= pinMask;\n        }\n        else\n        {\n            *odr &= ~pinMask;\n        }\n\n        /* Enable pull-up if necessary. Open drain mode must be active. */\n        if (flags & (GPIO_OPENDRAIN | GPIO_PULLUP))\n        {\n            *pud &= ~pinMask;\n        }\n        else\n        {\n            *pud |= pinMask;\n        }\n    }\n    else\n    {\n        /* Input, with optional pull-up, qualification, and polarity\n         * inversion */\n        *dir &= ~pinMask;\n\n        /* Enable pull-up if necessary */\n        if (flags & GPIO_PULLUP)\n        {\n            *pud &= ~pinMask;\n        }\n        else\n        {\n            *pud |= pinMask;\n        }\n\n        /* Invert polarity if necessary */\n        if (flags & GPIO_INVERT)\n        {\n            *inv |= pinMask;\n        }\n        else\n        {\n            *inv &= ~pinMask;\n        }\n    }\n\n    /* Extract the qualification parameter and load it into the register.\n     * This is also needed for open drain outputs, so we might as well do it\n     * all the time. */\n    qual = (flags & GPIO_ASYNC) / GPIO_QUAL3;\n    *qsel &= ~((Uint32)0x3L << (2 * (Uint32)pin16));\n    if (qual != 0x0)\n    {\n        *qsel |= qual << (2 * pin16);\n    }\n\n    EDIS;\n}\n\nvoid GPIO_EnablePullups176Pin(void)\n{\n    EALLOW;\n    GpioCtrlRegs.GPCPUD.all = ~0x80000000U;  /* GPIO 95 */\n    GpioCtrlRegs.GPDPUD.all = ~0xFFFFFFF7U;  /* GPIOs 96-127 */\n    GpioCtrlRegs.GPEPUD.all = ~0xFFFFFFDFU;  /* GPIOs 128-159 except for 133 */\n    GpioCtrlRegs.GPFPUD.all = ~0x000001FFU;  /* GPIOs 160-168 */\n    EDIS;\n}\n\nvoid GPIO_EnablePullups100Pin(void)\n{\n    EALLOW;\n    GpioCtrlRegs.GPAPUD.all = ~0xFFC003E3U;  // GPIOs 0-1, 5-9, 22-31\n    GpioCtrlRegs.GPBPUD.all = ~0x03FFF1FFU;  // GPIOs 32-40, 44-57\n    GpioCtrlRegs.GPCPUD.all = ~0xE10FBC18U;  // GPIOs 67-68, 74-77, 79-83, 93-95\n    GpioCtrlRegs.GPDPUD.all = ~0xFFFFFFF7U;  // GPIOs 96-127\n    GpioCtrlRegs.GPEPUD.all = ~0xFFFFFFFFU;  // GPIOs 128-159\n    GpioCtrlRegs.GPFPUD.all = ~0x000001FFU;  // GPIOs 160-168\n    EDIS;\n}\n\nvoid GPIO_EnableUnbondedIOPullups(void)\n{\n\t/* bits 8-10 have pin count */\n    unsigned char pin_count = ((DevCfgRegs.PARTIDL.all & 0x00000700U) >> 8U) ;\n\n\t/* 5 = 100 pin\n\t * 6 = 176 pin\n\t * 7 = 337 pin */\n    if(pin_count == 5)\n    {\n        GPIO_EnablePullups100Pin();\n    }\n    else if (pin_count == 6)\n    {\n\t\tGPIO_EnablePullups176Pin();\n    }\n    else\n    {\n\t\t/* do nothing - this is 337 pin package */\n    }\n}\n#endif // defined(CPU1)\n/*Read the GPyDAT register bit for the specified pin.\n * Note that this returns the actual state of the pin, not the state of the output latch.*/\nUint16 GPIO_ReadPin(Uint16 pin)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint16 pinVal;\n\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    pinVal = (gpioDataReg[GPYDAT] >> (pin % 32)) & 0x1U;\n    \n    return pinVal;\n}\n\n/*Set the GPyDAT register bit for the specified pin.*/\nvoid GPIO_WritePin(Uint16 pin, Uint16 outVal)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;\n    \n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    pinMask = 1UL << (pin % 32);\n    \n    if (outVal == 0U)\n    {\n        gpioDataReg[GPYCLEAR] = pinMask;\n    }\n    else\n    {\n        gpioDataReg[GPYSET] = pinMask;\n    }\n}\n\n#endif // end of defined(MW_F2838X)\n\n/*Toggle the GPyDAT register bit for the specified pin.*/\nvoid GPIO_TogglePin(Uint16 pin)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;    \n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + ((pin/32)*GPY_DATA_OFFSET);\n    Uint32 temp = (1UL << (pin % 32U));\n    pinMask = (Uint32)temp;\n    gpioDataReg[GPYTOGGLE] = pinMask;\n}\n#endif // end of F2837X_REG_FORMAT\n\n/*Set the GPIO pin. Set the mux values and pin options for the specified pin.\n  This function can be used for all processors except C281x. The implementation is dependant on CPU1 and CPU2*/ \nvoid Set_GPIOPin(Uint16 pin, Uint16 cpu, Uint16 peripheral, Uint16 output, Uint16 flags)\n{\n#if defined(F2837X_REG_FORMAT) && defined(CPU2)\n    Uint32 *pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n    Uint32 gpioData = 0x00000000;\n    //Sanity check for valid cpu and peripheral values\n    #ifdef MW_F28P65X\n        if (peripheral > 0xFU)\n            return;\n    #else\n        if (cpu > GPIO_MUX_CPU2CLA || peripheral > 0xFU)\n            return;\n    #endif\n    gpioData = gpioData | pin;\n    gpioData = gpioData | ((Uint32)peripheral << 8U);\n    gpioData = gpioData | ((Uint32)output << 16U);\n    gpioData = gpioData | ((Uint32)flags << 24U);\n    #ifdef MW_F2837XD\n    Uint32 ulRWord32 = 0;\n    IPCLiteLtoRFunctionCall(IPC_FLAG0, pulMsgRam[0], gpioData, IPC_FLAG31);\n    while (IPCLiteLtoRGetResult(&ulRWord32,IPC_LENGTH_32_BITS,\n            IPC_FLAG31) != STATUS_PASS)\n    {\n    }\n    #else\n     MW_IPC_sendCommand(IPC_CPU2_L_CPU1_R, (IPC_FLAG0 | IPC_FLAG31), IPC_ADDR_CORRECTION_DISABLE, IPC_FUNC_CALL, pulMsgRam[0], gpioData);\n    IPC_waitForAck(IPC_CPU2_L_CPU1_R, IPC_FLAG31);\n    IPC_getResponse(IPC_CPU2_L_CPU1_R);\n    #endif //MW_F2837XD\n#else\n    GPIO_SetupPinMux(pin, cpu, peripheral);\n    GPIO_SetupPinOptions(pin, output, flags);\n#endif // end of defined(F2837X_REG_FORMAT) && defined(CPU2)\n}\n#endif //end of MW_F281X\n    \n"},{"name":"MW_c28xGlobalInterrupts.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\c2b\\tic2000_shared\\src","tag":"","groupDisplay":"Other files","code":"/*####################################################\n * FILE: MW_c28xGlobalInterrupts.c\n * TITLE: Common board support functions specific for C2000 targets\n * Copyright 2020-2024 The MathWorks, Inc.\n * ####################################################*/\n\n/* ***************************************************************************/\n/* the includes */\n#include \"MW_target_hardware_resources.h\"\n\n/* ***************************************************************************/\n/* the globals */\nvolatile int16_T MW_InterruptDisableLock = 0;\n\n\n/* ***************************************************************************/\n/* the functions*/\n\n/* Global interrupt enable function */\nvoid globalInterruptEnable(void)\n{\n    if (0 == MW_InterruptDisableLock)\n    {\n        /* Enabled the interrupts only if it was enabled before */\n        __enable_interrupts(); /* Enable Global Interrupt INTM and realtime interrupt DBGM */\n        return;\n    }\n    --MW_InterruptDisableLock;\n    \n}\n\n/* Global interrupt disable function */\nvoid globalInterruptDisable(void)\n{\n    /* Disable Global Interrupt INTM using __disable_interrupts()\n     The function will return 0 if interrupt was enabled previously\n     otherwise it will return 1 if the interrupt was previously disabled*/\n    MW_InterruptDisableLock += ((__disable_interrupts()) & 0x01);\n}\n"},{"name":"MW_c28xSPI.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\c2b\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"/*####################################################\n * FILE: MW_c28xSPI.c\n * TITLE: SPI functions to access the SPI specific registers for C2000 target\n * Copyright 2017-2024 The MathWorks, Inc.\n * ####################################################*/\n\n/* ***************************************************************************/\n/* the includes */\n\n#include \"MW_c28xSPI.h\"\n#if defined(MW_SIMULINK_IO) && MW_SIMULINK_IO == 1\n#include \"peripheralIncludes.h\"\n#endif\n/* ***************************************************************************/\n/* the defines */\n\n/* ***************************************************************************/\n/* the globals */\n\nUint16 SPI_oneTimeInit[4] = {0, 0, 0, 0};\nMW_SpiObj mySpiObj[MW_MAX_SPI_MODULE];\n\n/* ***************************************************************************/\n/* the functions */\n\n/*Initialize the SPI registers*/\nMW_SpiHandle SPI_init(Uint32 SPIModule)\n{\n    Uint16 priority;\n    MW_SpiHandle SPI_obj = (MW_SpiHandle)&mySpiObj[SPIModule];\n    /* Assign used SPI modules to CPU1 */\n#if defined(IO_AUTOGEN_SPIBLOCK) && (defined(F2837xD) || defined(F2838x) || defined(F28p65x))\n     EALLOW;\n    #ifdef MW_SPI_A\n      DevCfgRegs.CPUSEL6.bit.SPI_A = 0U;\n    #endif\n    #ifdef MW_SPI_B\n      DevCfgRegs.CPUSEL6.bit.SPI_B = 0U;\n    #endif\n    #ifdef MW_SPI_C\n      DevCfgRegs.CPUSEL6.bit.SPI_C = 0U;\n    #endif\n    #ifdef MW_SPI_D\n      DevCfgRegs.CPUSEL6.bit.SPI_D = 0U;    \n    #endif\n    EDIS;\n#endif\n#ifdef F2837X_REG_FORMAT\n    EALLOW;\n    #ifdef MW_SPI_A\n    CpuSysRegs.PCLKCR8.bit.SPI_A = 1;\n    #endif\n    #ifdef MW_SPI_B\n    CpuSysRegs.PCLKCR8.bit.SPI_B = 1;\n    #endif\n    #ifdef MW_SPI_C\n    CpuSysRegs.PCLKCR8.bit.SPI_C = 1;\n    #endif\n    #ifdef MW_SPI_D\n    CpuSysRegs.PCLKCR8.bit.SPI_D = 1;\n    #endif\n    EDIS;\n#endif\n    \n#ifdef MW_F281X\n            if (SPI_oneTimeInit[0] == 0)\n            {\n                SPI_obj->spi_base_address = (SPI_REG_ADDRESS)&SpiaRegs;\n                SPI_obj->spi_clk_mode = 0;\n                SPI_obj->charLength = 0;\n                SPI_obj->fifoLevel = MW_SPI_FIFO_LEVEL;\n                SPI_obj->txInterrupt = MW_SPI_TXINTERRUPTENABLE;\n                if (MW_SPI_SUSPENSIONMODE == 0)\n                {\n                    priority = 0;\n                }\n                else if (MW_SPI_SUSPENSIONMODE == 1)\n                {\n                    priority = 2;\n                }\n                else\n                {\n                    priority = 1;\n                }\n                /*TRIWIRE - Controller, Peripheral In Controller Out / Peripheral, Peripheral Out Controller In */\n                EALLOW;\n                GpioMuxRegs.GPFMUX.all|=0x0007;      /* Select GPIOs to be SPI pins, Port F MUX - x000 0000 0000 0111*/\n                GpioMuxRegs.GPFMUX.all|=0x0008;      /* Select GPIOs to be SPISTE pin, Port F MUX - x000 0000 0000 1000*/\n                EDIS;\n                \n                *((SPI_obj->spi_base_address) + SPICCR_REG_OFFSET) &= (~(SPICCR_SPISWRESET_BITS << SPICCR_SPISWRESET_SHIFT));\n                *((SPI_obj->spi_base_address) + SPICCR_REG_OFFSET) |= (Uint16)((MW_SPI_ENABLELOOPBACK & SPICCR_SPILBK_BITS) << SPICCR_SPILBK_SHIFT);\n                *((SPI_obj->spi_base_address) + SPICTL_REG_OFFSET) |= (Uint16)(((~MW_SPI_MODE) & SPICTL_MASTER_SLAVE_BITS) << SPICTL_MASTER_SLAVE_SHIFT);\n                *((SPI_obj->spi_base_address) + SPICTL_REG_OFFSET) |= (Uint16)((SPICTL_TALK_BITS) << SPICTL_TALK_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIBRR_REG_OFFSET) |= (Uint16)(((Uint16)MW_SPI_BAUDRATEFACTOR & SPIBRR_SPI_BIT_RATE_BITS) << SPIBRR_SPI_BIT_RATE_SHIFT);\n\n                *((SPI_obj->spi_base_address) + SPIPRI_REG_OFFSET) |= (Uint16)((priority & SPIPRI_SOFT_FREE_BITS) << SPIPRI_SOFT_FREE_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIFFTX_REG_OFFSET) |= ((SPIFFTX_SPIFFENA_BITS) << SPIFFTX_SPIFFENA_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIFFCT_REG_OFFSET) |= ((MW_SPI_FIFOTRANSMITDELAY & SPIFFCT_TXDLY_BITS) << SPIFFCT_TXDLY_SHIFT);\n\n                /* Set the TX Interrupt FIFO level only at the init. Enable the FIFO interrupt only after TX buffer is full */\n                *((SPI_obj->spi_base_address) + SPIFFTX_REG_OFFSET) |= ((MW_SPI_FIFOINTERRUPTLEVEL_TX & SPIFFTX_TXFFIL_BITS) << SPIFFTX_TXFFIL_SHIFT);\n\n                *((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) &= (~(SPIFFRX_RXFFIL_BITS << SPIFFRX_RXFFIL_SHIFT));\n                *((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) |= ((MW_SPI_FIFOINTERRUPTLEVEL_RX & SPIFFRX_RXFFIL_BITS) << SPIFFRX_RXFFIL_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) |= (SPIFFRX_RXFFINTCLR_BITS << SPIFFRX_RXFFINTCLR_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) |= ((MW_SPI_RXINTERRUPTENABLE & SPIFFRX_RXFFIENA_BITS) << SPIFFRX_RXFFIENA_SHIFT);\n\n                *((SPI_obj->spi_base_address) + SPICCR_REG_OFFSET) |= (Uint16)(SPICCR_SPISWRESET_BITS << SPICCR_SPISWRESET_SHIFT);\n                SPI_oneTimeInit[0] = 1;\n            }            \n#else //Else of MW_F281X\n    switch(SPIModule)\n    {\n        case 0: //SPI Module A\n        {\n#ifdef MW_SPI_A\n            if (SPI_oneTimeInit[0] == 0)\n            {\n                SPI_obj->spi_base_address = (SPI_REG_ADDRESS)&SpiaRegs;\n                SPI_obj->spi_clk_mode = 0;\n                SPI_obj->charLength = 0;\n                SPI_obj->fifoLevel = MW_SPI_A_FIFO_LEVEL;\n                SPI_obj->txInterrupt = MW_SPI_A_TXINTERRUPTENABLE;\n                if (MW_SPI_A_SUSPENSIONMODE == 0)\n                {\n                    priority = 0;\n                }\n                else if (MW_SPI_A_SUSPENSIONMODE == 1)\n                {\n                    priority = 2;\n                }\n                else\n                {\n                    priority = 1;\n                }\n                /*TRIWIRE - Controller, Peripheral In Controller Out / Peripheral, Peripheral Out Controller In */\n#ifdef MW_SPI_A_ENABLETHREEWIRE\n    #if  MW_SPI_A_ENABLETHREEWIRE == 1\n        #if MW_SPI_A_MODE == 0\n                Set_GPIOPin(MW_SPI_A_PINVALUE_SIMO, GPIO_MUX_CPU1, MW_SPI_A_PINMUX_SIMO, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC);\n        #else //MW_SPI_A_MODE 1\n               Set_GPIOPin(MW_SPI_A_PINVALUE_SOMI, GPIO_MUX_CPU1, MW_SPI_A_PINMUX_SOMI, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC);\n        #endif //MW_SPI_A_MODE\n    #else // MW_SPI_A_ENABLETHREEWIRE 0\n        #if MW_SPI_A_MODE == 0\n                Set_GPIOPin(MW_SPI_A_PINVALUE_SIMO, GPIO_MUX_CPU1, MW_SPI_A_PINMUX_SIMO, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC);\n                Set_GPIOPin(MW_SPI_A_PINVALUE_SOMI, GPIO_MUX_CPU1, MW_SPI_A_PINMUX_SOMI, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC);\n        #else //MW_SPI_A_MODE 1\n                Set_GPIOPin(MW_SPI_A_PINVALUE_SIMO, GPIO_MUX_CPU1, MW_SPI_A_PINMUX_SIMO, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC);\n                Set_GPIOPin(MW_SPI_A_PINVALUE_SOMI, GPIO_MUX_CPU1, MW_SPI_A_PINMUX_SOMI, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC);\n        #endif //MW_SPI_A_MODE\n    #endif\n#else //MW_SPI_A_ENABLETHREEWIRE not defined\n    #if MW_SPI_A_MODE == 0\n                Set_GPIOPin(MW_SPI_A_PINVALUE_SIMO, GPIO_MUX_CPU1, MW_SPI_A_PINMUX_SIMO, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC);\n                Set_GPIOPin(MW_SPI_A_PINVALUE_SOMI, GPIO_MUX_CPU1, MW_SPI_A_PINMUX_SOMI, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC);\n    #else //MW_SPI_A_MODE 1\n                Set_GPIOPin(MW_SPI_A_PINVALUE_SIMO, GPIO_MUX_CPU1, MW_SPI_A_PINMUX_SIMO, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC);\n                Set_GPIOPin(MW_SPI_A_PINVALUE_SOMI, GPIO_MUX_CPU1, MW_SPI_A_PINMUX_SOMI, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC);\n    #endif //MW_SPI_A_MODE\n#endif // End of MW_SPI_A_ENABLETHREEWIRE\n                \n#if MW_SPI_A_MODE == 0\n                Set_GPIOPin(MW_SPI_A_PINVALUE_CLK, GPIO_MUX_CPU1, MW_SPI_A_PINMUX_CLK, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC); \n#else //MW_SPI_A_MODE 1\n                Set_GPIOPin(MW_SPI_A_PINVALUE_CLK, GPIO_MUX_CPU1, MW_SPI_A_PINMUX_CLK, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC); \n#endif //MW_SPI_A_MODE\n\n#ifdef MW_SPISTE_SELECT_SPI_A\n                if (MW_SPI_A_PINVALUE_STE >= 0)\n                {\n#if MW_SPI_A_MODE == 0\n                   Set_GPIOPin(MW_SPI_A_PINVALUE_STE, GPIO_MUX_CPU1, MW_SPI_A_PINMUX_STE, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC); \n#else //MW_SPI_A_MODE 1\n                   Set_GPIOPin(MW_SPI_A_PINVALUE_STE, GPIO_MUX_CPU1, MW_SPI_A_PINMUX_STE, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC); \n#endif //MW_SPI_A_MODE\n                }\n#endif //End of MW_SPISTE_SELECT_SPI_A\n                \n                *((SPI_obj->spi_base_address) + SPICCR_REG_OFFSET) &= (~(SPICCR_SPISWRESET_BITS << SPICCR_SPISWRESET_SHIFT));\n                *((SPI_obj->spi_base_address) + SPICCR_REG_OFFSET) |= (Uint16)((MW_SPI_A_ENABLELOOPBACK & SPICCR_SPILBK_BITS) << SPICCR_SPILBK_SHIFT);\n\t\t\t\t#ifdef MW_SPI_A_ENABLEHIGHSPEEDMODE\n                *((SPI_obj->spi_base_address) + SPICCR_REG_OFFSET) |= (Uint16)((MW_SPI_A_ENABLEHIGHSPEEDMODE & SPICCR_HS_MODE_BITS) << SPICCR_HS_MODE_SHIFT);\n\t\t\t\t#endif\n                *((SPI_obj->spi_base_address) + SPICTL_REG_OFFSET) |= (Uint16)(((~MW_SPI_A_MODE) & SPICTL_MASTER_SLAVE_BITS) << SPICTL_MASTER_SLAVE_SHIFT);\n                *((SPI_obj->spi_base_address) + SPICTL_REG_OFFSET) |= (Uint16)((SPICTL_TALK_BITS) << SPICTL_TALK_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIBRR_REG_OFFSET) |= (Uint16)(((Uint16)MW_SPI_A_BAUDRATEFACTOR & SPIBRR_SPI_BIT_RATE_BITS) << SPIBRR_SPI_BIT_RATE_SHIFT);\n#ifdef MW_SPI_A_ENABLETHREEWIRE\n                *((SPI_obj->spi_base_address) + SPIPRI_REG_OFFSET) |= (Uint16)((MW_SPI_A_ENABLETHREEWIRE & SPIPRI_TRIWIRE_BITS) << SPIPRI_TRIWIRE_SHIFT);\n#endif // End of MW_SPI_A_ENABLETHREEWIRE\n                *((SPI_obj->spi_base_address) + SPIPRI_REG_OFFSET) |= (Uint16)((priority & SPIPRI_SOFT_FREE_BITS) << SPIPRI_SOFT_FREE_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIFFTX_REG_OFFSET) |= ((SPIFFTX_SPIFFENA_BITS) << SPIFFTX_SPIFFENA_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIFFCT_REG_OFFSET) |= ((MW_SPI_A_FIFOTRANSMITDELAY & SPIFFCT_TXDLY_BITS) << SPIFFCT_TXDLY_SHIFT);\n\n                /* Set the TX Interrupt FIFO level only at the init. Enable the FIFO interrupt only after TX buffer is full */\n                *((SPI_obj->spi_base_address) + SPIFFTX_REG_OFFSET) |= ((MW_SPI_A_FIFOINTERRUPTLEVEL_TX & SPIFFTX_TXFFIL_BITS) << SPIFFTX_TXFFIL_SHIFT);\n\n                *((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) &= (~(SPIFFRX_RXFFIL_BITS << SPIFFRX_RXFFIL_SHIFT));\n                *((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) |= ((MW_SPI_A_FIFOINTERRUPTLEVEL_RX & SPIFFRX_RXFFIL_BITS) << SPIFFRX_RXFFIL_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) |= (SPIFFRX_RXFFINTCLR_BITS << SPIFFRX_RXFFINTCLR_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) |= ((MW_SPI_A_RXINTERRUPTENABLE & SPIFFRX_RXFFIENA_BITS) << SPIFFRX_RXFFIENA_SHIFT);\n\n                *((SPI_obj->spi_base_address) + SPICCR_REG_OFFSET) |= (Uint16)(SPICCR_SPISWRESET_BITS << SPICCR_SPISWRESET_SHIFT);\n                SPI_oneTimeInit[0] = 1;\n            }\n#else\n            SPI_obj->spi_base_address = (SPI_REG_ADDRESS)0;\n            SPI_obj->spi_clk_mode = 0;\n            SPI_obj->charLength = 0;\n            SPI_obj->fifoLevel = 0;\n            SPI_obj->txInterrupt = 0;\n#endif //End of MW_SPI_A\n        }\n        break;\n        \n        case 1: //SPI Module B\n        {\n#ifdef MW_SPI_B\n            if (SPI_oneTimeInit[1] == 0)\n            {\n                SPI_obj->spi_base_address = (SPI_REG_ADDRESS)&SpibRegs;\n                SPI_obj->spi_clk_mode = 0;\n                SPI_obj->charLength = 0;\n                SPI_obj->fifoLevel = MW_SPI_B_FIFO_LEVEL;\n                SPI_obj->txInterrupt = MW_SPI_B_TXINTERRUPTENABLE;\n                if (MW_SPI_B_SUSPENSIONMODE == 0)\n                {\n                    priority = 0;\n                }\n                else if (MW_SPI_B_SUSPENSIONMODE == 1)\n                {\n                    priority = 2;\n                }\n                else\n                {\n                    priority = 1;\n                }\n                /*TRIWIRE - Controller, Peripheral In Controller Out / Peripheral, Peripheral Out Controller In */\n#ifdef MW_SPI_B_ENABLETHREEWIRE\n    #if  MW_SPI_B_ENABLETHREEWIRE == 1\n        #if MW_SPI_B_MODE == 0\n                Set_GPIOPin(MW_SPI_B_PINVALUE_SIMO, GPIO_MUX_CPU1, MW_SPI_B_PINMUX_SIMO, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC);\n        #else //MW_SPI_B_MODE 1\n               Set_GPIOPin(MW_SPI_B_PINVALUE_SOMI, GPIO_MUX_CPU1, MW_SPI_B_PINMUX_SOMI, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC);\n        #endif //MW_SPI_B_MODE\n    #else // MW_SPI_B_ENABLETHREEWIRE 0\n        #if MW_SPI_B_MODE == 0\n                Set_GPIOPin(MW_SPI_B_PINVALUE_SIMO, GPIO_MUX_CPU1, MW_SPI_B_PINMUX_SIMO, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC);\n                Set_GPIOPin(MW_SPI_B_PINVALUE_SOMI, GPIO_MUX_CPU1, MW_SPI_B_PINMUX_SOMI, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC);\n        #else //MW_SPI_B_MODE 1\n                Set_GPIOPin(MW_SPI_B_PINVALUE_SIMO, GPIO_MUX_CPU1, MW_SPI_B_PINMUX_SIMO, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC);\n                Set_GPIOPin(MW_SPI_B_PINVALUE_SOMI, GPIO_MUX_CPU1, MW_SPI_B_PINMUX_SOMI, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC);\n        #endif //MW_SPI_B_MODE\n    #endif\n#else //MW_SPI_B_ENABLETHREEWIRE not defined\n    #if MW_SPI_B_MODE == 0\n                Set_GPIOPin(MW_SPI_B_PINVALUE_SIMO, GPIO_MUX_CPU1, MW_SPI_B_PINMUX_SIMO, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC);\n                Set_GPIOPin(MW_SPI_B_PINVALUE_SOMI, GPIO_MUX_CPU1, MW_SPI_B_PINMUX_SOMI, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC);\n    #else //MW_SPI_B_MODE 1\n                Set_GPIOPin(MW_SPI_B_PINVALUE_SIMO, GPIO_MUX_CPU1, MW_SPI_B_PINMUX_SIMO, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC);\n                Set_GPIOPin(MW_SPI_B_PINVALUE_SOMI, GPIO_MUX_CPU1, MW_SPI_B_PINMUX_SOMI, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC);\n    #endif //MW_SPI_B_MODE\n#endif // End of MW_SPI_B_ENABLETHREEWIRE\n                \n#if MW_SPI_B_MODE == 0\n                Set_GPIOPin(MW_SPI_B_PINVALUE_CLK, GPIO_MUX_CPU1, MW_SPI_B_PINMUX_CLK, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC); \n#else //MW_SPI_B_MODE 1\n                Set_GPIOPin(MW_SPI_B_PINVALUE_CLK, GPIO_MUX_CPU1, MW_SPI_B_PINMUX_CLK, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC); \n#endif //MW_SPI_B_MODE\n\n#ifdef MW_SPISTE_SELECT_SPI_B\n                if (MW_SPI_B_PINVALUE_STE >= 0)\n                {\n#if MW_SPI_B_MODE == 0\n                   Set_GPIOPin(MW_SPI_B_PINVALUE_STE, GPIO_MUX_CPU1, MW_SPI_B_PINMUX_STE, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC); \n#else //MW_SPI_B_MODE 1\n                   Set_GPIOPin(MW_SPI_B_PINVALUE_STE, GPIO_MUX_CPU1, MW_SPI_B_PINMUX_STE, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC); \n#endif //MW_SPI_B_MODE\n                }\n#endif //End of MW_SPISTE_SELECT_SPI_B\n                \n                *((SPI_obj->spi_base_address) + SPICCR_REG_OFFSET) &= (~(SPICCR_SPISWRESET_BITS << SPICCR_SPISWRESET_SHIFT));\n                *((SPI_obj->spi_base_address) + SPICCR_REG_OFFSET) |= (Uint16)((MW_SPI_B_ENABLELOOPBACK & SPICCR_SPILBK_BITS) << SPICCR_SPILBK_SHIFT);\n\t\t\t\t#ifdef MW_SPI_B_ENABLEHIGHSPEEDMODE\n                *((SPI_obj->spi_base_address) + SPICCR_REG_OFFSET) |= (Uint16)((MW_SPI_B_ENABLEHIGHSPEEDMODE & SPICCR_HS_MODE_BITS) << SPICCR_HS_MODE_SHIFT);\n\t\t\t\t#endif\n                *((SPI_obj->spi_base_address) + SPICTL_REG_OFFSET) |= (Uint16)(((~MW_SPI_B_MODE) & SPICTL_MASTER_SLAVE_BITS) << SPICTL_MASTER_SLAVE_SHIFT);\n                *((SPI_obj->spi_base_address) + SPICTL_REG_OFFSET) |= (Uint16)((SPICTL_TALK_BITS) << SPICTL_TALK_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIBRR_REG_OFFSET) |= (Uint16)(((Uint16)MW_SPI_B_BAUDRATEFACTOR & SPIBRR_SPI_BIT_RATE_BITS) << SPIBRR_SPI_BIT_RATE_SHIFT);\n#ifdef MW_SPI_B_ENABLETHREEWIRE\n                *((SPI_obj->spi_base_address) + SPIPRI_REG_OFFSET) |= (Uint16)((MW_SPI_B_ENABLETHREEWIRE & SPIPRI_TRIWIRE_BITS) << SPIPRI_TRIWIRE_SHIFT);\n#endif // End of MW_SPI_B_ENABLETHREEWIRE\n                *((SPI_obj->spi_base_address) + SPIPRI_REG_OFFSET) |= (Uint16)((priority & SPIPRI_SOFT_FREE_BITS) << SPIPRI_SOFT_FREE_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIFFTX_REG_OFFSET) |= ((SPIFFTX_SPIFFENA_BITS) << SPIFFTX_SPIFFENA_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIFFCT_REG_OFFSET) |= ((MW_SPI_B_FIFOTRANSMITDELAY & SPIFFCT_TXDLY_BITS) << SPIFFCT_TXDLY_SHIFT);\n\n                /* Set the TX Interrupt FIFO level only at the init. Enable the FIFO interrupt only after TX buffer is full */\n                *((SPI_obj->spi_base_address) + SPIFFTX_REG_OFFSET) |= ((MW_SPI_B_FIFOINTERRUPTLEVEL_TX & SPIFFTX_TXFFIL_BITS) << SPIFFTX_TXFFIL_SHIFT);\n\n                *((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) &= (~(SPIFFRX_RXFFIL_BITS << SPIFFRX_RXFFIL_SHIFT));\n                *((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) |= ((MW_SPI_B_FIFOINTERRUPTLEVEL_RX & SPIFFRX_RXFFIL_BITS) << SPIFFRX_RXFFIL_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) |= (SPIFFRX_RXFFINTCLR_BITS << SPIFFRX_RXFFINTCLR_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) |= ((MW_SPI_B_RXINTERRUPTENABLE & SPIFFRX_RXFFIENA_BITS) << SPIFFRX_RXFFIENA_SHIFT);\n\n                *((SPI_obj->spi_base_address) + SPICCR_REG_OFFSET) |= (Uint16)(SPICCR_SPISWRESET_BITS << SPICCR_SPISWRESET_SHIFT);\n                SPI_oneTimeInit[1] = 1;\n            }\n#else\n            SPI_obj->spi_base_address = (SPI_REG_ADDRESS)0;\n            SPI_obj->spi_clk_mode = 0;\n            SPI_obj->charLength = 0;\n            SPI_obj->fifoLevel = 0;\n            SPI_obj->txInterrupt = 0;\n#endif // End of MW_SPI_B\n        }\n        break;\n        case 2: //SPI Module C\n        {\n#ifdef MW_SPI_C\n            if (SPI_oneTimeInit[2] == 0)\n            {\n                SPI_obj->spi_base_address = (SPI_REG_ADDRESS)&SpicRegs;\n                SPI_obj->spi_clk_mode = 0;\n                SPI_obj->charLength = 0;\n                SPI_obj->fifoLevel = MW_SPI_C_FIFO_LEVEL;\n                SPI_obj->txInterrupt = MW_SPI_C_TXINTERRUPTENABLE;\n                if (MW_SPI_C_SUSPENSIONMODE == 0)\n                {\n                    priority = 0;\n                }\n                else if (MW_SPI_C_SUSPENSIONMODE == 1)\n                {\n                    priority = 2;\n                }\n                else\n                {\n                    priority = 1;\n                }\n                /*TRIWIRE - Controller, Peripheral In Controller Out / Peripheral, Peripheral Out Controller In */\n#ifdef MW_SPI_C_ENABLETHREEWIRE\n    #if  MW_SPI_C_ENABLETHREEWIRE == 1\n        #if MW_SPI_C_MODE == 0\n                Set_GPIOPin(MW_SPI_C_PINVALUE_SIMO, GPIO_MUX_CPU1, MW_SPI_C_PINMUX_SIMO, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC);\n        #else //MW_SPI_C_MODE 1\n               Set_GPIOPin(MW_SPI_C_PINVALUE_SOMI, GPIO_MUX_CPU1, MW_SPI_C_PINMUX_SOMI, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC);\n        #endif //MW_SPI_C_MODE\n    #else // MW_SPI_C_ENABLETHREEWIRE 0\n        #if MW_SPI_C_MODE == 0\n                Set_GPIOPin(MW_SPI_C_PINVALUE_SIMO, GPIO_MUX_CPU1, MW_SPI_C_PINMUX_SIMO, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC);\n                Set_GPIOPin(MW_SPI_C_PINVALUE_SOMI, GPIO_MUX_CPU1, MW_SPI_C_PINMUX_SOMI, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC);\n        #else //MW_SPI_C_MODE 1\n                Set_GPIOPin(MW_SPI_C_PINVALUE_SIMO, GPIO_MUX_CPU1, MW_SPI_C_PINMUX_SIMO, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC);\n                Set_GPIOPin(MW_SPI_C_PINVALUE_SOMI, GPIO_MUX_CPU1, MW_SPI_C_PINMUX_SOMI, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC);\n        #endif //MW_SPI_C_MODE\n    #endif\n#else //MW_SPI_C_ENABLETHREEWIRE not defined\n    #if MW_SPI_C_MODE == 0\n                Set_GPIOPin(MW_SPI_C_PINVALUE_SIMO, GPIO_MUX_CPU1, MW_SPI_C_PINMUX_SIMO, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC);\n                Set_GPIOPin(MW_SPI_C_PINVALUE_SOMI, GPIO_MUX_CPU1, MW_SPI_C_PINMUX_SOMI, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC);\n    #else //MW_SPI_C_MODE 1\n                Set_GPIOPin(MW_SPI_C_PINVALUE_SIMO, GPIO_MUX_CPU1, MW_SPI_C_PINMUX_SIMO, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC);\n                Set_GPIOPin(MW_SPI_C_PINVALUE_SOMI, GPIO_MUX_CPU1, MW_SPI_C_PINMUX_SOMI, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC);\n    #endif //MW_SPI_C_MODE\n#endif // End of MW_SPI_C_ENABLETHREEWIRE\n                \n#if MW_SPI_C_MODE == 0\n                Set_GPIOPin(MW_SPI_C_PINVALUE_CLK, GPIO_MUX_CPU1, MW_SPI_C_PINMUX_CLK, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC); \n#else //MW_SPI_C_MODE 1\n                Set_GPIOPin(MW_SPI_C_PINVALUE_CLK, GPIO_MUX_CPU1, MW_SPI_C_PINMUX_CLK, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC); \n#endif //MW_SPI_C_MODE\n\n#ifdef MW_SPISTE_SELECT_SPI_C\n                if (MW_SPI_C_PINVALUE_STE >= 0)\n                {\n#if MW_SPI_C_MODE == 0\n                   Set_GPIOPin(MW_SPI_C_PINVALUE_STE, GPIO_MUX_CPU1, MW_SPI_C_PINMUX_STE, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC); \n#else //MW_SPI_C_MODE 1\n                   Set_GPIOPin(MW_SPI_C_PINVALUE_STE, GPIO_MUX_CPU1, MW_SPI_C_PINMUX_STE, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC); \n#endif //MW_SPI_C_MODE\n                }\n#endif //End of MW_SPISTE_SELECT_SPI_C\n                \n                *((SPI_obj->spi_base_address) + SPICCR_REG_OFFSET) &= (~(SPICCR_SPISWRESET_BITS << SPICCR_SPISWRESET_SHIFT));\n                *((SPI_obj->spi_base_address) + SPICCR_REG_OFFSET) |= (Uint16)((MW_SPI_C_ENABLELOOPBACK & SPICCR_SPILBK_BITS) << SPICCR_SPILBK_SHIFT);\n\t\t\t\t#ifdef MW_SPI_C_ENABLEHIGHSPEEDMODE\n                *((SPI_obj->spi_base_address) + SPICCR_REG_OFFSET) |= (Uint16)((MW_SPI_C_ENABLEHIGHSPEEDMODE & SPICCR_HS_MODE_BITS) << SPICCR_HS_MODE_SHIFT);\n\t\t\t\t#endif\n                *((SPI_obj->spi_base_address) + SPICTL_REG_OFFSET) |= (Uint16)(((~MW_SPI_C_MODE) & SPICTL_MASTER_SLAVE_BITS) << SPICTL_MASTER_SLAVE_SHIFT);\n                *((SPI_obj->spi_base_address) + SPICTL_REG_OFFSET) |= (Uint16)((SPICTL_TALK_BITS) << SPICTL_TALK_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIBRR_REG_OFFSET) |= (Uint16)(((Uint16)MW_SPI_C_BAUDRATEFACTOR & SPIBRR_SPI_BIT_RATE_BITS) << SPIBRR_SPI_BIT_RATE_SHIFT);\n#ifdef MW_SPI_C_ENABLETHREEWIRE\n                *((SPI_obj->spi_base_address) + SPIPRI_REG_OFFSET) |= (Uint16)((MW_SPI_C_ENABLETHREEWIRE & SPIPRI_TRIWIRE_BITS) << SPIPRI_TRIWIRE_SHIFT);\n#endif // End of MW_SPI_C_ENABLETHREEWIRE\n                *((SPI_obj->spi_base_address) + SPIPRI_REG_OFFSET) |= (Uint16)((priority & SPIPRI_SOFT_FREE_BITS) << SPIPRI_SOFT_FREE_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIFFTX_REG_OFFSET) |= ((SPIFFTX_SPIFFENA_BITS) << SPIFFTX_SPIFFENA_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIFFCT_REG_OFFSET) |= ((MW_SPI_C_FIFOTRANSMITDELAY & SPIFFCT_TXDLY_BITS) << SPIFFCT_TXDLY_SHIFT);\n\n                /* Set the TX Interrupt FIFO level only at the init. Enable the FIFO interrupt only after TX buffer is full */\n                *((SPI_obj->spi_base_address) + SPIFFTX_REG_OFFSET) |= ((MW_SPI_C_FIFOINTERRUPTLEVEL_TX & SPIFFTX_TXFFIL_BITS) << SPIFFTX_TXFFIL_SHIFT);\n\n                *((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) &= (~(SPIFFRX_RXFFIL_BITS << SPIFFRX_RXFFIL_SHIFT));\n                *((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) |= ((MW_SPI_C_FIFOINTERRUPTLEVEL_RX & SPIFFRX_RXFFIL_BITS) << SPIFFRX_RXFFIL_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) |= (SPIFFRX_RXFFINTCLR_BITS << SPIFFRX_RXFFINTCLR_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) |= ((MW_SPI_C_RXINTERRUPTENABLE & SPIFFRX_RXFFIENA_BITS) << SPIFFRX_RXFFIENA_SHIFT);\n\n                *((SPI_obj->spi_base_address) + SPICCR_REG_OFFSET) |= (Uint16)(SPICCR_SPISWRESET_BITS << SPICCR_SPISWRESET_SHIFT);\n                SPI_oneTimeInit[2] = 1;\n            }\n#else\n            SPI_obj->spi_base_address = (SPI_REG_ADDRESS)0;\n            SPI_obj->spi_clk_mode = 0;\n            SPI_obj->charLength = 0;\n            SPI_obj->fifoLevel = 0;\n            SPI_obj->txInterrupt = 0;\n#endif // End of MW_SPI_C\n        }\n        break;\n        case 3: //SPI Module D\n        {\n#ifdef MW_SPI_D\n            if (SPI_oneTimeInit[3] == 0)\n            {\n                SPI_obj->spi_base_address = (SPI_REG_ADDRESS)&SpidRegs;\n                SPI_obj->spi_clk_mode = 0;\n                SPI_obj->charLength = 0;\n                SPI_obj->fifoLevel = MW_SPI_D_FIFO_LEVEL;\n                SPI_obj->txInterrupt = MW_SPI_D_TXINTERRUPTENABLE;\n\n                if (MW_SPI_D_SUSPENSIONMODE == 0)\n                {\n                    priority = 0;\n                }\n                else if (MW_SPI_D_SUSPENSIONMODE == 1)\n                {\n                    priority = 2;\n                }\n                else\n                {\n                    priority = 1;\n                }\n                /*TRIWIRE - Controller, Peripheral In Controller Out / Peripheral, Peripheral Out Controller In */\n#ifdef MW_SPI_D_ENABLETHREEWIRE\n    #if  MW_SPI_D_ENABLETHREEWIRE == 1\n        #if MW_SPI_D_MODE == 0\n                Set_GPIOPin(MW_SPI_D_PINVALUE_SIMO, GPIO_MUX_CPU1, MW_SPI_D_PINMUX_SIMO, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC);\n        #else //MW_SPI_D_MODE 1\n               Set_GPIOPin(MW_SPI_D_PINVALUE_SOMI, GPIO_MUX_CPU1, MW_SPI_D_PINMUX_SOMI, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC);\n        #endif //MW_SPI_D_MODE\n    #else // MW_SPI_D_ENABLETHREEWIRE 0\n        #if MW_SPI_D_MODE == 0\n                Set_GPIOPin(MW_SPI_D_PINVALUE_SIMO, GPIO_MUX_CPU1, MW_SPI_D_PINMUX_SIMO, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC);\n                Set_GPIOPin(MW_SPI_D_PINVALUE_SOMI, GPIO_MUX_CPU1, MW_SPI_D_PINMUX_SOMI, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC);\n        #else //MW_SPI_D_MODE 1\n                Set_GPIOPin(MW_SPI_D_PINVALUE_SIMO, GPIO_MUX_CPU1, MW_SPI_D_PINMUX_SIMO, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC);\n                Set_GPIOPin(MW_SPI_D_PINVALUE_SOMI, GPIO_MUX_CPU1, MW_SPI_D_PINMUX_SOMI, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC);\n        #endif //MW_SPI_D_MODE\n    #endif\n#else //MW_SPI_D_ENABLETHREEWIRE not defined\n    #if MW_SPI_D_MODE == 0\n                Set_GPIOPin(MW_SPI_D_PINVALUE_SIMO, GPIO_MUX_CPU1, MW_SPI_D_PINMUX_SIMO, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC);\n                Set_GPIOPin(MW_SPI_D_PINVALUE_SOMI, GPIO_MUX_CPU1, MW_SPI_D_PINMUX_SOMI, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC);\n    #else //MW_SPI_D_MODE 1\n                Set_GPIOPin(MW_SPI_D_PINVALUE_SIMO, GPIO_MUX_CPU1, MW_SPI_D_PINMUX_SIMO, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC);\n                Set_GPIOPin(MW_SPI_D_PINVALUE_SOMI, GPIO_MUX_CPU1, MW_SPI_D_PINMUX_SOMI, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC);\n    #endif //MW_SPI_D_MODE\n#endif // End of MW_SPI_D_ENABLETHREEWIRE\n                \n#if MW_SPI_D_MODE == 0\n                Set_GPIOPin(MW_SPI_D_PINVALUE_CLK, GPIO_MUX_CPU1, MW_SPI_D_PINMUX_CLK, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC); \n#else //MW_SPI_D_MODE 1\n                Set_GPIOPin(MW_SPI_D_PINVALUE_CLK, GPIO_MUX_CPU1, MW_SPI_D_PINMUX_CLK, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC); \n#endif //MW_SPI_D_MODE\n\n#ifdef MW_SPISTE_SELECT_SPI_D\n                if (MW_SPI_D_PINVALUE_STE >= 0)\n                {\n#if MW_SPI_D_MODE == 0\n                   Set_GPIOPin(MW_SPI_D_PINVALUE_STE, GPIO_MUX_CPU1, MW_SPI_D_PINMUX_STE, GPIO_OUTPUT, GPIO_PULLUP|GPIO_ASYNC); \n#else //MW_SPI_D_MODE 1\n                   Set_GPIOPin(MW_SPI_D_PINVALUE_STE, GPIO_MUX_CPU1, MW_SPI_D_PINMUX_STE, GPIO_INPUT, GPIO_PULLUP|GPIO_ASYNC); \n#endif //MW_SPI_D_MODE\n                }\n#endif //End of MW_SPISTE_SELECT_SPI_D\n                \n                *((SPI_obj->spi_base_address) + SPICCR_REG_OFFSET) &= (~(SPICCR_SPISWRESET_BITS << SPICCR_SPISWRESET_SHIFT));\n                *((SPI_obj->spi_base_address) + SPICCR_REG_OFFSET) |= (Uint16)((MW_SPI_D_ENABLELOOPBACK & SPICCR_SPILBK_BITS) << SPICCR_SPILBK_SHIFT);\n\t\t\t\t#ifdef MW_SPI_D_ENABLEHIGHSPEEDMODE\n                *((SPI_obj->spi_base_address) + SPICCR_REG_OFFSET) |= (Uint16)((MW_SPI_D_ENABLEHIGHSPEEDMODE & SPICCR_HS_MODE_BITS) << SPICCR_HS_MODE_SHIFT);\n\t\t\t\t#endif\n                *((SPI_obj->spi_base_address) + SPICTL_REG_OFFSET) |= (Uint16)(((~MW_SPI_D_MODE) & SPICTL_MASTER_SLAVE_BITS) << SPICTL_MASTER_SLAVE_SHIFT);\n                *((SPI_obj->spi_base_address) + SPICTL_REG_OFFSET) |= (Uint16)((SPICTL_TALK_BITS) << SPICTL_TALK_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIBRR_REG_OFFSET) |= (Uint16)(((Uint16)MW_SPI_D_BAUDRATEFACTOR & SPIBRR_SPI_BIT_RATE_BITS) << SPIBRR_SPI_BIT_RATE_SHIFT);\n#ifdef MW_SPI_D_ENABLETHREEWIRE\n                *((SPI_obj->spi_base_address) + SPIPRI_REG_OFFSET) |= (Uint16)((MW_SPI_D_ENABLETHREEWIRE & SPIPRI_TRIWIRE_BITS) << SPIPRI_TRIWIRE_SHIFT);\n#endif // End of MW_SPI_D_ENABLETHREEWIRE\n                *((SPI_obj->spi_base_address) + SPIPRI_REG_OFFSET) |= (Uint16)((priority & SPIPRI_SOFT_FREE_BITS) << SPIPRI_SOFT_FREE_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIFFTX_REG_OFFSET) |= ((SPIFFTX_SPIFFENA_BITS) << SPIFFTX_SPIFFENA_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIFFCT_REG_OFFSET) |= ((MW_SPI_D_FIFOTRANSMITDELAY & SPIFFCT_TXDLY_BITS) << SPIFFCT_TXDLY_SHIFT);\n\n                /* Set the TX Interrupt FIFO level only at the init. Enable the FIFO interrupt only after TX buffer is full */\n                *((SPI_obj->spi_base_address) + SPIFFTX_REG_OFFSET) |= ((MW_SPI_D_FIFOINTERRUPTLEVEL_TX & SPIFFTX_TXFFIL_BITS) << SPIFFTX_TXFFIL_SHIFT);\n\n                *((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) &= (~(SPIFFRX_RXFFIL_BITS << SPIFFRX_RXFFIL_SHIFT));\n                *((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) |= ((MW_SPI_D_FIFOINTERRUPTLEVEL_RX & SPIFFRX_RXFFIL_BITS) << SPIFFRX_RXFFIL_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) |= (SPIFFRX_RXFFINTCLR_BITS << SPIFFRX_RXFFINTCLR_SHIFT);\n                *((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) |= ((MW_SPI_D_RXINTERRUPTENABLE & SPIFFRX_RXFFIENA_BITS) << SPIFFRX_RXFFIENA_SHIFT);\n\n                *((SPI_obj->spi_base_address) + SPICCR_REG_OFFSET) |= (Uint16)(SPICCR_SPISWRESET_BITS << SPICCR_SPISWRESET_SHIFT);\n                SPI_oneTimeInit[3] = 1;\n            }\n#else\n            SPI_obj->spi_base_address = (SPI_REG_ADDRESS)0;\n            SPI_obj->spi_clk_mode = 0;\n            SPI_obj->charLength = 0;\n            SPI_obj->fifoLevel = 0;\n            SPI_obj->txInterrupt = 0;\n#endif //End of MW_SPI_D\n        }\n        break;\n        default:\n            SPI_obj->spi_base_address = (SPI_REG_ADDRESS)0;\n            break;\n    }\n#endif //End of MW_F281X\n\n    return &mySpiObj[SPIModule];\n}\n\n/*Set the SPIMode: Clock polarity and clock phase*/\nvoid SPI_clockFormat(MW_SpiHandle SPI_obj, Uint16 clockPolarity, Uint16 clockPhase)\n{\n    if(SPI_obj->spi_base_address != 0)\n    {\n        *((SPI_obj->spi_base_address) + SPICCR_REG_OFFSET) &= (~(SPICCR_CLKPOLARITY_BITS << SPICCR_CLKPOLARITY_SHIFT));\n        *((SPI_obj->spi_base_address) + SPICTL_REG_OFFSET) &= (~(SPICTL_CLK_PHASE_BITS << SPICTL_CLK_PHASE_SHIFT));\n        *((SPI_obj->spi_base_address) + SPICCR_REG_OFFSET) |= ((clockPolarity & SPICCR_CLKPOLARITY_BITS) << SPICCR_CLKPOLARITY_SHIFT);\n        *((SPI_obj->spi_base_address) + SPICTL_REG_OFFSET) |= ((clockPhase & SPICTL_CLK_PHASE_BITS) << SPICTL_CLK_PHASE_SHIFT);\n    }\n}\n\n/*Read the SPI status registers for read and write status*/\nUint16 SPI_status(MW_SpiHandle SPI_obj, SPI_statusVal type)\n{\n    Uint16 ret = 0;\n    if(SPI_obj->spi_base_address != 0)\n    {\n        switch(type)\n        {\n            case SPI_OVERRUN_FLAG:\n                ret = (*((SPI_obj->spi_base_address) + SPISTS_REG_OFFSET) >> SPISTS_OVERRUN_FLAG_SHIFT)& SPISTS_OVERRUN_FLAG_BITS;\n                break;\n            case SPI_INT_FLAG:\n                ret = (*((SPI_obj->spi_base_address) + SPISTS_REG_OFFSET) >> SPISTS_INT_FLAG_SHIFT) & SPISTS_INT_FLAG_BITS;\n                break;\n            case SPI_BUFFULL_FLAG:\n                ret = (*((SPI_obj->spi_base_address) + SPISTS_REG_OFFSET) >> SPISTS_BUFFULL_FLAG_SHIFT) & SPISTS_BUFFULL_FLAG_BITS;\n                break;\n            case SPI_TXFFST_FLAG:\n                ret = (*((SPI_obj->spi_base_address) + SPIFFTX_REG_OFFSET) >> SPIFFTX_TXFFST_SHIFT) & SPIFFTX_TXFFST_BITS ;\n                break;\n            case SPI_RXFFST_FLAG:\n                ret = (*((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) >> SPIFFRX_RXFFST_SHIFT) & SPIFFRX_RXFFST_BITS;\n                break;\n            case SPI_RXFFOVF_FLAG:\n                ret = (*((SPI_obj->spi_base_address) + SPIFFRX_REG_OFFSET) >> SPIFFRX_RXFFOVF_SHIFT) & SPIFFRX_RXFFOVF_BITS;\n                break;\n            default :\n                ret = 0;\n        }\n    }\n    return ret;\n}\n"},{"name":"MW_c28xx_adc.c","type":"source","group":"legacy","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Other files","code":"#include \"c2000BoardSupport.h\"\r\n#include \"MW_f2837xD_includes.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"mcb_pmsm_foc_qep_f28379d.h\"\r\n#include \"mcb_pmsm_foc_qep_f28379d_private.h\"\r\n\r\nvoid config_ADCC_SOC2(void)\r\n{\r\n  EALLOW;\r\n  AdccRegs.ADCSOC2CTL.bit.CHSEL = 2U;  /* Set SOC2 channel select to ADCIN2*/\r\n  AdccRegs.ADCSOC2CTL.bit.TRIGSEL = 0U;\r\n  AdccRegs.ADCSOC2CTL.bit.ACQPS = (uint16_T)14.0;\r\n                               /* Set SOC2 S/H Window to 15.0 ADC Clock Cycles*/\r\n  AdccRegs.ADCINTSOCSEL1.bit.SOC2 = 0U;\r\n                                   /* SOCx No ADCINT Interrupt Trigger Select.*/\r\n  AdccRegs.ADCOFFTRIM.bit.OFFTRIM = (uint16_T)AdccRegs.ADCOFFTRIM.bit.OFFTRIM;/* Set Offset Error Correction Value*/\r\n  AdccRegs.ADCCTL1.bit.INTPULSEPOS = 1U;\r\n             /* Interrupt pulse generation occurs at the end of the conversion*/\r\n  AdccRegs.ADCSOCPRICTL.bit.SOCPRIORITY = 0U;/* All in round robin mode SOC Priority*/\r\n  EDIS;\r\n}\r\n\r\nvoid config_ADCB_SOC2(void)\r\n{\r\n  EALLOW;\r\n  AdcbRegs.ADCSOC2CTL.bit.CHSEL = 2U;  /* Set SOC2 channel select to ADCIN2*/\r\n  AdcbRegs.ADCSOC2CTL.bit.TRIGSEL = 0U;\r\n  AdcbRegs.ADCSOC2CTL.bit.ACQPS = (uint16_T)14.0;\r\n                               /* Set SOC2 S/H Window to 15.0 ADC Clock Cycles*/\r\n  AdcbRegs.ADCINTSOCSEL1.bit.SOC2 = 0U;\r\n                                   /* SOCx No ADCINT Interrupt Trigger Select.*/\r\n  AdcbRegs.ADCOFFTRIM.bit.OFFTRIM = (uint16_T)AdcbRegs.ADCOFFTRIM.bit.OFFTRIM;/* Set Offset Error Correction Value*/\r\n  AdcbRegs.ADCCTL1.bit.INTPULSEPOS = 1U;\r\n             /* Interrupt pulse generation occurs at the end of the conversion*/\r\n  AdcbRegs.ADCSOCPRICTL.bit.SOCPRIORITY = 0U;/* All in round robin mode SOC Priority*/\r\n  EDIS;\r\n}\r\n\r\nvoid config_ADCB_SOC0(void)\r\n{\r\n  EALLOW;\r\n  AdcbRegs.ADCSOC0CTL.bit.CHSEL = 2U;  /* Set SOC0 channel select to ADCIN2*/\r\n  AdcbRegs.ADCSOC0CTL.bit.TRIGSEL = 5U;\r\n  AdcbRegs.ADCSOC0CTL.bit.ACQPS = (uint16_T)14.0;\r\n                               /* Set SOC0 S/H Window to 15.0 ADC Clock Cycles*/\r\n  AdcbRegs.ADCINTSEL1N2.bit.INT1E = 1U;/* Enabled/Disable ADCINT1 interrupt*/\r\n  AdcbRegs.ADCINTSEL1N2.bit.INT1SEL = 0U;/* Setup EOC0 to trigger ADCINT1*/\r\n  AdcbRegs.ADCINTSEL1N2.bit.INT1CONT = 1U;\r\n                                     /* Enable/Disable ADCINT1 Continuous mode*/\r\n  AdcbRegs.ADCINTSOCSEL1.bit.SOC0 = 0U;\r\n                                   /* SOCx No ADCINT Interrupt Trigger Select.*/\r\n  AdcbRegs.ADCOFFTRIM.bit.OFFTRIM = (uint16_T)AdcbRegs.ADCOFFTRIM.bit.OFFTRIM;/* Set Offset Error Correction Value*/\r\n  AdcbRegs.ADCCTL1.bit.INTPULSEPOS = 1U;\r\n             /* Interrupt pulse generation occurs at the end of the conversion*/\r\n  AdcbRegs.ADCSOCPRICTL.bit.SOCPRIORITY = 0U;/* All in round robin mode SOC Priority*/\r\n  EDIS;\r\n}\r\n\r\nvoid config_ADCC_SOC0(void)\r\n{\r\n  EALLOW;\r\n  AdccRegs.ADCSOC0CTL.bit.CHSEL = 2U;  /* Set SOC0 channel select to ADCIN2*/\r\n  AdccRegs.ADCSOC0CTL.bit.TRIGSEL = 5U;\r\n  AdccRegs.ADCSOC0CTL.bit.ACQPS = (uint16_T)14.0;\r\n                               /* Set SOC0 S/H Window to 15.0 ADC Clock Cycles*/\r\n  AdccRegs.ADCINTSOCSEL1.bit.SOC0 = 0U;\r\n                                   /* SOCx No ADCINT Interrupt Trigger Select.*/\r\n  AdccRegs.ADCOFFTRIM.bit.OFFTRIM = (uint16_T)AdccRegs.ADCOFFTRIM.bit.OFFTRIM;/* Set Offset Error Correction Value*/\r\n  AdccRegs.ADCCTL1.bit.INTPULSEPOS = 1U;\r\n             /* Interrupt pulse generation occurs at the end of the conversion*/\r\n  AdccRegs.ADCSOCPRICTL.bit.SOCPRIORITY = 0U;/* All in round robin mode SOC Priority*/\r\n  EDIS;\r\n}\r\n\r\nvoid InitAdcB(void)\r\n{\r\n  EALLOW;\r\n  CpuSysRegs.PCLKCR13.bit.ADC_B = 1U;\r\n  AdcbRegs.ADCCTL2.bit.PRESCALE = 8U;\r\n  AdcSetMode((uint16_T)ADC_ADCB, (uint16_T)ADC_RESOLUTION_12BIT,(uint16_T)\r\n             ADC_SIGNALMODE_SINGLE);\r\n\r\n  //power up the ADC\r\n  AdcbRegs.ADCCTL1.bit.ADCPWDNZ = 1U;\r\n\r\n  //delay for 1ms to allow ADC time to power up\r\n  DELAY_US(1000);\r\n  EDIS;\r\n}\r\n\r\nvoid InitAdcC(void)\r\n{\r\n  EALLOW;\r\n  CpuSysRegs.PCLKCR13.bit.ADC_C = 1U;\r\n  AdccRegs.ADCCTL2.bit.PRESCALE = 8U;\r\n  AdcSetMode((uint16_T)ADC_ADCC, (uint16_T)ADC_RESOLUTION_12BIT,(uint16_T)\r\n             ADC_SIGNALMODE_SINGLE);\r\n\r\n  //power up the ADC\r\n  AdccRegs.ADCCTL1.bit.ADCPWDNZ = 1U;\r\n\r\n  //delay for 1ms to allow ADC time to power up\r\n  DELAY_US(1000);\r\n  EDIS;\r\n}\r\n"},{"name":"MW_c28xx_board.c","type":"source","group":"legacy","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Other files","code":"#include \"c2000BoardSupport.h\"\r\n#include \"MW_f2837xD_includes.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"mcb_pmsm_foc_qep_f28379d.h\"\r\n#include \"mcb_pmsm_foc_qep_f28379d_private.h\"\r\n\r\nvoid init_board (void)\r\n{\r\n  DisableDog();\r\n  EALLOW;\r\n  CpuSysRegs.PCLKCR0.bit.DMA = 1U;\r\n  CpuSysRegs.PCLKCR6.bit.SD1 = 1U;\r\n  CpuSysRegs.PCLKCR6.bit.SD2 = 1U;\r\n  EDIS;\r\n\r\n#ifdef CPU1\r\n\r\n  EALLOW;\r\n\r\n  //enable pull-ups on unbonded IOs as soon as possible to reduce power consumption.\r\n  GPIO_EnableUnbondedIOPullups();\r\n  CpuSysRegs.PCLKCR13.bit.ADC_A = 1U;\r\n  CpuSysRegs.PCLKCR13.bit.ADC_B = 1U;\r\n  CpuSysRegs.PCLKCR13.bit.ADC_C = 1U;\r\n  CpuSysRegs.PCLKCR13.bit.ADC_D = 1U;\r\n\r\n  //check if device is trimmed\r\n  if (*((Uint16 *)0x5D1B6) == 0x0000U) {\r\n    //device is not trimmed, apply static calibration values\r\n    AnalogSubsysRegs.ANAREFTRIMA.all = 31709U;\r\n    AnalogSubsysRegs.ANAREFTRIMB.all = 31709U;\r\n    AnalogSubsysRegs.ANAREFTRIMC.all = 31709U;\r\n    AnalogSubsysRegs.ANAREFTRIMD.all = 31709U;\r\n  }\r\n\r\n  CpuSysRegs.PCLKCR13.bit.ADC_A = 0U;\r\n  CpuSysRegs.PCLKCR13.bit.ADC_B = 0U;\r\n  CpuSysRegs.PCLKCR13.bit.ADC_C = 0U;\r\n  CpuSysRegs.PCLKCR13.bit.ADC_D = 0U;\r\n  EDIS;\r\n  InitSysPll(XTAL_OSC,40,0,1);\r\n\r\n  //Turn on all peripherals\r\n  //InitPeripheralClocks();\r\n  EALLOW;\r\n  CpuSysRegs.PCLKCR0.bit.CPUTIMER0 = 1U;\r\n  CpuSysRegs.PCLKCR0.bit.CPUTIMER1 = 1U;\r\n  CpuSysRegs.PCLKCR0.bit.CPUTIMER2 = 1U;\r\n  CpuSysRegs.PCLKCR0.bit.HRPWM = 1U;\r\n  CpuSysRegs.PCLKCR1.bit.EMIF1 = 1U;\r\n  CpuSysRegs.PCLKCR1.bit.EMIF2 = 1U;\r\n\r\n  /* Assign all Peripherals to CPU2 */\r\n  DevCfgRegs.CPUSEL11.all = 0x0000000FU;\r\n  DevCfgRegs.CPUSEL5.all = 0x0000000FU;\r\n  DevCfgRegs.CPUSEL14.all = 0x00070000U;\r\n  DevCfgRegs.CPUSEL7.all = 0x00000003U;\r\n  DevCfgRegs.CPUSEL0.all = 0x00000FFFU;\r\n  DevCfgRegs.CPUSEL1.all = 0x0000003FU;\r\n  DevCfgRegs.CPUSEL2.all = 0x00000007U;\r\n  DevCfgRegs.CPUSEL4.all = 0x00000003U;\r\n  DevCfgRegs.CPUSEL6.all = 0x00000007U;\r\n  DevCfgRegs.CPUSEL8.all = 0x00000003U;\r\n  DevCfgRegs.CPUSEL12.all = 0x000000FFU;\r\n  EDIS;\r\n\r\n#endif                                 // #ifdef CPU1\r\n\r\n  EALLOW;\r\n\r\n  /* Configure low speed peripheral clocks */\r\n  ClkCfgRegs.LOSPCP.bit.LSPCLKDIV = 0U;\r\n  EDIS;\r\n\r\n  /* Disable and clear all CPU interrupts */\r\n  DINT;\r\n  IER = 0x0000U;\r\n  IFR = 0x0000U;\r\n  InitPieCtrl();\r\n  InitPieVectTable();\r\n  initSetGPIOIPC();\r\n  InitCpuTimers();\r\n\r\n#ifdef CPU1\r\n\r\n  EALLOW;\r\n\r\n  /* Assign used ADC modules to CPU1 */\r\n  DevCfgRegs.CPUSEL11.bit.ADC_B = 0U;\r\n  DevCfgRegs.CPUSEL11.bit.ADC_C = 0U;\r\n\r\n#ifdef MW_DAC_CHANNEL_A\r\n\r\n  DevCfgRegs.CPUSEL14.bit.DAC_A = 0U;\r\n\r\n#endif\r\n\r\n#ifdef MW_DAC_CHANNEL_B\r\n\r\n  DevCfgRegs.CPUSEL14.bit.DAC_B = 0U;\r\n\r\n#endif\r\n\r\n#ifdef MW_DAC_CHANNEL_C\r\n\r\n  DevCfgRegs.CPUSEL14.bit.DAC_C = 0U;\r\n\r\n#endif\r\n\r\n  /* Assign SDFM modules to CPU1 */\r\n#ifdef MW_SDFM_1\r\n\r\n  DevCfgRegs.CPUSEL4.bit.SD1 = 0U;\r\n\r\n#endif\r\n\r\n#ifdef MW_SDFM_2\r\n\r\n  DevCfgRegs.CPUSEL4.bit.SD2 = 0U;\r\n\r\n#endif\r\n\r\n#ifdef MW_SDFM_3\r\n\r\n  DevCfgRegs.CPUSEL4.bit.SD3 = 0U;\r\n\r\n#endif\r\n\r\n#ifdef MW_SDFM_4\r\n\r\n  DevCfgRegs.CPUSEL4.bit.SD4 = 0U;\r\n\r\n#endif\r\n\r\n  /* Assign used PWM modules to CPU1 */\r\n  DevCfgRegs.CPUSEL0.bit.EPWM1 = 0U;\r\n  DevCfgRegs.CPUSEL0.bit.EPWM2 = 0U;\r\n  DevCfgRegs.CPUSEL0.bit.EPWM3 = 0U;\r\n\r\n  /* Assign used eQEP modules to CPU1 */\r\n  DevCfgRegs.CPUSEL2.bit.EQEP1 = 0U;\r\n\r\n  /* Assign used SCI modules to CPU1 */\r\n  DevCfgRegs.CPUSEL5.bit.SCI_A = 0U;\r\n\r\n  /* Assign used SPI modules to CPU1 */\r\n#ifdef MW_SPI_A\r\n\r\n  DevCfgRegs.CPUSEL6.bit.SPI_A = 0U;\r\n\r\n#endif\r\n\r\n#ifdef MW_SPI_B\r\n\r\n  DevCfgRegs.CPUSEL6.bit.SPI_B = 0U;\r\n\r\n#endif\r\n\r\n#ifdef MW_SPI_C\r\n\r\n  DevCfgRegs.CPUSEL6.bit.SPI_C = 0U;\r\n\r\n#endif\r\n\r\n#ifdef MW_SPI_D\r\n\r\n  DevCfgRegs.CPUSEL6.bit.SPI_D = 0U;\r\n\r\n#endif\r\n\r\n#if defined MW_CMPSS1_COMPH || defined MW_CMPSS1_COMPL\r\n\r\n  DevCfgRegs.CPUSEL12.bit.CMPSS1 = 0U;\r\n\r\n#endif\r\n\r\n#if defined MW_CMPSS2_COMPH || defined MW_CMPSS2_COMPL\r\n\r\n  DevCfgRegs.CPUSEL12.bit.CMPSS2 = 0U;\r\n\r\n#endif\r\n\r\n#if defined MW_CMPSS3_COMPH || defined MW_CMPSS3_COMPL\r\n\r\n  DevCfgRegs.CPUSEL12.bit.CMPSS3 = 0U;\r\n\r\n#endif\r\n\r\n#if defined MW_CMPSS4_COMPH || defined MW_CMPSS4_COMPL\r\n\r\n  DevCfgRegs.CPUSEL12.bit.CMPSS4 = 0U;\r\n\r\n#endif\r\n\r\n#if defined MW_CMPSS5_COMPH || defined MW_CMPSS5_COMPL\r\n\r\n  DevCfgRegs.CPUSEL12.bit.CMPSS5 = 0U;\r\n\r\n#endif\r\n\r\n#if defined MW_CMPSS6_COMPH || defined MW_CMPSS6_COMPL\r\n\r\n  DevCfgRegs.CPUSEL12.bit.CMPSS6 = 0U;\r\n\r\n#endif\r\n\r\n#if defined MW_CMPSS7_COMPH || defined MW_CMPSS7_COMPL\r\n\r\n  DevCfgRegs.CPUSEL12.bit.CMPSS7 = 0U;\r\n\r\n#endif\r\n\r\n#if defined MW_CMPSS8_COMPH || defined MW_CMPSS8_COMPL\r\n\r\n  DevCfgRegs.CPUSEL12.bit.CMPSS8 = 0U;\r\n\r\n#endif\r\n\r\n#if defined MW_CMPSS9_COMPH || defined MW_CMPSS9_COMPL\r\n\r\n  DevCfgRegs.CPUSEL12.bit.CMPSS9 = 0U;\r\n\r\n#endif\r\n\r\n#if defined MW_CMPSS10_COMPH || defined MW_CMPSS10_COMPL\r\n\r\n  DevCfgRegs.CPUSEL12.bit.CMPSS10 = 0U;\r\n\r\n#endif\r\n\r\n#if defined MW_CMPSS11_COMPH || defined MW_CMPSS11_COMPL\r\n\r\n  DevCfgRegs.CPUSEL12.bit.CMPSS11 = 0U;\r\n\r\n#endif\r\n\r\n  EDIS;\r\n\r\n#endif                                 // #ifdef CPU1\r\n\r\n  init_SCI();\r\n  init_SCI_GPIO();\r\n  init_SCIFrame();\r\n\r\n  /* initial ePWM GPIO assignment... */\r\n  config_ePWM_GPIO();\r\n  EALLOW;\r\n\r\n  /* Enable clock to ePWM */\r\n  CpuSysRegs.PCLKCR2.bit.EPWM1 = 1U;\r\n  CpuSysRegs.PCLKCR2.bit.EPWM2 = 1U;\r\n  CpuSysRegs.PCLKCR2.bit.EPWM3 = 1U;\r\n\r\n  /* Disable TBCLK within ePWM before module configuration */\r\n  CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 0U;\r\n  EDIS;\r\n  config_ePWMSyncSource();\r\n\r\n#ifdef CPU1\r\n\r\n  /* initial GPIO qualification settings.... */\r\n  EALLOW;\r\n  GpioCtrlRegs.GPAQSEL1.all = 0x0U;\r\n  GpioCtrlRegs.GPAQSEL2.all = 0x0U;\r\n  GpioCtrlRegs.GPBQSEL1.all = 0x0U;\r\n  GpioCtrlRegs.GPBQSEL2.all = 0x0U;\r\n  GpioCtrlRegs.GPCQSEL1.all = 0x0U;\r\n  GpioCtrlRegs.GPCQSEL2.all = 0x0U;\r\n  GpioCtrlRegs.GPDQSEL1.all = 0x0U;\r\n  GpioCtrlRegs.GPDQSEL2.all = 0x0U;\r\n  GpioCtrlRegs.GPEQSEL1.all = 0x0U;\r\n  GpioCtrlRegs.GPEQSEL2.all = 0x0U;\r\n  GpioCtrlRegs.GPFQSEL1.all = 0x0U;\r\n  EDIS;\r\n\r\n#endif                                 // #ifdef CPU1\r\n\r\n}\r\n"},{"name":"MW_c28xx_csl.c","type":"source","group":"legacy","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Other files","code":"#include \"c2000BoardSupport.h\"\r\n#include \"MW_f2837xD_includes.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"mcb_pmsm_foc_qep_f28379d.h\"\r\n#include \"mcb_pmsm_foc_qep_f28379d_private.h\"\r\n\r\nvoid enableExtInterrupt (void);\r\nvoid configureGPIOExtInterrupt(void);\r\n\r\n#include <stdint.h>\r\n\r\nvoid disableWatchdog(void)\r\n{\r\n  int *WatchdogWDCR = (int *)(uintptr_t)0x7029;\r\n  asm(\" EALLOW \");\r\n  *WatchdogWDCR = 0x0068;\r\n  asm(\" EDIS \");\r\n}\r\n\r\nvoid init_SCI(void)\r\n{\r\n  /* initialize SCI & FIFO registers */\r\n  EALLOW;\r\n\r\n  /*\r\n   * Initialize SCI_A with following parameters:\r\n   *    BaudRate              : 12500000\r\n   *    CharacterLengthBits   : 8\r\n   *    EnableLoopBack        : 0\r\n   *    NumberOfStopBits      : 1\r\n   *    ParityMode            : None\r\n   *    SuspensionMode        : Free_run\r\n   */\r\n  CpuSysRegs.PCLKCR7.bit.SCI_A = 1U;\r\n  asm(\" NOP\");\r\n  SciaRegs.SCICCR.bit.STOPBITS = 0U;\r\n                    /*Number of stop bits. (0: One stop bit, 1: Two stop bits)*/\r\n  SciaRegs.SCICCR.bit.PARITY = 0U;\r\n                                 /*Parity mode (0: Odd parity, 1: Even parity)*/\r\n  SciaRegs.SCICCR.bit.PARITYENA = 0U;  /*Enable Pary Mode */\r\n  SciaRegs.SCICCR.bit.LOOPBKENA = 0U;  /*Loop Back enable*/\r\n  SciaRegs.SCICCR.bit.ADDRIDLE_MODE = 0U;/*ADDR/IDLE Mode control*/\r\n  SciaRegs.SCICCR.bit.SCICHAR = 7U;    /*Character length*/\r\n  SciaRegs.SCICTL1.bit.RXERRINTENA = 0U;/*Disable receive error interrupt*/\r\n  SciaRegs.SCICTL1.bit.SWRESET = 1U;   /*Software reset*/\r\n  SciaRegs.SCICTL1.bit.TXENA = 1U;     /* SCI transmitter enable*/\r\n  SciaRegs.SCICTL1.bit.RXENA = 1U;     /* SCI receiver enable*/\r\n  SciaRegs.SCIHBAUD.bit.BAUD = 0U;\r\n  SciaRegs.SCILBAUD.bit.BAUD = 1U;\r\n\r\n  /*Free run, continue SCI operation regardless of suspend*/\r\n  SciaRegs.SCIPRI.bit.FREESOFT = 3U;\r\n  SciaRegs.SCIFFCT.bit.ABDCLR = 0U;\r\n  SciaRegs.SCIFFCT.bit.CDC = 0U;\r\n  SciaRegs.SCIFFTX.bit.SCIRST = 1U;    /* SCI reset rx/tx channels*/\r\n  SciaRegs.SCIFFTX.bit.SCIFFENA = 1U;  /* SCI FIFO enhancements are enabled.*/\r\n  SciaRegs.SCIFFTX.bit.TXFIFORESET = 1U;/* Re-enable transmit FIFO operation.*/\r\n  SciaRegs.SCIFFRX.bit.RXFIFORESET = 1U;/* Re-enable receive FIFO operation.*/\r\n  SciaRegs.SCIFFRX.bit.RXFFIENA = 1U;\r\n  SciaRegs.SCIFFRX.bit.RXFFIL = 4U;\r\n  SciaRegs.SCICTL1.bit.RXERRINTENA = 1U;\r\n  /*Enable receive error interrupt by default if receive FIFO interrupt is enabled*/\r\n  EDIS;\r\n}\r\n\r\nvoid init_SCI_GPIO(void)\r\n{\r\n  EALLOW;\r\n  GpioCtrlRegs.GPBQSEL1.bit.GPIO43 = 3U;/*Asynch input GPIO43 SCIRXDA*/\r\n  GpioCtrlRegs.GPBPUD.bit.GPIO43 = 0U; /*Enable pull-up for GPIO43*/\r\n  GpioCtrlRegs.GPBGMUX1.bit.GPIO43 = 3U;\r\n  GpioCtrlRegs.GPBMUX1.bit.GPIO43 = 3U;/*Configure GPIO43 as SCIRXDA*/\r\n  GpioCtrlRegs.GPBPUD.bit.GPIO42 = 0U; /*Enable pull-up for GPIO42*/\r\n  GpioCtrlRegs.GPBGMUX1.bit.GPIO42 = 3U;\r\n  GpioCtrlRegs.GPBMUX1.bit.GPIO42 = 3U;/*Configure GPIO42 as SCITXDA*/\r\n  EDIS;\r\n}\r\n"},{"name":"MW_c28xx_pie.h","type":"header","group":"other","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef __MW_C28XX_PIE_H__\r\n#define __MW_C28XX_PIE_H__\r\n#define PIEMASK0                       64\r\n#define PIEMASK8                       1\r\n#define IFRMASK                        257\r\n#endif                                 /* MW_C28XX_PIE_H */\r\n"},{"name":"MW_c28xx_pwm.c","type":"source","group":"legacy","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Other files","code":"#include \"c2000BoardSupport.h\"\r\n#include \"MW_f2837xD_includes.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"mcb_pmsm_foc_qep_f28379d.h\"\r\n#include \"mcb_pmsm_foc_qep_f28379d_private.h\"\r\n\r\nvoid config_ePWM_GPIO (void)\r\n{\r\n  EALLOW;\r\n  ClkCfgRegs.PERCLKDIVSEL.bit.EPWMCLKDIV = 0U;\r\n\r\n  /*-- Configure pin assignments for ePWM1 --*/\r\n  GpioCtrlRegs.GPAGMUX1.bit.GPIO0 = 0U;\r\n  GpioCtrlRegs.GPAMUX1.bit.GPIO0 = 1U; /* Configure GPIOGPIO0 as EPWM1A*/\r\n  GpioCtrlRegs.GPAGMUX1.bit.GPIO1 = 0U;\r\n  GpioCtrlRegs.GPAMUX1.bit.GPIO1 = 1U; /* Configure GPIOGPIO1 as EPWM1B*/\r\n\r\n  /*-- Configure pin assignments for ePWM2 --*/\r\n  GpioCtrlRegs.GPAGMUX1.bit.GPIO2 = 0U;\r\n  GpioCtrlRegs.GPAMUX1.bit.GPIO2 = 1U; /* Configure GPIOGPIO2 as EPWM2A*/\r\n  GpioCtrlRegs.GPAGMUX1.bit.GPIO3 = 0U;\r\n  GpioCtrlRegs.GPAMUX1.bit.GPIO3 = 1U; /* Configure GPIOGPIO3 as EPWM2B*/\r\n\r\n  /*-- Configure pin assignments for ePWM3 --*/\r\n  GpioCtrlRegs.GPAGMUX1.bit.GPIO4 = 0U;\r\n  GpioCtrlRegs.GPAMUX1.bit.GPIO4 = 1U; /* Configure GPIOGPIO4 as EPWM3A*/\r\n  GpioCtrlRegs.GPAGMUX1.bit.GPIO5 = 0U;\r\n  GpioCtrlRegs.GPAMUX1.bit.GPIO5 = 1U; /* Configure GPIOGPIO5 as EPWM3B*/\r\n  EDIS;\r\n}\r\n\r\nvoid config_ePWM_TBSync (void)\r\n{\r\n  /* Enable TBCLK within the EPWM*/\r\n  EALLOW;\r\n\r\n  /* Enable TBCLK after the ePWM configurations */\r\n  CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1U;\r\n  EDIS;\r\n}\r\n\r\nvoid config_ePWMSyncSource (void)\r\n{\r\n  /* Configuring EXTSYNCOUT source selection */\r\n  EALLOW;\r\n  SyncSocRegs.SYNCSELECT.bit.SYNCOUT = 0U;\r\n\r\n  /* Configuring ePWM Sync in source selection */\r\n  SyncSocRegs.SYNCSELECT.bit.EPWM4SYNCIN = 0U;\r\n  SyncSocRegs.SYNCSELECT.bit.EPWM7SYNCIN = 0U;\r\n  SyncSocRegs.SYNCSELECT.bit.EPWM10SYNCIN = 0U;\r\n  EDIS;\r\n}\r\n"},{"name":"MW_c28xx_qep.c","type":"source","group":"legacy","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Other files","code":"#include \"c2000BoardSupport.h\"\r\n#include \"MW_f2837xD_includes.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"mcb_pmsm_foc_qep_f28379d.h\"\r\n#include \"mcb_pmsm_foc_qep_f28379d_private.h\"\r\n\r\nvoid config_QEP_eQEP1(uint32_T pcmaximumvalue, uint32_T pcInitialvalue, uint32_T\r\n                      unittimerperiod, uint32_T comparevalue, uint16_T\r\n                      watchdogtimer, uint16_T qdecctl, uint16_T qepctl, uint16_T\r\n                      qposctl, uint16_T qcapctl, uint16_T qeint)\r\n{\r\n  EALLOW;\r\n  CpuSysRegs.PCLKCR4.bit.EQEP1 = 1U;\r\n  EDIS;\r\n  EALLOW;                              /* Enable EALLOW*/\r\n\r\n  /* Enable internal pull-up for the selected pins */\r\n  GpioCtrlRegs.GPAPUD.bit.GPIO20 = 0U; /* Enable pull-up on GPIO20 (EQEP1A)*/\r\n  GpioCtrlRegs.GPAPUD.bit.GPIO21 = 0U; /* Enable pull-up on GPIO21 (EQEP1B)*/\r\n  GpioCtrlRegs.GPDPUD.bit.GPIO99 = 0U; /* Enable pull-up on GPIO99 (EQEP1I)*/\r\n\r\n  /* Configure eQEP-1 pins using GPIO regs*/\r\n  GpioCtrlRegs.GPAMUX2.bit.GPIO20 = 1U;/* Configure GPIO20 as EQEP1A*/\r\n  GpioCtrlRegs.GPAGMUX2.bit.GPIO20 = 0U;\r\n  GpioCtrlRegs.GPAMUX2.bit.GPIO21 = 1U;/* Configure GPIO21 as EQEP1B  */\r\n  GpioCtrlRegs.GPAGMUX2.bit.GPIO21 = 0U;\r\n  GpioCtrlRegs.GPDMUX1.bit.GPIO99 = 1U;/* Configure GPIO99 as EQEP1I*/\r\n  GpioCtrlRegs.GPDGMUX1.bit.GPIO99 = 1U;\r\n  EDIS;\r\n  EQep1Regs.QPOSINIT = pcInitialvalue; /*eQEP Initialization Position Count*/\r\n  EQep1Regs.QPOSMAX = pcmaximumvalue;  /*eQEP Maximum Position Count*/\r\n  EQep1Regs.QUPRD = unittimerperiod;   /*eQEP Unit Period Register*/\r\n  EQep1Regs.QWDPRD = watchdogtimer;    /*eQEP watchdog timer Register*/\r\n  EQep1Regs.QDECCTL.all = qdecctl;   /*eQEP Decoder Control (QDECCTL) Register*/\r\n  EQep1Regs.QEPCTL.all = qepctl;       /*eQEP Control (QEPCTL) Register*/\r\n  EQep1Regs.QPOSCTL.all = qposctl;\r\n                            /*eQEP Position-compare Control (QPOSCTL) Register*/\r\n  EQep1Regs.QCAPCTL.all = qcapctl;   /*eQEP Capture Control (QCAPCTL) Register*/\r\n  EQep1Regs.QEPCTL.bit.FREE_SOFT = 2U; /*unaffected by emulation suspend*/\r\n  EQep1Regs.QPOSCMP = comparevalue;    /*eQEP Position-compare*/\r\n  EQep1Regs.QEINT.all = qeint;         /*eQEPx interrupt enable register*/\r\n}\r\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n#include \"c2000BoardSupport.h\"\n#include \"MW_f2837xD_includes.h\"\n#include \"c2000SchedulerTimer.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE TI Delfino F28379D LaunchPad\n#define MW_CONNECTIONINFO_SERIAL_IPADDRESS codertarget.registry.getLoopbackIP;\n#define MW_CONNECTIONINFO_SERIAL_PORT 17725\n#define MW_CONNECTIONINFO_SERIAL_VERBOSE 0\n#define MW_CONNECTIONINFO_SERIALUSINGXCP_BAUDRATE codertarget.registry.getExtModeHostBaud(hCS);\n#define MW_CONNECTIONINFO_SERIALUSINGXCP_COMPORT COM1\n#define MW_CONNECTIONINFO_SERIALUSINGXCP_VERBOSE 1\n#define MW_CONNECTIONINFO_CAN_MEXARGS  \n#define MW_CONNECTIONINFO_XCPONCAN_CANVENDOR \n#define MW_CONNECTIONINFO_XCPONCAN_CANDEVICE \n#define MW_CONNECTIONINFO_XCPONCAN_CANCHANNEL \n#define MW_CONNECTIONINFO_XCPONCAN_BUSSPEED codertarget.registry.getExtModeCANBusSpeed(hCS)\n#define MW_CONNECTIONINFO_XCPONCAN_CANIDCOMMAND 2\n#define MW_CONNECTIONINFO_XCPONCAN_CANIDRESPONSE 3\n#define MW_CONNECTIONINFO_XCPONCAN_ISCANIDEXTENDED 0\n#define MW_CONNECTIONINFO_XCPONCAN_VERBOSE 1\n#define MW_CONNECTIONINFO_XCPONSERIAL_BAUDRATE codertarget.registry.getExtModeHostBaud(hCS);\n#define MW_CONNECTIONINFO_XCPONSERIAL_COMPORT codertarget.registry.serialPortValueCallback(hCS, 'ExtModeCOMPort');\n#define MW_CONNECTIONINFO_XCPONSERIAL_VERBOSE 1\n#define MW_EXTMODE_CONFIGURATION XCP on Serial\n#define MW_EXTMODE_SIGNALBUFFERSIZE 10000.000000\n#define MW_EXTMODE_SCIMODULE 0\n#define MW_EXTMODE_HOSTINTERFACE 3P Tools\n#define MW_EXTMODE_CANMODULE 0\n#define MW_EXTMODE_CANIDTYPE Standard (11-bit)\n#define MW_EXTMODE_CANMASTERID 0x02\n#define MW_EXTMODE_CANSLAVEID 0x03\n#define MW_EXTMODE_CANRXMAILBOXNUMBER 0\n#define MW_EXTMODE_CANTXMAILBOXNUMBER 1\n#define MW_EXTMODE_USEREALTIMESTAMPLOGGING 0\n#define MW_RTOS Baremetal\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_RUNTIME_BUILDACTION 1\n#define MW_RUNTIME_DEVICEID 0\n#define MW_RUNTIME_FLASHLOAD 1\n#define MW_RUNTIME_ENABLETMU 1\n#define MW_RUNTIME_CPU CPU1\n#define MW_RUNTIME_LOADCOMMANDARG $(TARGET_ROOT)/CCS_Config/f28379D.ccxml\n#define MW_RUNTIME_CPU2MODELENABLE 102 97108115101\n#define MW_RUNTIME_CPU2MODEL \n#define MW_RUNTIME_PF1DMAACCESS 0\n#define MW_RUNTIME_PF2DMAACCESS 0\n#define MW_RUNTIME_DISABLEPARALLELBUILD 0\n#define MW_RUNTIME_ENABLEDATATYPEREPLACEMENT 0\n#define MW_RUNTIME_BITSPERDOUBLE 1\n#define MW_TARGETLINKOBJ_USECUSTOMLINKER 0\n#define MW_TARGETLINKOBJ_NAME $(TARGET_ROOT)/src/c28377D.cmd\n#define MW_CLOCKING_CPUCLOCKRATEMHZ 200\n#define MW_CLOCKING_USEINTERNALOSC 0\n#define MW_CLOCKING_OSCCLK 10\n#define MW_CLOCKING_AUTOSETPLLSETTINGS 1\n#define MW_CLOCKING_PLLCR 40\n#define MW_CLOCKING_DIVSEL 2\n#define MW_CLOCKING_CLOSESTCPUCLOCK 200\n#define MW_CLOCKING_CLOSESTCPUCLOCK1 200\n#define MW_CLOCKING_LSPCLKDIV 0\n#define MW_CLOCKING_LSPCLKDIV1 0\n#define MW_CLOCKING_LSPCLK 200\n#define MW_ADCA_CPUCORE 0\n#define MW_ADCA_CLOCKDIV 7\n#define MW_ADCA_CLOCKFREQUENCY 40.000000\n#define MW_ADCA_OFFSETCORRECTIONVALUE AdcaRegs.ADCOFFTRIM.bit.OFFTRIM\n#define MW_ADCA_EXTERNALREFERENCESELECTOR 0\n#define MW_ADCA_EXTERNALREFERENCEVREFHI 3.3\n#define MW_ADCA_EXTERNALREFERENCEVREFLO 0\n#define MW_ADCA_INTPULSEGENERATION 0\n#define MW_ADCA_SOCPRIORITY 0\n#define MW_ADCA_XINT2GPIO GPIO0\n#define MW_ADCA_XINT2GPIO_IXBAR 0\n#define MW_ADCB_CPUCORE 0\n#define MW_ADCB_CLOCKDIV 7\n#define MW_ADCB_CLOCKFREQUENCY 40.000000\n#define MW_ADCB_OFFSETCORRECTIONVALUE AdcbRegs.ADCOFFTRIM.bit.OFFTRIM\n#define MW_ADCB_EXTERNALREFERENCESELECTOR 0\n#define MW_ADCB_EXTERNALREFERENCEVREFHI 3.3\n#define MW_ADCB_EXTERNALREFERENCEVREFLO 0\n#define MW_ADCB_INTPULSEGENERATION 0\n#define MW_ADCB_SOCPRIORITY 0\n#define MW_ADCB_XINT2GPIO GPIO0\n#define MW_ADCB_XINT2GPIO_IXBAR 0\n#define MW_ADCC_CPUCORE 0\n#define MW_ADCC_CLOCKDIV 7\n#define MW_ADCC_CLOCKFREQUENCY 40.000000\n#define MW_ADCC_OFFSETCORRECTIONVALUE AdccRegs.ADCOFFTRIM.bit.OFFTRIM\n#define MW_ADCC_EXTERNALREFERENCESELECTOR 0\n#define MW_ADCC_EXTERNALREFERENCEVREFHI 3.3\n#define MW_ADCC_EXTERNALREFERENCEVREFLO 0\n#define MW_ADCC_INTPULSEGENERATION 0\n#define MW_ADCC_SOCPRIORITY 0\n#define MW_ADCC_XINT2GPIO GPIO0\n#define MW_ADCC_XINT2GPIO_IXBAR 0\n#define MW_ADCD_CPUCORE 0\n#define MW_ADCD_CLOCKDIV 7\n#define MW_ADCD_CLOCKFREQUENCY 40.000000\n#define MW_ADCD_OFFSETCORRECTIONVALUE AdcdRegs.ADCOFFTRIM.bit.OFFTRIM\n#define MW_ADCD_EXTERNALREFERENCESELECTOR 0\n#define MW_ADCD_EXTERNALREFERENCEVREFHI 3.3\n#define MW_ADCD_EXTERNALREFERENCEVREFLO 0\n#define MW_ADCD_INTPULSEGENERATION 0\n#define MW_ADCD_SOCPRIORITY 0\n#define MW_ADCD_XINT2GPIO GPIO0\n#define MW_ADCD_XINT2GPIO_IXBAR 0\n#define MW_DACA_VOLTAGE 0\n#define MW_DACA_LOADMODE 0\n#define MW_DACB_VOLTAGE 0\n#define MW_DACB_LOADMODE 0\n#define MW_DACC_VOLTAGE 0\n#define MW_DACC_LOADMODE 0\n#define MW_EPWM_CLOCKDIV 0\n#define MW_EPWM_CLOCKDIV1 0\n#define MW_EPWM_PINASSIGNMENT_TZ1 None\n#define MW_EPWM_PINASSIGNMENT_TZ2 None\n#define MW_EPWM_PINASSIGNMENT_TZ3 None\n#define MW_EPWM_PINASSIGNMENT_SYNCI None\n#define MW_EPWM_PINASSIGNMENT_SYNCO None\n#define MW_EPWM_PINASSIGNMENT_PWM1A 1\n#define MW_EPWM_PINASSIGNMENT_PWM1B 1\n#define MW_EPWM_PINASSIGNMENT_PWM2A 1\n#define MW_EPWM_PINASSIGNMENT_PWM2B 1\n#define MW_EPWM_PINASSIGNMENT_PWM3A 1\n#define MW_EPWM_PINASSIGNMENT_PWM3B 1\n#define MW_EPWM_PINASSIGNMENT_PWM4A 1\n#define MW_EPWM_PINASSIGNMENT_PWM4B 1\n#define MW_EPWM_PINASSIGNMENT_PWM5A 1\n#define MW_EPWM_PINASSIGNMENT_PWM5B 1\n#define MW_EPWM_PINASSIGNMENT_PWM6A 1\n#define MW_EPWM_PINASSIGNMENT_PWM6B 1\n#define MW_EPWM_PINASSIGNMENT_PWM7A 2\n#define MW_EPWM_PINASSIGNMENT_PWM7B 2\n#define MW_EPWM_PINASSIGNMENT_PWM8A 2\n#define MW_EPWM_PINASSIGNMENT_PWM8B 2\n#define MW_EPWM_PINASSIGNMENT_PWM9A 1\n#define MW_EPWM_PINASSIGNMENT_PWM9B 1\n#define MW_EPWM_PINASSIGNMENT_PWM10A 1\n#define MW_EPWM_PINASSIGNMENT_PWM10B 1\n#define MW_EPWM_PINASSIGNMENT_PWM11A 1\n#define MW_EPWM_PINASSIGNMENT_PWM11B 1\n#define MW_EPWM_PINASSIGNMENT_PWM12A 1\n#define MW_EPWM_PINASSIGNMENT_PWM12B 1\n#define MW_EPWM_PINASSIGNMENT_TZ1_IXBAR 0\n#define MW_EPWM_PINASSIGNMENT_TZ2_IXBAR 0\n#define MW_EPWM_PINASSIGNMENT_TZ3_IXBAR 0\n#define MW_EPWM_EXBAR_TRIP4 0\n#define MW_EPWM_EXBAR_MUX_TRIP4 -1\n#define MW_EPWM_EXBAR_TRIP4_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP4_INVERT 0\n#define MW_EPWM_EXBAR_TRIP5 0\n#define MW_EPWM_EXBAR_MUX_TRIP5 -1\n#define MW_EPWM_EXBAR_TRIP5_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP5_INVERT 0\n#define MW_EPWM_EXBAR_TRIP7 0\n#define MW_EPWM_EXBAR_MUX_TRIP7 -1\n#define MW_EPWM_EXBAR_TRIP7_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP7_INVERT 0\n#define MW_EPWM_EXBAR_TRIP8 0\n#define MW_EPWM_EXBAR_MUX_TRIP8 -1\n#define MW_EPWM_EXBAR_TRIP8_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP8_INVERT 0\n#define MW_EPWM_EXBAR_TRIP9 0\n#define MW_EPWM_EXBAR_MUX_TRIP9 -1\n#define MW_EPWM_EXBAR_TRIP9_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP9_INVERT 0\n#define MW_EPWM_EXBAR_TRIP10 0\n#define MW_EPWM_EXBAR_MUX_TRIP10 -1\n#define MW_EPWM_EXBAR_TRIP10_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP10_INVERT 0\n#define MW_EPWM_EXBAR_TRIP11 0\n#define MW_EPWM_EXBAR_MUX_TRIP11 -1\n#define MW_EPWM_EXBAR_TRIP11_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP11_INVERT 0\n#define MW_EPWM_EXBAR_TRIP12 0\n#define MW_EPWM_EXBAR_MUX_TRIP12 -1\n#define MW_EPWM_EXBAR_TRIP12_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP12_INVERT 0\n#define MW_EPWM_PINASSIGNMENT_SYNCI_IXBAR 0\n#define MW_EPWM_SYNCSEL_SYNCOUT 0\n#define MW_EPWM_SYNCSEL_EPWM4SYNCIN 0\n#define MW_EPWM_SYNCSEL_EPWM7SYNCIN 0\n#define MW_EPWM_SYNCSEL_EPWM10SYNCIN 0\n#define MW_ECAP_PINASSIGNMENT_ECAP1 GPIO24\n#define MW_ECAP_PINASSIGNMENT_ECAP2 GPIO25\n#define MW_ECAP_PINASSIGNMENT_ECAP3 GPIO26\n#define MW_ECAP_PINASSIGNMENT_ECAP4 GPIO20\n#define MW_ECAP_PINASSIGNMENT_ECAP5 GPIO21\n#define MW_ECAP_PINASSIGNMENT_ECAP6 GPIO23\n#define MW_ECAP_PINASSIGNMENT_APWM1 13\n#define MW_ECAP_PINASSIGNMENT_APWM2 14\n#define MW_ECAP_PINASSIGNMENT_APWM3 15\n#define MW_ECAP_PINASSIGNMENT_APWM4 16\n#define MW_ECAP_PINASSIGNMENT_APWM5 17\n#define MW_ECAP_PINASSIGNMENT_APWM6 18\n#define MW_ECAP_PINASSIGNMENT_ECAP1_IXBAR 0\n#define MW_ECAP_PINASSIGNMENT_ECAP2_IXBAR 0\n#define MW_ECAP_PINASSIGNMENT_ECAP3_IXBAR 0\n#define MW_ECAP_PINASSIGNMENT_ECAP4_IXBAR 0\n#define MW_ECAP_PINASSIGNMENT_ECAP5_IXBAR 0\n#define MW_ECAP_PINASSIGNMENT_ECAP6_IXBAR 0\n#define MW_ECAP_PINASSIGNMENT_APWM1_OXBAR 1.000000\n#define MW_ECAP_PINASSIGNMENT_APWM2_OXBAR 2.000000\n#define MW_ECAP_PINASSIGNMENT_APWM3_OXBAR 3.000000\n#define MW_ECAP_PINASSIGNMENT_APWM4_OXBAR 4.000000\n#define MW_ECAP_PINASSIGNMENT_APWM5_OXBAR 5.000000\n#define MW_ECAP_PINASSIGNMENT_APWM6_OXBAR 6.000000\n#define MW_ECAP_SYNCSEL_ECAP1SYNCIN 0\n#define MW_ECAP_SYNCSEL_ECAP4SYNCIN 0\n#define MW_EQEP_PINASSIGNMENT_EQEP1A 2\n#define MW_EQEP_PINASSIGNMENT_EQEP1B 2\n#define MW_EQEP_PINASSIGNMENT_EQEP1S 0\n#define MW_EQEP_PINASSIGNMENT_EQEP1I 4\n#define MW_EQEP_PINASSIGNMENT_EQEP2A 2\n#define MW_EQEP_PINASSIGNMENT_EQEP2B 2\n#define MW_EQEP_PINASSIGNMENT_EQEP2S 0\n#define MW_EQEP_PINASSIGNMENT_EQEP2I 2\n#define MW_EQEP_PINASSIGNMENT_EQEP3A 2\n#define MW_EQEP_PINASSIGNMENT_EQEP3B 2\n#define MW_EQEP_PINASSIGNMENT_EQEP3S 2\n#define MW_EQEP_PINASSIGNMENT_EQEP3I 2\n#define MW_I2C_MODE 0\n#define MW_I2C_ADDRDATAFORMAT 0\n#define MW_I2C_OWNADDRESS 1\n#define MW_I2C_BITCOUNT 0\n#define MW_I2C_MODULECLOCKPRESCALER 9\n#define MW_I2C_MODULECLOCKFREQUENCY 20000000.000000\n#define MW_I2C_MASTERCLKLOWTIME 20\n#define MW_I2C_MASTERCLKHIGHTIME 20\n#define MW_I2C_MASTERCLOCKFREQUENCY 400000.000000\n#define MW_I2C_MASTERCLOCKFREQUENCY_1 400000.000000\n#define MW_I2C_MASTERCLOCKFREQUENCY_2 400000.000000\n#define MW_I2C_ENABLELOOPBACK 0\n#define MW_I2C_PINASSIGNMENT_SDAA 1\n#define MW_I2C_PINASSIGNMENT_SCLA 1\n#define MW_I2C_ENABLETXINT 0\n#define MW_I2C_TXFIFOLEVEL 16\n#define MW_I2C_ENABLERXINT 0\n#define MW_I2C_RXFIFOLEVEL 16\n#define MW_I2C_ENABLESYSINT 0\n#define MW_I2C_AAS 0\n#define MW_I2C_SCD 0\n#define MW_I2C_ARDY 0\n#define MW_I2C_NACK 0\n#define MW_I2C_AL 0\n#define MW_I2C_PINVALUE_SDA 32\n#define MW_I2C_PINVALUE_SCL 33\n#define MW_I2C_PINMUX_SDA 1\n#define MW_I2C_PINMUX_SCL 1\n#define MW_I2C_B_MODE 0\n#define MW_I2C_B_ADDRDATAFORMAT 0\n#define MW_I2C_B_OWNADDRESS 1\n#define MW_I2C_B_BITCOUNT 0\n#define MW_I2C_B_MODULECLOCKPRESCALER 9\n#define MW_I2C_B_MODULECLOCKFREQUENCY 20000000.000000\n#define MW_I2C_B_MASTERCLKLOWTIME 20\n#define MW_I2C_B_MASTERCLKHIGHTIME 20\n#define MW_I2C_B_MASTERCLOCKFREQUENCY 400000.000000\n#define MW_I2C_B_MASTERCLOCKFREQUENCY_1 400000.000000\n#define MW_I2C_B_MASTERCLOCKFREQUENCY_2 400000.000000\n#define MW_I2C_B_ENABLELOOPBACK 0\n#define MW_I2C_B_PINASSIGNMENT_SDAA 1\n#define MW_I2C_B_PINASSIGNMENT_SCLA 1\n#define MW_I2C_B_ENABLETXINT 0\n#define MW_I2C_B_TXFIFOLEVEL 16\n#define MW_I2C_B_ENABLERXINT 0\n#define MW_I2C_B_RXFIFOLEVEL 16\n#define MW_I2C_B_ENABLESYSINT 0\n#define MW_I2C_B_AAS 0\n#define MW_I2C_B_SCD 0\n#define MW_I2C_B_ARDY 0\n#define MW_I2C_B_NACK 0\n#define MW_I2C_B_AL 0\n#define MW_I2C_B_PINVALUE_SDA 34\n#define MW_I2C_B_PINVALUE_SCL 35\n#define MW_I2C_B_PINMUX_SDA 6\n#define MW_I2C_B_PINMUX_SCL 6\n#define MW_SCI_A_ENABLELOOPBACK 0\n#define MW_SCI_A_SUSPENSIONMODE 2\n#define MW_SCI_A_NUMBEROFSTOPBITS 0\n#define MW_SCI_A_PARITYMODE 0\n#define MW_SCI_A_CHARACTERLENGTHBITS 0\n#define MW_SCI_A_USERBAUDRATE 12e6\n#define MW_SCI_A_BAUDRATEPRESCALER 1.000000\n#define MW_SCI_A_BAUDRATE 12500000.000000\n#define MW_SCI_A_COMMUNICATIONMODE 0\n#define MW_SCI_A_BLOCKINGMODE 0\n#define MW_SCI_A_DATABYTEORDER 0\n#define MW_SCI_A_DATASWAPWIDTH 0\n#define MW_SCI_A_PINASSIGNMENT_TX 4\n#define MW_SCI_A_PINASSIGNMENT_RX 4\n#define MW_SCI_A_ENABLEINTERRUPTTX 0\n#define MW_SCI_A_FIFOINTERRUPTLEVELTX 1\n#define MW_SCI_A_ENABLEINTERRUPTRX 1\n#define MW_SCI_A_FIFOINTERRUPTLEVELRX 4\n#define MW_SCI_B_ENABLELOOPBACK 0\n#define MW_SCI_B_SUSPENSIONMODE 2\n#define MW_SCI_B_NUMBEROFSTOPBITS 0\n#define MW_SCI_B_PARITYMODE 0\n#define MW_SCI_B_CHARACTERLENGTHBITS 0\n#define MW_SCI_B_USERBAUDRATE 115200\n#define MW_SCI_B_BAUDRATEPRESCALER 216.000000\n#define MW_SCI_B_BAUDRATE 115207.000000\n#define MW_SCI_B_COMMUNICATIONMODE 0\n#define MW_SCI_B_BLOCKINGMODE 0\n#define MW_SCI_B_DATABYTEORDER 0\n#define MW_SCI_B_DATASWAPWIDTH 0\n#define MW_SCI_B_PINASSIGNMENT_TX 1\n#define MW_SCI_B_PINASSIGNMENT_RX 1\n#define MW_SCI_B_ENABLEINTERRUPTTX 0\n#define MW_SCI_B_FIFOINTERRUPTLEVELTX 1\n#define MW_SCI_B_ENABLEINTERRUPTRX 0\n#define MW_SCI_B_FIFOINTERRUPTLEVELRX 1\n#define MW_SCI_C_ENABLELOOPBACK 0\n#define MW_SCI_C_SUSPENSIONMODE 2\n#define MW_SCI_C_NUMBEROFSTOPBITS 0\n#define MW_SCI_C_PARITYMODE 0\n#define MW_SCI_C_CHARACTERLENGTHBITS 0\n#define MW_SCI_C_USERBAUDRATE 115200\n#define MW_SCI_C_BAUDRATEPRESCALER 216.000000\n#define MW_SCI_C_BAUDRATE 115207.000000\n#define MW_SCI_C_COMMUNICATIONMODE 0\n#define MW_SCI_C_BLOCKINGMODE 0\n#define MW_SCI_C_DATABYTEORDER 0\n#define MW_SCI_C_DATASWAPWIDTH 0\n#define MW_SCI_C_PINASSIGNMENT_TX 1\n#define MW_SCI_C_PINASSIGNMENT_RX 1\n#define MW_SCI_C_ENABLEINTERRUPTTX 0\n#define MW_SCI_C_FIFOINTERRUPTLEVELTX 1\n#define MW_SCI_C_ENABLEINTERRUPTRX 0\n#define MW_SCI_C_FIFOINTERRUPTLEVELRX 1\n#define MW_SCI_D_ENABLELOOPBACK 0\n#define MW_SCI_D_SUSPENSIONMODE 2\n#define MW_SCI_D_NUMBEROFSTOPBITS 0\n#define MW_SCI_D_PARITYMODE 0\n#define MW_SCI_D_CHARACTERLENGTHBITS 0\n#define MW_SCI_D_USERBAUDRATE 115200\n#define MW_SCI_D_BAUDRATEPRESCALER 216.000000\n#define MW_SCI_D_BAUDRATE 115207.000000\n#define MW_SCI_D_COMMUNICATIONMODE 0\n#define MW_SCI_D_BLOCKINGMODE 0\n#define MW_SCI_D_DATABYTEORDER 0\n#define MW_SCI_D_DATASWAPWIDTH 0\n#define MW_SCI_D_PINASSIGNMENT_TX 1\n#define MW_SCI_D_PINASSIGNMENT_RX 1\n#define MW_SCI_D_ENABLEINTERRUPTTX 0\n#define MW_SCI_D_FIFOINTERRUPTLEVELTX 1\n#define MW_SCI_D_ENABLEINTERRUPTRX 0\n#define MW_SCI_D_FIFOINTERRUPTLEVELRX 1\n#define MW_SPI_A_MODE 0\n#define MW_SPI_A_USERBAUDRATE 1843200\n#define MW_SPI_A_BAUDRATEFACTOR 108.000000\n#define MW_SPI_A_BAUDRATE 1834862.000000\n#define MW_SPI_A_DATABITS 15\n#define MW_SPI_A_CLOCKPOLARITY 0\n#define MW_SPI_A_CLOCKPHASE 0\n#define MW_SPI_A_SUSPENSIONMODE 2\n#define MW_SPI_A_ENABLELOOPBACK 0\n#define MW_SPI_A_ENABLETHREEWIRE 0\n#define MW_SPI_A_TXINTERRUPTENABLE 0\n#define MW_SPI_A_FIFOINTERRUPTLEVEL_TX 0\n#define MW_SPI_A_RXINTERRUPTENABLE 0\n#define MW_SPI_A_FIFOINTERRUPTLEVEL_RX 16\n#define MW_SPI_A_FIFOENABLE 1\n#define MW_SPI_A_FIFOTRANSMITDELAY 0\n#define MW_SPI_A_PINASSIGNMENT_SIMO 3\n#define MW_SPI_A_PINASSIGNMENT_SOMI 3\n#define MW_SPI_A_PINASSIGNMENT_CLK 3\n#define MW_SPI_A_PINASSIGNMENT_STE 3\n#define MW_SPI_A_PINVALUE_SIMO 58\n#define MW_SPI_A_PINVALUE_SOMI 59\n#define MW_SPI_A_PINVALUE_CLK 60\n#define MW_SPI_A_PINVALUE_STE 61\n#define MW_SPI_A_PINMUX_SIMO 15\n#define MW_SPI_A_PINMUX_SOMI 15\n#define MW_SPI_A_PINMUX_CLK 15\n#define MW_SPI_A_PINMUX_STE 15\n#define MW_SPI_A_FIFO_LEVEL 16.000000\n#define MW_SPI_A_ENABLEHIGHSPEEDMODE 1\n#define MW_SPI_B_MODE 0\n#define MW_SPI_B_USERBAUDRATE 1843200\n#define MW_SPI_B_BAUDRATEFACTOR 108.000000\n#define MW_SPI_B_BAUDRATE 1834862.000000\n#define MW_SPI_B_DATABITS 15\n#define MW_SPI_B_CLOCKPOLARITY 0\n#define MW_SPI_B_CLOCKPHASE 0\n#define MW_SPI_B_SUSPENSIONMODE 2\n#define MW_SPI_B_ENABLELOOPBACK 0\n#define MW_SPI_B_ENABLETHREEWIRE 0\n#define MW_SPI_B_TXINTERRUPTENABLE 0\n#define MW_SPI_B_FIFOINTERRUPTLEVEL_TX 0\n#define MW_SPI_B_RXINTERRUPTENABLE 0\n#define MW_SPI_B_FIFOINTERRUPTLEVEL_RX 16\n#define MW_SPI_B_FIFOENABLE 1\n#define MW_SPI_B_FIFOTRANSMITDELAY 0\n#define MW_SPI_B_PINASSIGNMENT_SIMO 1\n#define MW_SPI_B_PINASSIGNMENT_SOMI 1\n#define MW_SPI_B_PINASSIGNMENT_CLK 2\n#define MW_SPI_B_PINASSIGNMENT_STE 2\n#define MW_SPI_B_PINVALUE_SIMO 24\n#define MW_SPI_B_PINVALUE_SOMI 25\n#define MW_SPI_B_PINVALUE_CLK 26\n#define MW_SPI_B_PINVALUE_STE 27\n#define MW_SPI_B_PINMUX_SIMO 6\n#define MW_SPI_B_PINMUX_SOMI 6\n#define MW_SPI_B_PINMUX_CLK 6\n#define MW_SPI_B_PINMUX_STE 6\n#define MW_SPI_B_FIFO_LEVEL 16.000000\n#define MW_SPI_B_ENABLEHIGHSPEEDMODE 1\n#define MW_SPI_C_MODE 0\n#define MW_SPI_C_USERBAUDRATE 1843200\n#define MW_SPI_C_BAUDRATEFACTOR 108.000000\n#define MW_SPI_C_BAUDRATE 1834862.000000\n#define MW_SPI_C_DATABITS 15\n#define MW_SPI_C_CLOCKPOLARITY 0\n#define MW_SPI_C_CLOCKPHASE 0\n#define MW_SPI_C_SUSPENSIONMODE 2\n#define MW_SPI_C_ENABLELOOPBACK 0\n#define MW_SPI_C_ENABLETHREEWIRE 0\n#define MW_SPI_C_TXINTERRUPTENABLE 0\n#define MW_SPI_C_FIFOINTERRUPTLEVEL_TX 0\n#define MW_SPI_C_RXINTERRUPTENABLE 0\n#define MW_SPI_C_FIFOINTERRUPTLEVEL_RX 16\n#define MW_SPI_C_FIFOENABLE 1\n#define MW_SPI_C_FIFOTRANSMITDELAY 0\n#define MW_SPI_C_PINASSIGNMENT_SIMO 1\n#define MW_SPI_C_PINASSIGNMENT_SOMI 1\n#define MW_SPI_C_PINASSIGNMENT_CLK 1\n#define MW_SPI_C_PINASSIGNMENT_STE 1\n#define MW_SPI_C_PINVALUE_SIMO 50\n#define MW_SPI_C_PINVALUE_SOMI 51\n#define MW_SPI_C_PINVALUE_CLK 52\n#define MW_SPI_C_PINVALUE_STE 53\n#define MW_SPI_C_PINMUX_SIMO 6\n#define MW_SPI_C_PINMUX_SOMI 6\n#define MW_SPI_C_PINMUX_CLK 6\n#define MW_SPI_C_PINMUX_STE 6\n#define MW_SPI_C_FIFO_LEVEL 16.000000\n#define MW_SPI_C_ENABLEHIGHSPEEDMODE 1\n#define MW_ECAN_A_MODULECLOCKFREQUENCY 200\n#define MW_ECAN_A_BAUDRATEPRESCALER 20.000000\n#define MW_ECAN_A_TSEG1 4\n#define MW_ECAN_A_TSEG2 3\n#define MW_ECAN_A_BAUDRATE 1000000\n#define MW_ECAN_A_SBG 0\n#define MW_ECAN_A_SJW 1\n#define MW_ECAN_A_SAM 0\n#define MW_ECAN_A_ENHANCEDCANMODE 1\n#define MW_ECAN_A_SELFTESTMODE 0\n#define MW_ECAN_A_PINASSIGNMENT_TX 3\n#define MW_ECAN_A_PINASSIGNMENT_RX 3\n#define MW_ECAN_B_MODULECLOCKFREQUENCY 200\n#define MW_ECAN_B_BAUDRATEPRESCALER 20.000000\n#define MW_ECAN_B_TSEG1 4\n#define MW_ECAN_B_TSEG2 3\n#define MW_ECAN_B_BAUDRATE 1000000\n#define MW_ECAN_B_SBG 0\n#define MW_ECAN_B_SJW 1\n#define MW_ECAN_B_SAM 0\n#define MW_ECAN_B_ENHANCEDCANMODE 1\n#define MW_ECAN_B_SELFTESTMODE 0\n#define MW_ECAN_B_PINASSIGNMENT_TX 2\n#define MW_ECAN_B_PINASSIGNMENT_RX 2\n#define MW_WATCHDOG_ENABLE_WATCHDOG 0\n#define MW_WATCHDOG_WATCHDOGCLOCK 0\n#define MW_WATCHDOG_TIME_PERIOD 0.013107\n#define MW_WATCHDOG_WATCHDOGEVENT 0\n#define MW_GPIO0_7_GPIOQUALSEL0 0\n#define MW_GPIO0_7_GPIOQUALSEL1 0\n#define MW_GPIO0_7_GPIOQUALSEL2 0\n#define MW_GPIO0_7_GPIOQUALSEL3 0\n#define MW_GPIO0_7_GPIOQUALSEL4 0\n#define MW_GPIO0_7_GPIOQUALSEL5 0\n#define MW_GPIO0_7_GPIOQUALSEL6 0\n#define MW_GPIO0_7_GPIOQUALSEL7 0\n#define MW_GPIO0_7_QUALPRD 0\n#define MW_GPIO8_15_GPIOQUALSEL8 0\n#define MW_GPIO8_15_GPIOQUALSEL9 0\n#define MW_GPIO8_15_GPIOQUALSEL10 0\n#define MW_GPIO8_15_GPIOQUALSEL11 0\n#define MW_GPIO8_15_GPIOQUALSEL12 0\n#define MW_GPIO8_15_GPIOQUALSEL13 0\n#define MW_GPIO8_15_GPIOQUALSEL14 0\n#define MW_GPIO8_15_GPIOQUALSEL15 0\n#define MW_GPIO8_15_QUALPRD 0\n#define MW_GPIO16_23_GPIOQUALSEL16 0\n#define MW_GPIO16_23_GPIOQUALSEL17 0\n#define MW_GPIO16_23_GPIOQUALSEL18 0\n#define MW_GPIO16_23_GPIOQUALSEL19 0\n#define MW_GPIO16_23_GPIOQUALSEL20 0\n#define MW_GPIO16_23_GPIOQUALSEL21 0\n#define MW_GPIO16_23_GPIOQUALSEL22 0\n#define MW_GPIO16_23_GPIOQUALSEL23 0\n#define MW_GPIO16_23_QUALPRD 0\n#define MW_GPIO24_31_GPIOQUALSEL24 0\n#define MW_GPIO24_31_GPIOQUALSEL25 0\n#define MW_GPIO24_31_GPIOQUALSEL26 0\n#define MW_GPIO24_31_GPIOQUALSEL27 0\n#define MW_GPIO24_31_GPIOQUALSEL28 0\n#define MW_GPIO24_31_GPIOQUALSEL29 0\n#define MW_GPIO24_31_GPIOQUALSEL30 0\n#define MW_GPIO24_31_GPIOQUALSEL31 0\n#define MW_GPIO24_31_QUALPRD 0\n#define MW_GPIO32_39_GPIOQUALSEL32 0\n#define MW_GPIO32_39_GPIOQUALSEL33 0\n#define MW_GPIO32_39_GPIOQUALSEL34 0\n#define MW_GPIO32_39_GPIOQUALSEL35 0\n#define MW_GPIO32_39_GPIOQUALSEL36 0\n#define MW_GPIO32_39_GPIOQUALSEL37 0\n#define MW_GPIO32_39_GPIOQUALSEL38 0\n#define MW_GPIO32_39_GPIOQUALSEL39 0\n#define MW_GPIO32_39_QUALPRD 0\n#define MW_GPIO40_47_GPIOQUALSEL40 0\n#define MW_GPIO40_47_GPIOQUALSEL41 0\n#define MW_GPIO40_47_GPIOQUALSEL42 0\n#define MW_GPIO40_47_GPIOQUALSEL43 0\n#define MW_GPIO40_47_GPIOQUALSEL44 0\n#define MW_GPIO40_47_GPIOQUALSEL45 0\n#define MW_GPIO40_47_GPIOQUALSEL46 0\n#define MW_GPIO40_47_GPIOQUALSEL47 0\n#define MW_GPIO40_47_QUALPRD 0\n#define MW_GPIO48_55_GPIOQUALSEL48 0\n#define MW_GPIO48_55_GPIOQUALSEL49 0\n#define MW_GPIO48_55_GPIOQUALSEL50 0\n#define MW_GPIO48_55_GPIOQUALSEL51 0\n#define MW_GPIO48_55_GPIOQUALSEL52 0\n#define MW_GPIO48_55_GPIOQUALSEL53 0\n#define MW_GPIO48_55_GPIOQUALSEL54 0\n#define MW_GPIO48_55_GPIOQUALSEL55 0\n#define MW_GPIO48_55_QUALPRD 0\n#define MW_GPIO56_63_GPIOQUALSEL56 0\n#define MW_GPIO56_63_GPIOQUALSEL57 0\n#define MW_GPIO56_63_GPIOQUALSEL58 0\n#define MW_GPIO56_63_GPIOQUALSEL59 0\n#define MW_GPIO56_63_GPIOQUALSEL60 0\n#define MW_GPIO56_63_GPIOQUALSEL61 0\n#define MW_GPIO56_63_GPIOQUALSEL62 0\n#define MW_GPIO56_63_GPIOQUALSEL63 0\n#define MW_GPIO56_63_QUALPRD 0\n#define MW_GPIO64_71_GPIOQUALSEL64 0\n#define MW_GPIO64_71_GPIOQUALSEL65 0\n#define MW_GPIO64_71_GPIOQUALSEL66 0\n#define MW_GPIO64_71_GPIOQUALSEL67 0\n#define MW_GPIO64_71_GPIOQUALSEL68 0\n#define MW_GPIO64_71_GPIOQUALSEL69 0\n#define MW_GPIO64_71_GPIOQUALSEL70 0\n#define MW_GPIO64_71_GPIOQUALSEL71 0\n#define MW_GPIO64_71_QUALPRD 0\n#define MW_GPIO72_79_GPIOQUALSEL72 0\n#define MW_GPIO72_79_GPIOQUALSEL73 0\n#define MW_GPIO72_79_GPIOQUALSEL74 0\n#define MW_GPIO72_79_GPIOQUALSEL75 0\n#define MW_GPIO72_79_GPIOQUALSEL76 0\n#define MW_GPIO72_79_GPIOQUALSEL77 0\n#define MW_GPIO72_79_GPIOQUALSEL78 0\n#define MW_GPIO72_79_GPIOQUALSEL79 0\n#define MW_GPIO72_79_QUALPRD 0\n#define MW_GPIO80_87_GPIOQUALSEL80 0\n#define MW_GPIO80_87_GPIOQUALSEL81 0\n#define MW_GPIO80_87_GPIOQUALSEL82 0\n#define MW_GPIO80_87_GPIOQUALSEL83 0\n#define MW_GPIO80_87_GPIOQUALSEL84 0\n#define MW_GPIO80_87_GPIOQUALSEL85 0\n#define MW_GPIO80_87_GPIOQUALSEL86 0\n#define MW_GPIO80_87_GPIOQUALSEL87 0\n#define MW_GPIO80_87_QUALPRD 0\n#define MW_GPIO88_95_GPIOQUALSEL88 0\n#define MW_GPIO88_95_GPIOQUALSEL89 0\n#define MW_GPIO88_95_GPIOQUALSEL90 0\n#define MW_GPIO88_95_GPIOQUALSEL91 0\n#define MW_GPIO88_95_GPIOQUALSEL92 0\n#define MW_GPIO88_95_GPIOQUALSEL93 0\n#define MW_GPIO88_95_GPIOQUALSEL94 0\n#define MW_GPIO88_95_GPIOQUALSEL95 0\n#define MW_GPIO88_95_QUALPRD 0\n#define MW_GPIO96_103_GPIOQUALSEL96 0\n#define MW_GPIO96_103_GPIOQUALSEL97 0\n#define MW_GPIO96_103_GPIOQUALSEL98 0\n#define MW_GPIO96_103_GPIOQUALSEL99 0\n#define MW_GPIO96_103_GPIOQUALSEL100 0\n#define MW_GPIO96_103_GPIOQUALSEL101 0\n#define MW_GPIO96_103_GPIOQUALSEL102 0\n#define MW_GPIO96_103_GPIOQUALSEL103 0\n#define MW_GPIO96_103_QUALPRD 0\n#define MW_GPIO104_111_GPIOQUALSEL104 0\n#define MW_GPIO104_111_GPIOQUALSEL105 0\n#define MW_GPIO104_111_GPIOQUALSEL106 0\n#define MW_GPIO104_111_GPIOQUALSEL107 0\n#define MW_GPIO104_111_GPIOQUALSEL108 0\n#define MW_GPIO104_111_GPIOQUALSEL109 0\n#define MW_GPIO104_111_GPIOQUALSEL110 0\n#define MW_GPIO104_111_GPIOQUALSEL111 0\n#define MW_GPIO104_111_QUALPRD 0\n#define MW_GPIO112_119_GPIOQUALSEL112 0\n#define MW_GPIO112_119_GPIOQUALSEL113 0\n#define MW_GPIO112_119_GPIOQUALSEL114 0\n#define MW_GPIO112_119_GPIOQUALSEL115 0\n#define MW_GPIO112_119_GPIOQUALSEL116 0\n#define MW_GPIO112_119_GPIOQUALSEL117 0\n#define MW_GPIO112_119_GPIOQUALSEL118 0\n#define MW_GPIO112_119_GPIOQUALSEL119 0\n#define MW_GPIO112_119_QUALPRD 0\n#define MW_GPIO120_127_GPIOQUALSEL120 0\n#define MW_GPIO120_127_GPIOQUALSEL121 0\n#define MW_GPIO120_127_GPIOQUALSEL122 0\n#define MW_GPIO120_127_GPIOQUALSEL123 0\n#define MW_GPIO120_127_GPIOQUALSEL124 0\n#define MW_GPIO120_127_GPIOQUALSEL125 0\n#define MW_GPIO120_127_GPIOQUALSEL126 0\n#define MW_GPIO120_127_GPIOQUALSEL127 0\n#define MW_GPIO120_127_QUALPRD 0\n#define MW_GPIO128_135_GPIOQUALSEL128 0\n#define MW_GPIO128_135_GPIOQUALSEL129 0\n#define MW_GPIO128_135_GPIOQUALSEL130 0\n#define MW_GPIO128_135_GPIOQUALSEL131 0\n#define MW_GPIO128_135_GPIOQUALSEL132 0\n#define MW_GPIO128_135_GPIOQUALSEL133 0\n#define MW_GPIO128_135_GPIOQUALSEL134 0\n#define MW_GPIO128_135_GPIOQUALSEL135 0\n#define MW_GPIO128_135_QUALPRD 0\n#define MW_GPIO136_143_GPIOQUALSEL136 0\n#define MW_GPIO136_143_GPIOQUALSEL137 0\n#define MW_GPIO136_143_GPIOQUALSEL138 0\n#define MW_GPIO136_143_GPIOQUALSEL139 0\n#define MW_GPIO136_143_GPIOQUALSEL140 0\n#define MW_GPIO136_143_GPIOQUALSEL141 0\n#define MW_GPIO136_143_GPIOQUALSEL142 0\n#define MW_GPIO136_143_GPIOQUALSEL143 0\n#define MW_GPIO136_143_QUALPRD 0\n#define MW_GPIO144_151_GPIOQUALSEL144 0\n#define MW_GPIO144_151_GPIOQUALSEL145 0\n#define MW_GPIO144_151_GPIOQUALSEL146 0\n#define MW_GPIO144_151_GPIOQUALSEL147 0\n#define MW_GPIO144_151_GPIOQUALSEL148 0\n#define MW_GPIO144_151_GPIOQUALSEL149 0\n#define MW_GPIO144_151_GPIOQUALSEL150 0\n#define MW_GPIO144_151_GPIOQUALSEL151 0\n#define MW_GPIO144_151_QUALPRD 0\n#define MW_GPIO152_159_GPIOQUALSEL152 0\n#define MW_GPIO152_159_GPIOQUALSEL153 0\n#define MW_GPIO152_159_GPIOQUALSEL154 0\n#define MW_GPIO152_159_GPIOQUALSEL155 0\n#define MW_GPIO152_159_GPIOQUALSEL156 0\n#define MW_GPIO152_159_GPIOQUALSEL157 0\n#define MW_GPIO152_159_GPIOQUALSEL158 0\n#define MW_GPIO152_159_GPIOQUALSEL159 0\n#define MW_GPIO152_159_QUALPRD 0\n#define MW_GPIO160_167_GPIOQUALSEL160 0\n#define MW_GPIO160_167_GPIOQUALSEL161 0\n#define MW_GPIO160_167_GPIOQUALSEL162 0\n#define MW_GPIO160_167_GPIOQUALSEL163 0\n#define MW_GPIO160_167_GPIOQUALSEL164 0\n#define MW_GPIO160_167_GPIOQUALSEL165 0\n#define MW_GPIO160_167_GPIOQUALSEL166 0\n#define MW_GPIO160_167_GPIOQUALSEL167 0\n#define MW_GPIO160_167_QUALPRD 0\n#define MW_GPIO168_175_GPIOQUALSEL168 0\n#define MW_GPIO168_175_GPIOQUALSEL169 0\n#define MW_GPIO168_175_GPIOQUALSEL170 0\n#define MW_GPIO168_175_GPIOQUALSEL171 0\n#define MW_GPIO168_175_GPIOQUALSEL172 0\n#define MW_GPIO168_175_GPIOQUALSEL173 0\n#define MW_GPIO168_175_GPIOQUALSEL174 0\n#define MW_GPIO168_175_GPIOQUALSEL175 0\n#define MW_GPIO168_175_QUALPRD 0\n#define MW_DMA_CH1_ENABLEDMACHANNEL 0\n#define MW_DMA_CH1_DATASIZE 0\n#define MW_DMA_CH1_INTERRUPTSRC 0\n#define MW_DMA_CH1_BURSTSIZE 0\n#define MW_DMA_CH1_TRANSFERSIZE 1\n#define MW_DMA_CH1_SRCBEGINADD 0xC000\n#define MW_DMA_CH1_DSTBEGINADD 0xD000\n#define MW_DMA_CH1_SRCBURSTSTEP 0\n#define MW_DMA_CH1_DSTBURSTSTEP 0\n#define MW_DMA_CH1_SRCTRANSSTEP 0\n#define MW_DMA_CH1_DSTTRANSSTEP 0\n#define MW_DMA_CH1_WRAPSRCSIZE 65536\n#define MW_DMA_CH1_WRAPDSTSIZE 65536\n#define MW_DMA_CH1_SRCWRAPSTEP 0\n#define MW_DMA_CH1_DSTWRAPSTEP 0\n#define MW_DMA_CH1_SETCH1TOHIGH 0\n#define MW_DMA_CH1_ENABLEONESHOT 0\n#define MW_DMA_CH1_ENABLECONTINUOUS 1\n#define MW_DMA_CH1_GENINTERRUPT 0\n#define MW_DMA_CH1_ENABLEOVERFLOW 0\n#define MW_DMA_CH2_ENABLEDMACHANNEL 0\n#define MW_DMA_CH2_DATASIZE 0\n#define MW_DMA_CH2_INTERRUPTSRC 0\n#define MW_DMA_CH2_BURSTSIZE 0\n#define MW_DMA_CH2_TRANSFERSIZE 1\n#define MW_DMA_CH2_SRCBEGINADD 0xC000\n#define MW_DMA_CH2_DSTBEGINADD 0xD000\n#define MW_DMA_CH2_SRCBURSTSTEP 0\n#define MW_DMA_CH2_DSTBURSTSTEP 0\n#define MW_DMA_CH2_SRCTRANSSTEP 0\n#define MW_DMA_CH2_DSTTRANSSTEP 0\n#define MW_DMA_CH2_WRAPSRCSIZE 65536\n#define MW_DMA_CH2_WRAPDSTSIZE 65536\n#define MW_DMA_CH2_SRCWRAPSTEP 0\n#define MW_DMA_CH2_DSTWRAPSTEP 0\n#define MW_DMA_CH2_ENABLEONESHOT 0\n#define MW_DMA_CH2_ENABLECONTINUOUS 1\n#define MW_DMA_CH2_GENINTERRUPT 0\n#define MW_DMA_CH2_ENABLEOVERFLOW 0\n#define MW_DMA_CH3_ENABLEDMACHANNEL 0\n#define MW_DMA_CH3_DATASIZE 0\n#define MW_DMA_CH3_INTERRUPTSRC 0\n#define MW_DMA_CH3_BURSTSIZE 0\n#define MW_DMA_CH3_TRANSFERSIZE 1\n#define MW_DMA_CH3_SRCBEGINADD 0xC000\n#define MW_DMA_CH3_DSTBEGINADD 0xD000\n#define MW_DMA_CH3_SRCBURSTSTEP 0\n#define MW_DMA_CH3_DSTBURSTSTEP 0\n#define MW_DMA_CH3_SRCTRANSSTEP 0\n#define MW_DMA_CH3_DSTTRANSSTEP 0\n#define MW_DMA_CH3_WRAPSRCSIZE 65536\n#define MW_DMA_CH3_WRAPDSTSIZE 65536\n#define MW_DMA_CH3_SRCWRAPSTEP 0\n#define MW_DMA_CH3_DSTWRAPSTEP 0\n#define MW_DMA_CH3_ENABLEONESHOT 0\n#define MW_DMA_CH3_ENABLECONTINUOUS 1\n#define MW_DMA_CH3_GENINTERRUPT 0\n#define MW_DMA_CH3_ENABLEOVERFLOW 0\n#define MW_DMA_CH4_ENABLEDMACHANNEL 0\n#define MW_DMA_CH4_DATASIZE 0\n#define MW_DMA_CH4_INTERRUPTSRC 0\n#define MW_DMA_CH4_BURSTSIZE 0\n#define MW_DMA_CH4_TRANSFERSIZE 1\n#define MW_DMA_CH4_SRCBEGINADD 0xC000\n#define MW_DMA_CH4_DSTBEGINADD 0xD000\n#define MW_DMA_CH4_SRCBURSTSTEP 0\n#define MW_DMA_CH4_DSTBURSTSTEP 0\n#define MW_DMA_CH4_SRCTRANSSTEP 0\n#define MW_DMA_CH4_DSTTRANSSTEP 0\n#define MW_DMA_CH4_WRAPSRCSIZE 65536\n#define MW_DMA_CH4_WRAPDSTSIZE 65536\n#define MW_DMA_CH4_SRCWRAPSTEP 0\n#define MW_DMA_CH4_DSTWRAPSTEP 0\n#define MW_DMA_CH4_ENABLEONESHOT 0\n#define MW_DMA_CH4_ENABLECONTINUOUS 1\n#define MW_DMA_CH4_GENINTERRUPT 0\n#define MW_DMA_CH4_ENABLEOVERFLOW 0\n#define MW_DMA_CH5_ENABLEDMACHANNEL 0\n#define MW_DMA_CH5_DATASIZE 0\n#define MW_DMA_CH5_INTERRUPTSRC 0\n#define MW_DMA_CH5_BURSTSIZE 0\n#define MW_DMA_CH5_TRANSFERSIZE 1\n#define MW_DMA_CH5_SRCBEGINADD 0xC000\n#define MW_DMA_CH5_DSTBEGINADD 0xD000\n#define MW_DMA_CH5_SRCBURSTSTEP 0\n#define MW_DMA_CH5_DSTBURSTSTEP 0\n#define MW_DMA_CH5_SRCTRANSSTEP 0\n#define MW_DMA_CH5_DSTTRANSSTEP 0\n#define MW_DMA_CH5_WRAPSRCSIZE 65536\n#define MW_DMA_CH5_WRAPDSTSIZE 65536\n#define MW_DMA_CH5_SRCWRAPSTEP 0\n#define MW_DMA_CH5_DSTWRAPSTEP 0\n#define MW_DMA_CH5_ENABLEONESHOT 0\n#define MW_DMA_CH5_ENABLECONTINUOUS 1\n#define MW_DMA_CH5_GENINTERRUPT 0\n#define MW_DMA_CH5_ENABLEOVERFLOW 0\n#define MW_DMA_CH6_ENABLEDMACHANNEL 0\n#define MW_DMA_CH6_DATASIZE 0\n#define MW_DMA_CH6_INTERRUPTSRC 0\n#define MW_DMA_CH6_BURSTSIZE 0\n#define MW_DMA_CH6_TRANSFERSIZE 1\n#define MW_DMA_CH6_SRCBEGINADD 0xC000\n#define MW_DMA_CH6_DSTBEGINADD 0xD000\n#define MW_DMA_CH6_SRCBURSTSTEP 0\n#define MW_DMA_CH6_DSTBURSTSTEP 0\n#define MW_DMA_CH6_SRCTRANSSTEP 0\n#define MW_DMA_CH6_DSTTRANSSTEP 0\n#define MW_DMA_CH6_WRAPSRCSIZE 65536\n#define MW_DMA_CH6_WRAPDSTSIZE 65536\n#define MW_DMA_CH6_SRCWRAPSTEP 0\n#define MW_DMA_CH6_DSTWRAPSTEP 0\n#define MW_DMA_CH6_ENABLEONESHOT 0\n#define MW_DMA_CH6_ENABLECONTINUOUS 1\n#define MW_DMA_CH6_GENINTERRUPT 0\n#define MW_DMA_CH6_ENABLEOVERFLOW 0\n#define MW_EMIF1_CLOCKDIV 1\n#define MW_EMIF1_CLOCKFREQUENCY 100\n#define MW_EMIF1_CS0 0\n#define MW_EMIF1_COLUMNADDRESS 0\n#define MW_EMIF1_PAGESIZE 256\n#define MW_EMIF1_BANKS 0\n#define MW_EMIF1_BUSWIDTH 0\n#define MW_EMIF1_T_RFC 3\n#define MW_EMIF1_T_RFC_NS 40\n#define MW_EMIF1_T_RP 1\n#define MW_EMIF1_T_RP_NS 20\n#define MW_EMIF1_T_RCD 2\n#define MW_EMIF1_T_RCD_NS 30\n#define MW_EMIF1_T_WR 1\n#define MW_EMIF1_T_WR_NS 20\n#define MW_EMIF1_T_RAS 4\n#define MW_EMIF1_T_RAS_NS 50\n#define MW_EMIF1_T_RC 6\n#define MW_EMIF1_T_RC_NS 70\n#define MW_EMIF1_T_RRD 1\n#define MW_EMIF1_T_RRD_NS 20\n#define MW_EMIF1_T_XSR 7\n#define MW_EMIF1_T_XSR_NS 80\n#define MW_EMIF1_REFRESHPERIOD 64\n#define MW_EMIF1_REFRESHCYCLE 4096\n#define MW_EMIF1_REFRESHRATE 1562\n#define MW_EMIF1_CASLATENCY 1\n#define MW_EMIF1_CS2 0\n#define MW_EMIF1_CS2_ASYNCHRONOUSMODE 0\n#define MW_EMIF1_CS2_ASYNCDATAWIDTH 1\n#define MW_EMIF1_CS2_R_SETUP 15\n#define MW_EMIF1_CS2_R_SETUP_NS 160\n#define MW_EMIF1_CS2_R_STROBE 63\n#define MW_EMIF1_CS2_R_STROBE_NS 640\n#define MW_EMIF1_CS2_R_HOLD 7\n#define MW_EMIF1_CS2_R_HOLD_NS 80\n#define MW_EMIF1_CS2_W_SETUP 15\n#define MW_EMIF1_CS2_W_SETUP_NS 160\n#define MW_EMIF1_CS2_W_STROBE 63\n#define MW_EMIF1_CS2_W_STROBE_NS 640\n#define MW_EMIF1_CS2_W_HOLD 7\n#define MW_EMIF1_CS2_W_HOLD_NS 80\n#define MW_EMIF1_CS2_TA_CYCLES 3\n#define MW_EMIF1_CS2_EXTEND_WAIT_ENABLE 0\n#define MW_EMIF1_CS3 0\n#define MW_EMIF1_CS3_ASYNCHRONOUSMODE 0\n#define MW_EMIF1_CS3_ASYNCDATAWIDTH 1\n#define MW_EMIF1_CS3_R_SETUP 15\n#define MW_EMIF1_CS3_R_SETUP_NS 160\n#define MW_EMIF1_CS3_R_STROBE 63\n#define MW_EMIF1_CS3_R_STROBE_NS 640\n#define MW_EMIF1_CS3_R_HOLD 7\n#define MW_EMIF1_CS3_R_HOLD_NS 80\n#define MW_EMIF1_CS3_W_SETUP 15\n#define MW_EMIF1_CS3_W_SETUP_NS 160\n#define MW_EMIF1_CS3_W_STROBE 63\n#define MW_EMIF1_CS3_W_STROBE_NS 640\n#define MW_EMIF1_CS3_W_HOLD 7\n#define MW_EMIF1_CS3_W_HOLD_NS 80\n#define MW_EMIF1_CS3_TA_CYCLES 3\n#define MW_EMIF1_CS3_EXTEND_WAIT_ENABLE 0\n#define MW_EMIF1_CS4 0\n#define MW_EMIF1_CS4_ASYNCHRONOUSMODE 0\n#define MW_EMIF1_CS4_ASYNCDATAWIDTH 1\n#define MW_EMIF1_CS4_R_SETUP 15\n#define MW_EMIF1_CS4_R_SETUP_NS 160\n#define MW_EMIF1_CS4_R_STROBE 63\n#define MW_EMIF1_CS4_R_STROBE_NS 640\n#define MW_EMIF1_CS4_R_HOLD 7\n#define MW_EMIF1_CS4_R_HOLD_NS 80\n#define MW_EMIF1_CS4_W_SETUP 15\n#define MW_EMIF1_CS4_W_SETUP_NS 160\n#define MW_EMIF1_CS4_W_STROBE 63\n#define MW_EMIF1_CS4_W_STROBE_NS 640\n#define MW_EMIF1_CS4_W_HOLD 7\n#define MW_EMIF1_CS4_W_HOLD_NS 80\n#define MW_EMIF1_CS4_TA_CYCLES 3\n#define MW_EMIF1_CS4_EXTEND_WAIT_ENABLE 0\n#define MW_EMIF1_EXTENDED_WAIT_CYCLE 128\n#define MW_EMIF1_EXTENDED_WAIT_POLARITY 0\n#define MW_EMIF1_WAITRISE 0\n#define MW_EMIF1_TIMEOUT 0\n#define MW_EMIF1_LINETRAP 0\n#define MW_EMIF2_CLOCKDIV 1\n#define MW_EMIF2_CLOCKFREQUENCY 100\n#define MW_EMIF2_CS0 0\n#define MW_EMIF2_COLUMNADDRESS 0\n#define MW_EMIF2_PAGESIZE 256\n#define MW_EMIF2_BANKS 0\n#define MW_EMIF2_BUSWIDTH 0\n#define MW_EMIF2_T_RFC 3\n#define MW_EMIF2_T_RFC_NS 40\n#define MW_EMIF2_T_RP 1\n#define MW_EMIF2_T_RP_NS 20\n#define MW_EMIF2_T_RCD 2\n#define MW_EMIF2_T_RCD_NS 30\n#define MW_EMIF2_T_WR 1\n#define MW_EMIF2_T_WR_NS 20\n#define MW_EMIF2_T_RAS 4\n#define MW_EMIF2_T_RAS_NS 50\n#define MW_EMIF2_T_RC 6\n#define MW_EMIF2_T_RC_NS 70\n#define MW_EMIF2_T_RRD 1\n#define MW_EMIF2_T_RRD_NS 20\n#define MW_EMIF2_T_XSR 7\n#define MW_EMIF2_T_XSR_NS 80\n#define MW_EMIF2_REFRESHPERIOD 64\n#define MW_EMIF2_REFRESHCYCLE 4096\n#define MW_EMIF2_REFRESHRATE 1562\n#define MW_EMIF2_CASLATENCY 1\n#define MW_EMIF2_CS2 0\n#define MW_EMIF2_CS2_ASYNCHRONOUSMODE 0\n#define MW_EMIF2_CS2_ASYNCDATAWIDTH 1\n#define MW_EMIF2_CS2_R_SETUP 15\n#define MW_EMIF2_CS2_R_SETUP_NS 160\n#define MW_EMIF2_CS2_R_STROBE 63\n#define MW_EMIF2_CS2_R_STROBE_NS 640\n#define MW_EMIF2_CS2_R_HOLD 7\n#define MW_EMIF2_CS2_R_HOLD_NS 80\n#define MW_EMIF2_CS2_W_SETUP 15\n#define MW_EMIF2_CS2_W_SETUP_NS 160\n#define MW_EMIF2_CS2_W_STROBE 63\n#define MW_EMIF2_CS2_W_STROBE_NS 640\n#define MW_EMIF2_CS2_W_HOLD 7\n#define MW_EMIF2_CS2_W_HOLD_NS 80\n#define MW_EMIF2_CS2_TA_CYCLES 3\n#define MW_EMIF2_CS2_EXTEND_WAIT_ENABLE 0\n#define MW_EMIF2_EXTENDED_WAIT_CYCLE 128\n#define MW_EMIF2_EXTENDED_WAIT_POLARITY 0\n#define MW_EMIF2_WAITRISE 0\n#define MW_EMIF2_TIMEOUT 0\n#define MW_EMIF2_LINETRAP 0\n#define MW_XINT_GPIOXINT1SEL 0\n#define MW_XINT_GPIOXINT2SEL 0\n#define MW_XINT_GPIOXINT3SEL 0\n#define MW_XINT_GPIOXINT4SEL 0\n#define MW_XINT_GPIOXINT5SEL 0\n#define MW_XINT_POLARITY1 0\n#define MW_XINT_POLARITY2 0\n#define MW_XINT_POLARITY3 0\n#define MW_XINT_POLARITY4 0\n#define MW_XINT_POLARITY5 0\n#define MW_XINT_GPIOXINT1SEL_IXBAR 0\n#define MW_XINT_GPIOXINT2SEL_IXBAR 0\n#define MW_XINT_GPIOXINT3SEL_IXBAR 0\n#define MW_XINT_GPIOXINT4SEL_IXBAR 0\n#define MW_XINT_GPIOXINT5SEL_IXBAR 0\n#define MW_EXTMODECOMPORT -1\n#define MW_EXECUTIONPROFILEBUFFERLEN 50.000000\n#define MW_SDCARD_ENABLE 0\n#define MW_SDCARD_SPIMODULE 0\n#define MW_SDCARD_SPIBAUDRATE 1\n#define MW_DATAVERSION 2016.02\n#define MW_CMPSS_ENABLE_MODULE_CMPSS1 0\n#define MW_CMPSS_CMPSS1_COMPH 0\n#define MW_CMPSS_CMPSS1_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS1_COMPH_DACSOURCESEL RAMP generator (RAMPSTS)\n#define MW_CMPSS_CMPSS1_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS1_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS1_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS1_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS1_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS1_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS1_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS1_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS1_COMPL 0\n#define MW_CMPSS_CMPSS1_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS1_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS1_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS1_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS1_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS1_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS1_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS1_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS1_COMP_SELREF 0\n#define MW_CMPSS_CMPSS1_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS1_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS1_COMP_COMPHYS 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS2 0\n#define MW_CMPSS_CMPSS2_COMPH 0\n#define MW_CMPSS_CMPSS2_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS2_COMPH_DACSOURCESEL RAMP generator (RAMPSTS)\n#define MW_CMPSS_CMPSS2_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS2_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS2_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS2_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS2_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS2_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS2_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS2_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS2_COMPL_CRTL 0.000000\n#define MW_CMPSS_CMPSS2_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS2_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS2_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS2_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS2_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS2_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS2_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS2_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS2_COMP_SELREF 0\n#define MW_CMPSS_CMPSS2_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS2_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS2_COMP_COMPHYS 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS3 0\n#define MW_CMPSS_CMPSS3_COMPH 0\n#define MW_CMPSS_CMPSS3_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS3_COMPH_DACSOURCESEL RAMP generator (RAMPSTS)\n#define MW_CMPSS_CMPSS3_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS3_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS3_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS3_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS3_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS3_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS3_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS3_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS3_COMPL_CRTL 0.000000\n#define MW_CMPSS_CMPSS3_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS3_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS3_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS3_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS3_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS3_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS3_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS3_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS3_COMP_SELREF 0\n#define MW_CMPSS_CMPSS3_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS3_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS3_COMP_COMPHYS 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS4 0\n#define MW_CMPSS_CMPSS4_COMPH 0\n#define MW_CMPSS_CMPSS4_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS4_COMPH_DACSOURCESEL RAMP generator (RAMPSTS)\n#define MW_CMPSS_CMPSS4_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS4_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS4_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS4_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS4_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS4_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS4_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS4_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS4_COMPL_CRTL 0.000000\n#define MW_CMPSS_CMPSS4_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS4_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS4_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS4_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS4_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS4_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS4_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS4_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS4_COMP_SELREF 0\n#define MW_CMPSS_CMPSS4_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS4_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS4_COMP_COMPHYS 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS5 0\n#define MW_CMPSS_CMPSS5_COMPH 0\n#define MW_CMPSS_CMPSS5_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS5_COMPH_DACSOURCESEL RAMP generator (RAMPSTS)\n#define MW_CMPSS_CMPSS5_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS5_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS5_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS5_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS5_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS5_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS5_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS5_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS5_COMPL_CRTL 0.000000\n#define MW_CMPSS_CMPSS5_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS5_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS5_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS5_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS5_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS5_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS5_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS5_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS5_COMP_SELREF 0\n#define MW_CMPSS_CMPSS5_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS5_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS5_COMP_COMPHYS 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS6 0\n#define MW_CMPSS_CMPSS6_COMPH 0\n#define MW_CMPSS_CMPSS6_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS6_COMPH_DACSOURCESEL RAMP generator (RAMPSTS)\n#define MW_CMPSS_CMPSS6_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS6_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS6_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS6_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS6_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS6_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS6_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS6_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS6_COMPL_CRTL 0.000000\n#define MW_CMPSS_CMPSS6_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS6_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS6_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS6_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS6_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS6_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS6_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS6_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS6_COMP_SELREF 0\n#define MW_CMPSS_CMPSS6_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS6_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS6_COMP_COMPHYS 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS7 0\n#define MW_CMPSS_CMPSS7_COMPH 0\n#define MW_CMPSS_CMPSS7_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS7_COMPH_DACSOURCESEL RAMP generator (RAMPSTS)\n#define MW_CMPSS_CMPSS7_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS7_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS7_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS7_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS7_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS7_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS7_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS7_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS7_COMPL_CRTL 0.000000\n#define MW_CMPSS_CMPSS7_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS7_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS7_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS7_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS7_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS7_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS7_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS7_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS7_COMP_SELREF 0\n#define MW_CMPSS_CMPSS7_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS7_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS7_COMP_COMPHYS 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS8 0\n#define MW_CMPSS_CMPSS8_COMPH 0\n#define MW_CMPSS_CMPSS8_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS8_COMPH_DACSOURCESEL RAMP generator (RAMPSTS)\n#define MW_CMPSS_CMPSS8_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS8_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS8_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS8_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS8_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS8_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS8_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS8_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS8_COMPL_CRTL 0.000000\n#define MW_CMPSS_CMPSS8_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS8_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS8_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS8_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS8_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS8_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS8_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS8_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS8_COMP_SELREF 0\n#define MW_CMPSS_CMPSS8_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS8_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS8_COMP_COMPHYS 0\n#define MW_CMPSS_CMPSS2_COMPL 0\n#define MW_CMPSS_CMPSS3_COMPL 0\n#define MW_CMPSS_CMPSS4_COMPL 0\n#define MW_CMPSS_CMPSS5_COMPL 0\n#define MW_CMPSS_CMPSS6_COMPL 0\n#define MW_CMPSS_CMPSS7_COMPL 0\n#define MW_CMPSS_CMPSS8_COMPL 0\n#define MW_SDFM1_F1 0\n#define MW_SDFM1_D1 0\n#define MW_SDFM1_C1 0\n#define MW_SDFM1_F1_MODE -1\n#define MW_SDFM1_F1_C_FILTERTYPE 1\n#define MW_SDFM1_F1_COSR 0\n#define MW_SDFM1_F1_HLT 0\n#define MW_SDFM1_F1_LLT 0\n#define MW_SDFM1_F1_D_FILTERTYPE 1\n#define MW_SDFM1_F1_DOSR 0\n#define MW_SDFM1_F1_EXTPWM 0\n#define MW_SDFM1_F1_IEL 0\n#define MW_SDFM1_F1_IEH 0\n#define MW_SDFM1_F1_MFIE 0\n#define MW_SDFM1_F1_AE 0\n#define MW_SDFM1_F2 0\n#define MW_SDFM1_D2 0\n#define MW_SDFM1_C2 0\n#define MW_SDFM1_F2_MODE -1\n#define MW_SDFM1_F2_C_FILTERTYPE 1\n#define MW_SDFM1_F2_COSR 0\n#define MW_SDFM1_F2_HLT 0\n#define MW_SDFM1_F2_LLT 0\n#define MW_SDFM1_F2_D_FILTERTYPE 1\n#define MW_SDFM1_F2_DOSR 0\n#define MW_SDFM1_F2_EXTPWM 0\n#define MW_SDFM1_F2_IEL 0\n#define MW_SDFM1_F2_IEH 0\n#define MW_SDFM1_F2_MFIE 0\n#define MW_SDFM1_F2_AE 0\n#define MW_SDFM1_F3 0\n#define MW_SDFM1_D3 0\n#define MW_SDFM1_C3 0\n#define MW_SDFM1_F3_MODE -1\n#define MW_SDFM1_F3_C_FILTERTYPE 1\n#define MW_SDFM1_F3_COSR 0\n#define MW_SDFM1_F3_HLT 0\n#define MW_SDFM1_F3_LLT 0\n#define MW_SDFM1_F3_D_FILTERTYPE 1\n#define MW_SDFM1_F3_DOSR 0\n#define MW_SDFM1_F3_EXTPWM 0\n#define MW_SDFM1_F3_IEL 0\n#define MW_SDFM1_F3_IEH 0\n#define MW_SDFM1_F3_MFIE 0\n#define MW_SDFM1_F3_AE 0\n#define MW_SDFM1_F4 0\n#define MW_SDFM1_D4 0\n#define MW_SDFM1_C4 0\n#define MW_SDFM1_F4_MODE -1\n#define MW_SDFM1_F4_C_FILTERTYPE 1\n#define MW_SDFM1_F4_COSR 0\n#define MW_SDFM1_F4_HLT 0\n#define MW_SDFM1_F4_LLT 0\n#define MW_SDFM1_F4_D_FILTERTYPE 1\n#define MW_SDFM1_F4_DOSR 0\n#define MW_SDFM1_F4_EXTPWM 0\n#define MW_SDFM1_F4_IEL 0\n#define MW_SDFM1_F4_IEH 0\n#define MW_SDFM1_F4_MFIE 0\n#define MW_SDFM1_F4_AE 0\n#define MW_SDFM1_PINVALUE_D1 16\n#define MW_SDFM1_PINVALUE_C1 17\n#define MW_SDFM1_PINVALUE_D2 18\n#define MW_SDFM1_PINVALUE_C2 19\n#define MW_SDFM1_PINVALUE_D3 20\n#define MW_SDFM1_PINVALUE_C3 21\n#define MW_SDFM1_PINVALUE_D4 22\n#define MW_SDFM1_PINVALUE_C4 23\n#define MW_SDFM1_PINMUX_D1 7\n#define MW_SDFM1_PINMUX_C1 7\n#define MW_SDFM1_PINMUX_D2 7\n#define MW_SDFM1_PINMUX_C2 7\n#define MW_SDFM1_PINMUX_D3 7\n#define MW_SDFM1_PINMUX_C3 7\n#define MW_SDFM1_PINMUX_D4 7\n#define MW_SDFM1_PINMUX_C4 7\n#define MW_SDFM2_F1 0\n#define MW_SDFM2_D1 0\n#define MW_SDFM2_C1 0\n#define MW_SDFM2_F1_MODE -1\n#define MW_SDFM2_F1_C_FILTERTYPE 1\n#define MW_SDFM2_F1_COSR 0\n#define MW_SDFM2_F1_HLT 0\n#define MW_SDFM2_F1_LLT 0\n#define MW_SDFM2_F1_D_FILTERTYPE 1\n#define MW_SDFM2_F1_DOSR 0\n#define MW_SDFM2_F1_EXTPWM 0\n#define MW_SDFM2_F1_IEL 0\n#define MW_SDFM2_F1_IEH 0\n#define MW_SDFM2_F1_MFIE 0\n#define MW_SDFM2_F1_AE 0\n#define MW_SDFM2_F2 0\n#define MW_SDFM2_D2 0\n#define MW_SDFM2_C2 0\n#define MW_SDFM2_F2_MODE -1\n#define MW_SDFM2_F2_C_FILTERTYPE 1\n#define MW_SDFM2_F2_COSR 0\n#define MW_SDFM2_F2_HLT 0\n#define MW_SDFM2_F2_LLT 0\n#define MW_SDFM2_F2_D_FILTERTYPE 1\n#define MW_SDFM2_F2_DOSR 0\n#define MW_SDFM2_F2_EXTPWM 0\n#define MW_SDFM2_F2_IEL 0\n#define MW_SDFM2_F2_IEH 0\n#define MW_SDFM2_F2_MFIE 0\n#define MW_SDFM2_F2_AE 0\n#define MW_SDFM2_F3 0\n#define MW_SDFM2_D3 0\n#define MW_SDFM2_C3 0\n#define MW_SDFM2_F3_MODE -1\n#define MW_SDFM2_F3_C_FILTERTYPE 1\n#define MW_SDFM2_F3_COSR 0\n#define MW_SDFM2_F3_HLT 0\n#define MW_SDFM2_F3_LLT 0\n#define MW_SDFM2_F3_D_FILTERTYPE 1\n#define MW_SDFM2_F3_DOSR 0\n#define MW_SDFM2_F3_EXTPWM 0\n#define MW_SDFM2_F3_IEL 0\n#define MW_SDFM2_F3_IEH 0\n#define MW_SDFM2_F3_MFIE 0\n#define MW_SDFM2_F3_AE 0\n#define MW_SDFM2_F4 0\n#define MW_SDFM2_D4 0\n#define MW_SDFM2_C4 0\n#define MW_SDFM2_F4_MODE -1\n#define MW_SDFM2_F4_C_FILTERTYPE 1\n#define MW_SDFM2_F4_COSR 0\n#define MW_SDFM2_F4_HLT 0\n#define MW_SDFM2_F4_LLT 0\n#define MW_SDFM2_F4_D_FILTERTYPE 1\n#define MW_SDFM2_F4_DOSR 0\n#define MW_SDFM2_F4_EXTPWM 0\n#define MW_SDFM2_F4_IEL 0\n#define MW_SDFM2_F4_IEH 0\n#define MW_SDFM2_F4_MFIE 0\n#define MW_SDFM2_F4_AE 0\n#define MW_SDFM2_PINVALUE_D1 24\n#define MW_SDFM2_PINVALUE_C1 25\n#define MW_SDFM2_PINVALUE_D2 26\n#define MW_SDFM2_PINVALUE_C2 27\n#define MW_SDFM2_PINVALUE_D3 28\n#define MW_SDFM2_PINVALUE_C3 29\n#define MW_SDFM2_PINVALUE_D4 30\n#define MW_SDFM2_PINVALUE_C4 31\n#define MW_SDFM2_PINMUX_D1 7\n#define MW_SDFM2_PINMUX_C1 7\n#define MW_SDFM2_PINMUX_D2 7\n#define MW_SDFM2_PINMUX_C2 7\n#define MW_SDFM2_PINMUX_D3 7\n#define MW_SDFM2_PINMUX_C3 7\n#define MW_SDFM2_PINMUX_D4 7\n#define MW_SDFM2_PINMUX_C4 7\n#define MW_PIL_COMMUNICATIONINTERFACE 0\n#define MW_PIL_SCIMODULE 0\n#define MW_PIL_COMPORT COM3\n#define MW_OVERRUNDETECTION_ENABLE_OVERRUN_DETECTION 0\n#define MW_OVERRUNDETECTION_CHECK_GPIO_STATUS 1\n#define MW_OVERRUNDETECTION_DIGITAL_OUTPUT_TO_SET_ON_OVERRUN 6\n#define MW_OVERRUNDETECTION_GPIOMODE 0\n#define MW_OVERRUNDETECTION_CUSTOM_LOGIC 0\n#define MW_OVERRUNDETECTION_PIE_NUMBER 0\n#define MW_OVERRUNDETECTION_CPU_NUMBER 0\n#define MW_OVERRUNDETECTION_CUSTOM_FUNCTION c2000_OverrunFunction\n#define MW_IXBAR_FLAG 49\n#define MW_IXBAR_I1 None\n#define MW_IXBAR_I2 None\n#define MW_IXBAR_I3 None\n#define MW_IXBAR_I4 0\n#define MW_IXBAR_I5 0\n#define MW_IXBAR_I6 0\n#define MW_IXBAR_I7 24\n#define MW_IXBAR_I8 25\n#define MW_IXBAR_I9 26\n#define MW_IXBAR_I10 20\n#define MW_IXBAR_I11 21\n#define MW_IXBAR_I12 23\n#define MW_IXBAR_I13 0\n#define MW_IXBAR_I14 0\n#define MW_IXBAR_ONE_TIME 0.000000\n#define MW_OUTPUTXBAR_OXBAR1 0\n#define MW_OUTPUTXBAR_OXBAR_MUX1 -1\n#define MW_OUTPUTXBAR_OXBAR1_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR1_GPIO 0\n#define MW_OUTPUTXBAR_OXBAR1_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR1_INVERT 0\n#define MW_OUTPUTXBAR_OXBAR2 0\n#define MW_OUTPUTXBAR_OXBAR_MUX2 -1\n#define MW_OUTPUTXBAR_OXBAR2_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR2_GPIO -1\n#define MW_OUTPUTXBAR_OXBAR2_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR2_INVERT 0\n#define MW_OUTPUTXBAR_OXBAR3 0\n#define MW_OUTPUTXBAR_OXBAR_MUX3 -1\n#define MW_OUTPUTXBAR_OXBAR3_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR3_GPIO -1\n#define MW_OUTPUTXBAR_OXBAR3_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR3_INVERT 0\n#define MW_OUTPUTXBAR_OXBAR4 0\n#define MW_OUTPUTXBAR_OXBAR_MUX4 -1\n#define MW_OUTPUTXBAR_OXBAR4_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR4_GPIO -1\n#define MW_OUTPUTXBAR_OXBAR4_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR4_INVERT 0\n#define MW_OUTPUTXBAR_OXBAR5 0\n#define MW_OUTPUTXBAR_OXBAR_MUX5 -1\n#define MW_OUTPUTXBAR_OXBAR5_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR5_GPIO -1\n#define MW_OUTPUTXBAR_OXBAR5_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR5_INVERT 0\n#define MW_OUTPUTXBAR_OXBAR6 0\n#define MW_OUTPUTXBAR_OXBAR_MUX6 -1\n#define MW_OUTPUTXBAR_OXBAR6_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR6_GPIO -1\n#define MW_OUTPUTXBAR_OXBAR6_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR6_INVERT 0\n#define MW_OUTPUTXBAR_OXBAR7 0\n#define MW_OUTPUTXBAR_OXBAR_MUX7 -1\n#define MW_OUTPUTXBAR_OXBAR7_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR7_GPIO -1\n#define MW_OUTPUTXBAR_OXBAR7_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR7_INVERT 0\n#define MW_OUTPUTXBAR_OXBAR8 0\n#define MW_OUTPUTXBAR_OXBAR_MUX8 -1\n#define MW_OUTPUTXBAR_OXBAR8_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR8_GPIO -1\n#define MW_OUTPUTXBAR_OXBAR8_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR8_INVERT 0\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERSIZE 1000\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_MAXCONTIGSAMPLES 8\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_LOGGINGBUFFERSIZE 1000\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_MAXCONTIGSAMPLES 10\n#define MW_CLA_LSCONFIGENABLE 0\n#define MW_CLA_PMLENGTH 0\n#define MW_CLA_DMLENGTH 1\n#define MW_CLA_CPULSLENGTH 6\n#define MW_IOBLOCKSMODE deployed\n#define MW_CLBXBAR_AUXSIG0 0\n#define MW_CLBXBAR_AUXSIG_MUX0 -1\n#define MW_CLBXBAR_AUXSIG0_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG0_INVERT 0\n#define MW_CLBXBAR_AUXSIG1 0\n#define MW_CLBXBAR_AUXSIG_MUX1 -1\n#define MW_CLBXBAR_AUXSIG1_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG1_INVERT 0\n#define MW_CLBXBAR_AUXSIG2 0\n#define MW_CLBXBAR_AUXSIG_MUX2 -1\n#define MW_CLBXBAR_AUXSIG2_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG2_INVERT 0\n#define MW_CLBXBAR_AUXSIG3 0\n#define MW_CLBXBAR_AUXSIG_MUX3 -1\n#define MW_CLBXBAR_AUXSIG3_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG3_INVERT 0\n#define MW_CLBXBAR_AUXSIG4 0\n#define MW_CLBXBAR_AUXSIG_MUX4 -1\n#define MW_CLBXBAR_AUXSIG4_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG4_INVERT 0\n#define MW_CLBXBAR_AUXSIG5 0\n#define MW_CLBXBAR_AUXSIG_MUX5 -1\n#define MW_CLBXBAR_AUXSIG5_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG5_INVERT 0\n#define MW_CLBXBAR_AUXSIG6 0\n#define MW_CLBXBAR_AUXSIG_MUX6 -1\n#define MW_CLBXBAR_AUXSIG6_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG6_INVERT 0\n#define MW_CLBXBAR_AUXSIG7 0\n#define MW_CLBXBAR_AUXSIG_MUX7 -1\n#define MW_CLBXBAR_AUXSIG7_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG7_INVERT 0\n#define MW_CLB_TILE1 0\n#define MW_CLB_TILE1_NAME TILE1\n#define MW_CLB_TILE1_IN0_MUX 0\n#define MW_CLB_TILE1_IN0 -1\n#define MW_CLB_TILE1_IN0_FILTER 0\n#define MW_CLB_TILE1_IN0_SYNC 0\n#define MW_CLB_TILE1_IN1_MUX 0\n#define MW_CLB_TILE1_IN1 -1\n#define MW_CLB_TILE1_IN1_FILTER 0\n#define MW_CLB_TILE1_IN1_SYNC 0\n#define MW_CLB_TILE1_IN2_MUX 0\n#define MW_CLB_TILE1_IN2 -1\n#define MW_CLB_TILE1_IN2_FILTER 0\n#define MW_CLB_TILE1_IN2_SYNC 0\n#define MW_CLB_TILE1_IN3_MUX 0\n#define MW_CLB_TILE1_IN3 -1\n#define MW_CLB_TILE1_IN3_FILTER 0\n#define MW_CLB_TILE1_IN3_SYNC 0\n#define MW_CLB_TILE1_IN4_MUX 0\n#define MW_CLB_TILE1_IN4 -1\n#define MW_CLB_TILE1_IN4_FILTER 0\n#define MW_CLB_TILE1_IN4_SYNC 0\n#define MW_CLB_TILE1_IN5_MUX 0\n#define MW_CLB_TILE1_IN5 -1\n#define MW_CLB_TILE1_IN5_FILTER 0\n#define MW_CLB_TILE1_IN5_SYNC 0\n#define MW_CLB_TILE1_IN6_MUX 0\n#define MW_CLB_TILE1_IN6 -1\n#define MW_CLB_TILE1_IN6_FILTER 0\n#define MW_CLB_TILE1_IN6_SYNC 0\n#define MW_CLB_TILE1_IN7_MUX 0\n#define MW_CLB_TILE1_IN7 -1\n#define MW_CLB_TILE1_IN7_FILTER 0\n#define MW_CLB_TILE1_IN7_SYNC 0\n#define MW_CLB_TILE1_OUT0_0 0\n#define MW_CLB_TILE1_OUT0_1 0\n#define MW_CLB_TILE1_OUT1_0 0\n#define MW_CLB_TILE1_OUT1_1 0\n#define MW_CLB_TILE1_OUT2_0 0\n#define MW_CLB_TILE1_OUT2_1 0\n#define MW_CLB_TILE1_OUT3_0 0\n#define MW_CLB_TILE1_OUT3_1 0\n#define MW_CLB_TILE1_OUT4_0 0\n#define MW_CLB_TILE1_OUT4_1 0\n#define MW_CLB_TILE1_OUT5_0 0\n#define MW_CLB_TILE1_OUT5_1 0\n#define MW_CLB_TILE1_OUT6_0 0\n#define MW_CLB_TILE1_OUT6_1 0\n#define MW_CLB_TILE1_OUT7_0 0\n#define MW_CLB_TILE1_OUT7_1 0\n#define MW_CLB_TILE2 0\n#define MW_CLB_TILE2_NAME TILE2\n#define MW_CLB_TILE2_IN0_MUX 0\n#define MW_CLB_TILE2_IN0 -1\n#define MW_CLB_TILE2_IN0_FILTER 0\n#define MW_CLB_TILE2_IN0_SYNC 0\n#define MW_CLB_TILE2_IN1_MUX 0\n#define MW_CLB_TILE2_IN1 -1\n#define MW_CLB_TILE2_IN1_FILTER 0\n#define MW_CLB_TILE2_IN1_SYNC 0\n#define MW_CLB_TILE2_IN2_MUX 0\n#define MW_CLB_TILE2_IN2 -1\n#define MW_CLB_TILE2_IN2_FILTER 0\n#define MW_CLB_TILE2_IN2_SYNC 0\n#define MW_CLB_TILE2_IN3_MUX 0\n#define MW_CLB_TILE2_IN3 -1\n#define MW_CLB_TILE2_IN3_FILTER 0\n#define MW_CLB_TILE2_IN3_SYNC 0\n#define MW_CLB_TILE2_IN4_MUX 0\n#define MW_CLB_TILE2_IN4 -1\n#define MW_CLB_TILE2_IN4_FILTER 0\n#define MW_CLB_TILE2_IN4_SYNC 0\n#define MW_CLB_TILE2_IN5_MUX 0\n#define MW_CLB_TILE2_IN5 -1\n#define MW_CLB_TILE2_IN5_FILTER 0\n#define MW_CLB_TILE2_IN5_SYNC 0\n#define MW_CLB_TILE2_IN6_MUX 0\n#define MW_CLB_TILE2_IN6 -1\n#define MW_CLB_TILE2_IN6_FILTER 0\n#define MW_CLB_TILE2_IN6_SYNC 0\n#define MW_CLB_TILE2_IN7_MUX 0\n#define MW_CLB_TILE2_IN7 -1\n#define MW_CLB_TILE2_IN7_FILTER 0\n#define MW_CLB_TILE2_IN7_SYNC 0\n#define MW_CLB_TILE2_OUT0_0 0\n#define MW_CLB_TILE2_OUT0_1 0\n#define MW_CLB_TILE2_OUT1_0 0\n#define MW_CLB_TILE2_OUT1_1 0\n#define MW_CLB_TILE2_OUT2_0 0\n#define MW_CLB_TILE2_OUT2_1 0\n#define MW_CLB_TILE2_OUT3_0 0\n#define MW_CLB_TILE2_OUT3_1 0\n#define MW_CLB_TILE2_OUT4_0 0\n#define MW_CLB_TILE2_OUT4_1 0\n#define MW_CLB_TILE2_OUT5_0 0\n#define MW_CLB_TILE2_OUT5_1 0\n#define MW_CLB_TILE2_OUT6_0 0\n#define MW_CLB_TILE2_OUT6_1 0\n#define MW_CLB_TILE2_OUT7_0 0\n#define MW_CLB_TILE2_OUT7_1 0\n#define MW_CLB_TILE3 0\n#define MW_CLB_TILE3_NAME TILE3\n#define MW_CLB_TILE3_IN0_MUX 0\n#define MW_CLB_TILE3_IN0 -1\n#define MW_CLB_TILE3_IN0_FILTER 0\n#define MW_CLB_TILE3_IN0_SYNC 0\n#define MW_CLB_TILE3_IN1_MUX 0\n#define MW_CLB_TILE3_IN1 -1\n#define MW_CLB_TILE3_IN1_FILTER 0\n#define MW_CLB_TILE3_IN1_SYNC 0\n#define MW_CLB_TILE3_IN2_MUX 0\n#define MW_CLB_TILE3_IN2 -1\n#define MW_CLB_TILE3_IN2_FILTER 0\n#define MW_CLB_TILE3_IN2_SYNC 0\n#define MW_CLB_TILE3_IN3_MUX 0\n#define MW_CLB_TILE3_IN3 -1\n#define MW_CLB_TILE3_IN3_FILTER 0\n#define MW_CLB_TILE3_IN3_SYNC 0\n#define MW_CLB_TILE3_IN4_MUX 0\n#define MW_CLB_TILE3_IN4 -1\n#define MW_CLB_TILE3_IN4_FILTER 0\n#define MW_CLB_TILE3_IN4_SYNC 0\n#define MW_CLB_TILE3_IN5_MUX 0\n#define MW_CLB_TILE3_IN5 -1\n#define MW_CLB_TILE3_IN5_FILTER 0\n#define MW_CLB_TILE3_IN5_SYNC 0\n#define MW_CLB_TILE3_IN6_MUX 0\n#define MW_CLB_TILE3_IN6 -1\n#define MW_CLB_TILE3_IN6_FILTER 0\n#define MW_CLB_TILE3_IN6_SYNC 0\n#define MW_CLB_TILE3_IN7_MUX 0\n#define MW_CLB_TILE3_IN7 -1\n#define MW_CLB_TILE3_IN7_FILTER 0\n#define MW_CLB_TILE3_IN7_SYNC 0\n#define MW_CLB_TILE3_OUT0_0 0\n#define MW_CLB_TILE3_OUT0_1 0\n#define MW_CLB_TILE3_OUT1_0 0\n#define MW_CLB_TILE3_OUT1_1 0\n#define MW_CLB_TILE3_OUT2_0 0\n#define MW_CLB_TILE3_OUT2_1 0\n#define MW_CLB_TILE3_OUT3_0 0\n#define MW_CLB_TILE3_OUT3_1 0\n#define MW_CLB_TILE3_OUT4_0 0\n#define MW_CLB_TILE3_OUT4_1 0\n#define MW_CLB_TILE3_OUT5_0 0\n#define MW_CLB_TILE3_OUT5_1 0\n#define MW_CLB_TILE3_OUT6_0 0\n#define MW_CLB_TILE3_OUT6_1 0\n#define MW_CLB_TILE3_OUT7_0 0\n#define MW_CLB_TILE3_OUT7_1 0\n#define MW_CLB_TILE4 0\n#define MW_CLB_TILE4_NAME TILE4\n#define MW_CLB_TILE4_IN0_MUX 0\n#define MW_CLB_TILE4_IN0 -1\n#define MW_CLB_TILE4_IN0_FILTER 0\n#define MW_CLB_TILE4_IN0_SYNC 0\n#define MW_CLB_TILE4_IN1_MUX 0\n#define MW_CLB_TILE4_IN1 -1\n#define MW_CLB_TILE4_IN1_FILTER 0\n#define MW_CLB_TILE4_IN1_SYNC 0\n#define MW_CLB_TILE4_IN2_MUX 0\n#define MW_CLB_TILE4_IN2 -1\n#define MW_CLB_TILE4_IN2_FILTER 0\n#define MW_CLB_TILE4_IN2_SYNC 0\n#define MW_CLB_TILE4_IN3_MUX 0\n#define MW_CLB_TILE4_IN3 -1\n#define MW_CLB_TILE4_IN3_FILTER 0\n#define MW_CLB_TILE4_IN3_SYNC 0\n#define MW_CLB_TILE4_IN4_MUX 0\n#define MW_CLB_TILE4_IN4 -1\n#define MW_CLB_TILE4_IN4_FILTER 0\n#define MW_CLB_TILE4_IN4_SYNC 0\n#define MW_CLB_TILE4_IN5_MUX 0\n#define MW_CLB_TILE4_IN5 -1\n#define MW_CLB_TILE4_IN5_FILTER 0\n#define MW_CLB_TILE4_IN5_SYNC 0\n#define MW_CLB_TILE4_IN6_MUX 0\n#define MW_CLB_TILE4_IN6 -1\n#define MW_CLB_TILE4_IN6_FILTER 0\n#define MW_CLB_TILE4_IN6_SYNC 0\n#define MW_CLB_TILE4_IN7_MUX 0\n#define MW_CLB_TILE4_IN7 -1\n#define MW_CLB_TILE4_IN7_FILTER 0\n#define MW_CLB_TILE4_IN7_SYNC 0\n#define MW_CLB_TILE4_OUT0_0 0\n#define MW_CLB_TILE4_OUT1_0 0\n#define MW_CLB_TILE4_OUT2_0 0\n#define MW_CLB_TILE4_OUT3_0 0\n#define MW_CLB_TILE4_OUT4_0 0\n#define MW_CLB_TILE4_OUT4_1 0\n#define MW_CLB_TILE4_OUT5_0 0\n#define MW_CLB_TILE4_OUT5_1 0\n#define MW_CLB_TILE4_OUT6_0 0\n#define MW_CLB_TILE4_OUT6_1 0\n#define MW_CLB_TILE4_OUT7_0 0\n#define MW_CLB_TILE4_OUT7_1 0\n#define MW_CLB_HEADER clb_config.h\n#define MW_CLB_SOURCE clb_config.c\n#define MW_SIMULINKIO_COMMUNICATIONINTERFACE 0\n#define MW_SIMULINKIO_SCIMODULE 0\n#define MW_SIMULINKIO_MODELTRANSPORTDATAFCN codertarget.simulinkIO.tic2000.getModelTransportInfo\n#define MW_SIMULINKIO_SERVERDEPLOYFCN codertarget.simulinkIO.tic2000.updateServer\n#define MW_SIMULINKIO_COMPORT COM3\n#define MW_ESB_PROCESSINGUNIT c28xCPU1\n#define MW_ESB_SIMDIAGSHOWINSDI 1\n#define MW_ESB_SIMDIAGSAVETOFILE 1\n#define MW_ESB_SIMDIAGOVERWRITEFILE 0\n#define MW_ESB_HWDIAGSHOWINSDI 0\n#define MW_ESB_HWDIAGSAVETOFILE 0\n#define MW_ESB_HWDIAGOVERWRITEFILE 0\n#define MW_ESB_HWDIAGINSTRUMENTATION Code\n#define MW_ESB_HWDIAGRECORDING Continuous\n#define MW_ESB_HWDIAGSTREAMINGMODETYPE Unlimited\n#define MW_ESB_HWDIAGBUFFERSIZE 1024.000000\n#define MW_ESB_HWDIAGNUMBUFFERS 1.000000\n#define MW_ESB_HWDIAGVIEWLEVEL Task manager tasks\n#define MW_ESB_SETRNG 0\n#define MW_ESB_RNGSEED default\n#define MW_ESB_CACHEDATA 0\n#define MW_ESB_SCHEDULEEDITORSCHEDULERESET 0\n#define MW_TASKMAP_TASKS_HWI_ADCB1_INT_EVENT1_MAPPEDGROUP ADC - Analog to Digital Converter\n#define MW_TASKMAP_TASKS_HWI_ADCB1_INT_EVENT1_MAPPEDINTERRUPT ADCB1_INT\n#define MW_TASKMAP_TASKS_HWI_ADCB1_INT_EVENT1_MAPPEDSOURCE Default event\n#define MW_TASKMAP_TASKS_HWI_ADCB1_INT_EVENT1_DISABLEPREMPTION on\n#define MW_TASKMAP_TASKS_HWI_ADCB1_INT_EVENT1_CLEARINTERRUPTFLAGSATENDOFEVENT on\n#define MW_TASKMAP_TASKS_HWI_ADCB1_INT_EVENT1_TASKPRIORITY 30\n#define MW_TASKMAP_TASKS_HWI_ADCB1_INT_EVENT1_EVENTORDER 1.000000\n#define MW_TASKMAP_TASKS_HWI_SCIA_RX_INT_EVENT1_MAPPEDGROUP SCI - Serial Communications Interface\n#define MW_TASKMAP_TASKS_HWI_SCIA_RX_INT_EVENT1_MAPPEDINTERRUPT SCIA_RX_INT\n#define MW_TASKMAP_TASKS_HWI_SCIA_RX_INT_EVENT1_MAPPEDSOURCE Default event\n#define MW_TASKMAP_TASKS_HWI_SCIA_RX_INT_EVENT1_DISABLEPREMPTION off\n#define MW_TASKMAP_TASKS_HWI_SCIA_RX_INT_EVENT1_CLEARINTERRUPTFLAGSATENDOFEVENT on\n#define MW_TASKMAP_TASKS_HWI_SCIA_RX_INT_EVENT1_TASKPRIORITY 50\n#define MW_TASKMAP_TASKS_HWI_SCIA_RX_INT_EVENT1_EVENTORDER 1.000000\n#define MW_FPGADESIGN_PROJECTFOLDER soc_prj\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"c2000HardwareTimerConfig.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\c2b\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"/* Copyrights 2016-2021, MathWorks Inc */\n#include \"MW_target_hardware_resources.h\"\n#include \"rtwtypes.h\"\n\nvoid hardwareTimer1Init(void)\n{\n  /* InitCpuTimers() - CPU Timers are initialized in\n   * MW_c28xx_board.c in the generated code.\n   */\n  CpuTimer1Regs.PRD.all = 0xFFFFFFFF;  /* max Period*/\n  CpuTimer1Regs.TIM.all = 0xFFFFFFFF;  /* set Ctr*/\n#if defined(MW_TIMER_PRESCALE_FOR_XCP)\n  CpuTimer1Regs.TPR.all = (0xFF & (MW_TIMER_PRESCALE_FOR_XCP - 1));         /* prescaler defined in make file dynamically based on clock */\n#else\n  CpuTimer1Regs.TPR.all = 0x00;        /* no prescaler    */\n#endif\n  StartCpuTimer1();\n}\n\n/* EOF */\n"},{"name":"c2837xDBoard_Realtime_Support.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\c2b\\tic2000_shared\\src","tag":"","groupDisplay":"Other files","code":"/*\n *   Copyright 2015-2023 The MathWorks, Inc.\n *\n *\n */\n\n#include \"MW_target_hardware_resources.h\"\n#include \"MW_f2837xD_includes.h\"\n#include \"MW_ipc_helper.h\"\n\nextern Uint16 RamfuncsLoadSize;\nextern Uint16 Cla1funcsRunStart;\nextern Uint16 Cla1funcsLoadStart;\nextern Uint16 Cla1funcsLoadSize;\nextern Uint16 Cla1mathTablesRunStart;\nextern Uint16 Cla1mathTablesLoadStart;\nextern Uint16 Cla1mathTablesLoadSize;\n#ifdef CPU1\nextern interrupt void IPC0_INT_isr(void);\nvoid (*CIPC0_INT_fptr)(void) = NULL;\nuint32_t mwInitStart = 0;\nuint32_t mwInitEnd = 0;\n__interrupt void CPU02toCPU01IPC0IntHandler(void);\nUint32 setGPIOForCPU2(Uint32 gpioData);\nUint32 setInXBARForCPU2(Uint32 inData);\nUint32 setOutXBARForCPU2(Uint32 inData);\nUint32 setEpwmXBARForCPU2(Uint32 inData);\nUint32 setCLBXBARForCPU2(Uint32 inData);\nUint32 setSyncSocRegsForCPU2(Uint32 inData);\nvolatile uint16_t ErrorFlag;\n#else\nvoid configureCPU2Peripherals(Uint32 gpioNumber, Uint32 gpGRegValA, Uint32 gpRegValA);\nvoid configureInputXBar(Uint32 gpioNumber, Uint32 inputXbarNumber);\nvoid configureOutputXBar(Uint32 xbar , Uint32 mux, Uint32 muxVal, Uint32 invert, Uint32 latch);\nvoid configureEpwmXBar(Uint32 xbar , Uint32 mux, Uint32 muxVal, Uint32 invert);\nvoid configureCLBXbarInCPU2(Uint32 xbar , Uint32 mux, Uint32 muxVal, Uint32 invert);\nvoid configureSyncSocRegsInCPU2(Uint32 syncSelectVal , Uint32 syncSelectPosition);\n#endif\nvoid initSetGPIOIPC(void);\n\n#if MW_RUNTIME_FLASHLOAD\nextern Uint16 MW_RamfuncsRunStart;\nextern Uint16 MW_RamfuncsLoadSize;\nextern Uint16 MW_RamfuncsLoadStart;\n#endif\nextern Uint16 Cla1ConstRunStart, Cla1ConstLoadStart, Cla1ConstLoadSize;\nvoid c2000_flash_init(void)\n{\n  #if MW_RUNTIME_FLASHLOAD\n  /* Copy InitFlash function code and Flash setup code to RAM */\n  memcpy(&RamfuncsRunStart,&RamfuncsLoadStart, (Uint32)(&RamfuncsLoadEnd-&RamfuncsLoadStart));\n  memcpy(&MW_RamfuncsRunStart, &MW_RamfuncsLoadStart, (Uint32)&MW_RamfuncsLoadSize);\n  #ifdef CLA_BLOCK_INCLUDED\n    memcpy(&Cla1funcsRunStart, &Cla1funcsLoadStart, (Uint32)&Cla1funcsLoadSize);\n    memcpy(&Cla1ConstRunStart, &Cla1ConstLoadStart, (Uint32)&Cla1ConstLoadSize);\n    /*memcpy(&Cla1mathTablesRunStart, &Cla1mathTablesLoadStart, (Uint32)&Cla1mathTablesLoadSize); */\n  #endif\n  /* Call Flash Initialization to setup flash waitstates\n   This function must reside in RAM */\n  InitFlash();\n  #endif\n}\n\nvoid initSetGPIOIPC(void)\n{\n\n    uint32_t *pulMsgRam;\n    volatile uint32_t ipcCountVar = 0;\n    #ifdef CPU1\n\tuint32_t i = 0;\n\tuint32_t MemCfgRegVar = 0;\n        EALLOW; // This is needed to write to EALLOW protected registers\n        PieVectTable.IPC0_INT = &CPU02toCPU01IPC0IntHandler;\n        /*Each global shared RAM section size is 4096 (2^12)*/\n        for (i=((uint32_t)CPU2_RAMGS_DATA_START) >> 12; i < (((uint32_t)CPU2_RAMGS_DATA_LENGTH + (uint32_t)CPU2_RAMGS_DATA_START) >> 12); i++)\n        {\n            /*Global shred RAM strts at 0xC000*/\n            MemCfgRegVar = MemCfgRegVar | (1UL<<(i-12));\n        }\n        for (i=((uint32_t)CPU2_RAMGS_PROG_START) >> 12; i < (((uint32_t)CPU2_RAMGS_PROG_LENGTH + (uint32_t)CPU2_RAMGS_PROG_START) >> 12); i++)\n        {\n            MemCfgRegVar = MemCfgRegVar | (1UL<<(i-12));\n        }\n        MemCfgRegs.GSxMSEL.all = MemCfgRegs.GSxMSEL.all | MemCfgRegVar;\n        EDIS;    // This is needed to disable write to EALLOW protected registers\n\t\t\n\t    // Any new entry to pulMsgRam should follow with change in starting address CPU01_TO_CPU02_PASSMSG\n        pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n        pulMsgRam[0] = (uint32_t)&setGPIOForCPU2;\n        pulMsgRam[1] = (uint32_t)&mwInitStart;\n        pulMsgRam[2] = (uint32_t)&mwInitEnd;\n        pulMsgRam[3] = (uint32_t)&setInXBARForCPU2;\n        pulMsgRam[4] = (uint32_t)&setOutXBARForCPU2;\n        pulMsgRam[5] = (uint32_t)&setEpwmXBARForCPU2;\n        pulMsgRam[6] = (uint32_t)&setCLBXBARForCPU2;\n        pulMsgRam[7] = (uint32_t)&setSyncSocRegsForCPU2;\n        PieCtrlRegs.PIEIER1.bit.INTx13 = 1;     // IPC INT0\n        IER |= M_INT1;\n        EINT;  // Enable Global interrupt INTM\n        ERTM;  // Enable Global realtime interrupt DBGM\n        \n    //#if MW_RUNTIME_FLASHLOAD\n      #ifndef TIC2000_SOC_BASEPRODUCT\n        //Wait for CPU2 to get ready to accept boot command from CPU1\n        while (((IpcRegs.IPCBOOTSTS & 0x0000000F) != C2_BOOTROM_BOOTSTS_SYSTEM_READY) && (700 > ipcCountVar))\n        {\n            ipcCountVar++;\n        }\n        //CPU01 to CPU02 IPC Boot Mode Register\n        IpcRegs.IPCBOOTMODE = C1C2_BROM_BOOTMODE_BOOT_FROM_FLASH;\n        // CPU01 To CPU02 IPC Command Register\n        IpcRegs.IPCSENDCOM  = BROM_IPC_EXECUTE_BOOTMODE_CMD;\n        // CPU01 to CPU02 IPC flag register\n        IpcRegs.IPCSET.all = 0x80000001;\n        ipcCountVar = 0;\n        // Give ~35 usec delay to start CPU2 init\n        while (500 > ipcCountVar) {\n            ipcCountVar++;\n        }\n      #endif\n\n    //#endif\n\n    #else\n        #ifndef TIC2000_SOC_BASEPRODUCT\n        pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n        IPCLiteLtoRDataWrite(IPC_FLAG0, pulMsgRam[1], 0x425,\n                         IPC_LENGTH_32_BITS, IPC_FLAG31);\n        #endif\n    #endif\n}\n\n#ifdef CPU1\nUint32 setGPIOForCPU2(Uint32 gpioData)\n{\n    if (((gpioData & 0xFF000000)>>24) == GPIO_MUX_CPU2CLA) /* from CLA inside CPU2, GPIO_MUX_CPU2CLA defined to value 3*/\n    {\n        gpioData = gpioData & 0x00FFFFFF; /* remove added encryption GPIO_MUX_CPU2CLA, MSB is the flag and we use only flag 0*/\n        GPIO_SetupPinMux(gpioData & 0x000000FF, GPIO_MUX_CPU2CLA, (gpioData & 0x0000FF00)>>8);\n        GPIO_SetupPinOptions(gpioData & 0x000000FF, (gpioData & 0x00FF0000)>>16, (gpioData & 0xFF000000)>>24);\n    }\n    else\n    {\n        GPIO_SetupPinMux(gpioData & 0x000000FF, GPIO_MUX_CPU2, (gpioData & 0x0000FF00)>>8);/* From CPU2*/\n        GPIO_SetupPinOptions(gpioData & 0x000000FF, (gpioData & 0x00FF0000)>>16, (gpioData & 0xFF000000)>>24);\n    }\n    return 1;\n}\n\nUint32 setInXBARForCPU2(Uint32 inData)\n{\n    Uint16 pin = (Uint16)(inData & 0x000000FF);\n    EALLOW;\n    switch((inData & 0x0000FF00) >> 8)\n    {\n        case 1:\n            InputXbarRegs.INPUT1SELECT = pin;\n            break;\n        case 2:\n            InputXbarRegs.INPUT2SELECT = pin;\n            break;\n        case 3:\n            InputXbarRegs.INPUT3SELECT = pin;\n            break;\n        case 4:\n            InputXbarRegs.INPUT4SELECT = pin;\n            break;\n        case 5:\n            InputXbarRegs.INPUT5SELECT = pin;\n            break;\n        case 6:\n            InputXbarRegs.INPUT6SELECT = pin;\n            break;\n        case 7:\n            InputXbarRegs.INPUT7SELECT = pin;\n            break;\n        case 8:\n            InputXbarRegs.INPUT8SELECT = pin;\n            break;\n        case 9:\n            InputXbarRegs.INPUT9SELECT = pin;\n            break;\n        case 10:\n            InputXbarRegs.INPUT10SELECT = pin;\n            break;\n        case 11:\n            InputXbarRegs.INPUT11SELECT = pin;\n            break;\n        case 12:\n            InputXbarRegs.INPUT12SELECT = pin;\n            break;\n        case 13:\n            InputXbarRegs.INPUT13SELECT = pin;\n            break;\n        case 14:\n            InputXbarRegs.INPUT14SELECT = pin;\n            break;\n    }\n    EDIS;\n    return 1;\n}\n\nUint32 setOutXBARForCPU2(Uint32 inData)\n{\n    volatile Uint32 *muxEnableRegAddr;\n    volatile Uint32 *muxRegAddr;\n    volatile Uint32 *muxLatchRegAddr;\n    volatile Uint32 *muxInvertRegAddr;\n    Uint16 latch = (Uint16)((inData & 0xF0000000) >> 28);\n    Uint16 invert = (Uint16)((inData & 0x0F000000) >> 24);\n    Uint16 muxVal = (Uint16)((inData & 0x00FF0000) >> 16);\n    Uint16 mux = (Uint16)((inData & 0x0000FF00) >> 8);\n    Uint16 xbar = (Uint16)(inData & 0x000000FF);\n    Uint16 muxPosition = mux%16;\n    \n    muxRegAddr          = (Uint32 *)&OutputXbarRegs + ((2*xbar)-2) + (mux/16);\n    muxEnableRegAddr    = (Uint32 *)&OutputXbarRegs + 0x10 + (xbar-1);\n    muxLatchRegAddr    = (Uint32 *)&OutputXbarRegs + 0x1B;\n    muxInvertRegAddr    = (Uint32 *)&OutputXbarRegs + 0x1C;\n    EALLOW;\n    *muxRegAddr        |= (Uint32)(muxVal & 0x3) << (2*muxPosition);\n    *muxEnableRegAddr  |= (Uint32)1 << mux;\n    *muxLatchRegAddr   |= (Uint32)(latch & 0x1) << (xbar-1);\n    *muxInvertRegAddr  |= (Uint32)(invert & 0x1) << (xbar-1);\n    EDIS;\n    return 1;\n}\n\nUint32 setEpwmXBARForCPU2(Uint32 inData)\n{\n    volatile Uint32 *muxEnableRegAddr;\n    volatile Uint32 *muxRegAddr;\n    volatile Uint32 *muxInvertRegAddr;\n    Uint16 invert = (Uint16)((inData & 0x0F000000) >> 24);\n    Uint16 muxVal = (Uint16)((inData & 0x00FF0000) >> 16);\n    Uint16 mux = (Uint16)((inData & 0x0000FF00) >> 8);\n    Uint16 xbar = (Uint16)(inData & 0x000000FF);\n    Uint16 muxPosition = mux%16;\n    \n    muxRegAddr          = (Uint32 *)&EPwmXbarRegs + ((2*xbar)-2) + (mux/16);\n    muxEnableRegAddr    = (Uint32 *)&EPwmXbarRegs + 0x10 + (xbar-1);\n    muxInvertRegAddr    = (Uint32 *)&EPwmXbarRegs + 0x1C;\n    EALLOW;\n    *muxRegAddr        |= (Uint32)(muxVal & 0x3) << (2*muxPosition);\n    *muxEnableRegAddr  |= (Uint32)1 << mux;\n    *muxInvertRegAddr  |= (Uint32)(invert & 0x1) << (xbar-1);\n    EDIS;\n    return 1;\n}\n\nUint32 setCLBXBARForCPU2(Uint32 inData)\n{\n    volatile Uint32 *muxEnableRegAddr;\n    volatile Uint32 *muxRegAddr;\n    volatile Uint32 *muxInvertRegAddr;\n    Uint16 invert = (Uint16)((inData & 0x0F000000) >> 24);\n    Uint16 muxVal = (Uint16)((inData & 0x00FF0000) >> 16);\n    Uint16 mux = (Uint16)((inData & 0x0000FF00) >> 8);\n    Uint16 xbar = (Uint16)(inData & 0x000000FF);\n    Uint16 muxPosition = mux%16;\n    \n    muxRegAddr          = (Uint32 *)&ClbXbarRegs + (2*xbar) + (mux/16);\n    muxEnableRegAddr    = (Uint32 *)&ClbXbarRegs + 0x10 + xbar;\n    muxInvertRegAddr    = (Uint32 *)&ClbXbarRegs + 0x1C;\n    EALLOW;\n    *muxRegAddr        |= (Uint32)(muxVal & 0x3) << (2*muxPosition);\n    *muxEnableRegAddr  |= (Uint32)1 << mux;\n    *muxInvertRegAddr  |= (Uint32)(invert & 0x1) << (xbar);\n    EDIS;\n    return 1;\n}\n\nUint32 setSyncSocRegsForCPU2(Uint32 inData)\n{\n    volatile Uint32 *syncSelectRegAddr;\n\t//First byte to store the sync select value\n    Uint16 syncSelectVal = (Uint16)(inData & 0x000000FFU);\n\t//Second byte to store the sync select position\n    Uint16 syncSelectPosition = (Uint16)((inData & 0x0000FF00U) >> 8U);\n    \n    syncSelectRegAddr          = (Uint32 *)&SyncSocRegs;\n    EALLOW;\n\t//Each sync select uses 3 bits to store the value.\n\t//3*syncSelectPosition ensures value is set at proper bit position\n    *syncSelectRegAddr        |= (Uint32)(syncSelectVal & 0x7U) << (3*syncSelectPosition);\n    EDIS;\n    return 1;\n}\n\n__interrupt void CPU02toCPU01IPC0IntHandler (void)\n{\n    // Continue processing messages\n    uint32_t command;\n    command = IpcRegs.IPCRECVCOM;\n    \n    switch (command)\n    {\n    case IPC_SET_BITS_16:\n        IPCLiteRtoLSetBits(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_SET_BITS_32:\n        IPCLiteRtoLSetBits(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_CLEAR_BITS_16:\n        IPCLiteRtoLClearBits(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_CLEAR_BITS_32:\n        IPCLiteRtoLClearBits(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_DATA_WRITE_16:\n        IPCLiteRtoLDataWrite(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_DATA_WRITE_32:\n        IPCLiteRtoLDataWrite(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_SET_BITS_16_PROTECTED:\n        IPCLiteRtoLSetBits_Protected(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_SET_BITS_32_PROTECTED:\n        IPCLiteRtoLSetBits_Protected(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_CLEAR_BITS_16_PROTECTED:\n        IPCLiteRtoLClearBits_Protected(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_CLEAR_BITS_32_PROTECTED:\n        IPCLiteRtoLClearBits_Protected(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_DATA_WRITE_16_PROTECTED:\n        IPCLiteRtoLDataWrite_Protected(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_DATA_WRITE_32_PROTECTED:\n        IPCLiteRtoLDataWrite_Protected(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_DATA_READ_16:\n        IPCLiteRtoLDataRead(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_DATA_READ_32:\n        IPCLiteRtoLDataRead(IPC_FLAG0, IPC_FLAG31);\n        break;\n    case IPC_FUNC_CALL:\n        IPCLiteRtoLFunctionCall(IPC_FLAG0, IPC_FLAG31);\n        break;\n    default:\n        ErrorFlag = 1;\n        break;\n    }\n\n    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;   // Acknowledge interrupt to PIE\n    // try re-mapping the IPC INT0.\n    if (IpcRegs.IPCRECVDATA == 0x36E) // mwInitEnd\n    {\n        IpcRegs.IPCACK.all |= IPC_FLAG0;\n        IpcRegs.IPCACK.all |= IPC_FLAG31;\n        IpcRegs.IPCCLR.all |= IPC_FLAG0;\n        IpcRegs.IPCCLR.all |= IPC_FLAG31;\n        #ifdef REMAPIPCINT0\n            EALLOW;\n            PieVectTable.IPC0_INT = &IPC0_INT_isr; /* Map ISR to vector table */\n            EDIS;\n        #else\n            /* Support new HWI where ISR are registered */ \n            if (CIPC0_INT_fptr != NULL) // CIPC0_INT_fptr is set only when there is an IPC0 interrupt block and otherwise will be NULL\n            {\n                EALLOW;\n                PieVectTable.IPC0_INT = CIPC0_INT_fptr; /* Map ISR to vector table */\n                EDIS;\n            }\n            else\n            {\n                asm(\" SETC INTM\");\n                PieCtrlRegs.PIEIER1.bit.INTx13 = 0;     // IPC INT0 disable\n                asm(\" RPT #5 || NOP\");\n                IFR &= 0xFFFE;\n                PieCtrlRegs.PIEACK.all = 0x1;\n                asm(\" CLRC INTM\"); /* Enable Interrupt Global Enable Bit - set it to 0 */\n            }\n        #endif\n    }\n}\n\n#else\n    void configureCPU2Peripherals(Uint32 gpioNumber, Uint32 gpGRegValA, Uint32 gpRegValA)\n    {\n        Uint32 *pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n        Uint32 ulRWord32 = 0;\n        Uint32 gpioData = 0x00010000;\n        gpioData = gpioData|gpioNumber;\n        gpioData = gpioData|(gpRegValA << 8);\n        gpioData = gpioData|(gpGRegValA << 10);\n        IPCLiteLtoRFunctionCall(IPC_FLAG0, pulMsgRam[0], gpioData, IPC_FLAG31);\n        while (IPCLiteLtoRGetResult(&ulRWord32,IPC_LENGTH_32_BITS,\n                        IPC_FLAG31) != STATUS_PASS)\n        {\n\n        }\n    }\n    void configureInputXBar(Uint32 gpioNumber, Uint32 inputXbarNumber)\n    {\n        Uint32 *pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n        Uint32 ulRWord32 = 0;\n        Uint32 gpioData = 0x00000000;\n        gpioData = 0x00000000;\n        gpioData = gpioData|gpioNumber;\n        gpioData = gpioData|(inputXbarNumber << 8);\n        IPCLiteLtoRFunctionCall(IPC_FLAG0, pulMsgRam[3], gpioData, IPC_FLAG31);\n        while (IPCLiteLtoRGetResult(&ulRWord32,IPC_LENGTH_32_BITS,\n                IPC_FLAG31) != STATUS_PASS)\n        {\n            \n        }    \n    }\n    void configureOutputXBar(Uint32 xbar , Uint32 mux, Uint32 muxVal, Uint32 invert, Uint32 latch)\n    {\n        Uint32 *pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n        Uint32 gpioData = 0x00000000;\n        Uint32 ulRWord32 = 0;\n        gpioData = 0x00000000;\n        gpioData = gpioData|xbar;\n        gpioData = gpioData|(mux << 8);\n        gpioData = gpioData|(muxVal << 16);\n        gpioData = gpioData|(invert << 24);\n        gpioData = gpioData|(latch << 28);\n        IPCLiteLtoRFunctionCall(IPC_FLAG0, pulMsgRam[4], gpioData, IPC_FLAG31);\n\t\twhile (IPCLiteLtoRGetResult(&ulRWord32,IPC_LENGTH_32_BITS,\n                IPC_FLAG31) != STATUS_PASS)\n        {\n            \n        }\n    }\n    void configureEpwmXBar(Uint32 xbar , Uint32 mux, Uint32 muxVal, Uint32 invert)\n    {\n        Uint32 *pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n        Uint32 gpioData = 0x00000000;\n        Uint32 ulRWord32 = 0;\n        gpioData = 0x00000000;\n        gpioData = gpioData|xbar;\n        gpioData = gpioData|(mux << 8);\n        gpioData = gpioData|(muxVal << 16);\n        gpioData = gpioData|(invert << 24);\n        IPCLiteLtoRFunctionCall(IPC_FLAG0, pulMsgRam[5], gpioData, IPC_FLAG31);\n\t\twhile (IPCLiteLtoRGetResult(&ulRWord32,IPC_LENGTH_32_BITS,\n                IPC_FLAG31) != STATUS_PASS)\n        {\n            \n        }\n    }\n\t\n\tvoid configureCLBXbarInCPU2(Uint32 xbar , Uint32 mux, Uint32 muxVal, Uint32 invert)\n    {\n        Uint32 *pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n        Uint32 gpioData = 0x00000000;\n        Uint32 ulRWord32 = 0;\n        gpioData = 0x00000000;\n        gpioData = gpioData|xbar;\n        gpioData = gpioData|(mux << 8);\n        gpioData = gpioData|(muxVal << 16);\n        gpioData = gpioData|(invert << 24);\n        IPCLiteLtoRFunctionCall(IPC_FLAG0, pulMsgRam[6], gpioData, IPC_FLAG31);\n\t\twhile (IPCLiteLtoRGetResult(&ulRWord32,IPC_LENGTH_32_BITS,\n                IPC_FLAG31) != STATUS_PASS)\n        {\n            \n        }\n    }\n\n    void configureSyncSocRegsInCPU2(Uint32 syncSelectVal , Uint32 syncSelectPosition)\n    {\n        Uint32 *pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n        Uint32 outData = 0x00000000;\n        Uint32 ulRWord32 = 0;\n        outData = outData|syncSelectVal;\n        outData = outData|(syncSelectPosition << 8);\n        IPCLiteLtoRFunctionCall(IPC_FLAG0, pulMsgRam[7], outData, IPC_FLAG31);\n    \twhile (IPCLiteLtoRGetResult(&ulRWord32,IPC_LENGTH_32_BITS,\n                IPC_FLAG31) != STATUS_PASS)\n        {\n            \n        }\n    }\n#endif\n"},{"name":"c2837xDInit.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\c2b\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"/*\n *   Copyright 2020-2022 The MathWorks, Inc.\n *\n */\n\n#include \"MW_target_hardware_resources.h\"\n#include \"F2837xD_Ipc_drivers.h\"\n#include \"F2837xD_Gpio_defines.h\"\n#include \"F2837xD_Pie_defines.h\"\n#include \"MW_F2837xD_MemoryMap.h\"\n#include \"F2837xD_sysctrl.h\"\n\n#ifdef TIC2000_SOC_BASEPRODUCT\n/* Master CPU functions */\nvoid waitUntilAllSlaveCPUsReadyToBoot(void)\n{\n    uint16_t ipcCountVar;\n    ipcCountVar = 0;\n    \n    //Wait for CPU2 to get ready to accept boot command from CPU1\n    while (((IpcRegs.IPCBOOTSTS & 0x0000000F) != C2_BOOTROM_BOOTSTS_SYSTEM_READY) && (700 > ipcCountVar))\n    {\n        ipcCountVar++;\n    }\n}\n\nvoid sendStartBootCmdToSlaveCPU(uint32_t slaveCpuId)\n{\n    uint16_t ipcCountVar;\n    //CPU01 to CPU02 IPC Boot Mode Register\n    IpcRegs.IPCBOOTMODE = C1C2_BROM_BOOTMODE_BOOT_FROM_FLASH;\n    // CPU01 To CPU02 IPC Command Register\n    IpcRegs.IPCSENDCOM  = BROM_IPC_EXECUTE_BOOTMODE_CMD;\n    // CPU01 to CPU02 IPC flag register\n    IpcRegs.IPCSET.all = 0x80000001;\n    ipcCountVar = 0;\n    // Give ~35 usec delay to start CPU2 init\n    while (500 > ipcCountVar) {\n        ipcCountVar++;\n    }\n}\n\nvoid sendStartModelInitCmdToSlaveCPU(uint32_t slaveCpuId)\n{\n    IpcRegs.IPCSET.bit.IPC30 = 1;\n}\n\nvoid waitForAckForStartModelInitCmdFromSlaveCPU(uint32_t slaveCpuId)\n{\n    while (IpcRegs.IPCFLG.bit.IPC30 == 1);\n}\n\nboolean_T receiveEndModelInitCmdFromSlaveCPU(uint32_t slaveCpuId)\n{\n    boolean_T status;\n\n    if (IpcRegs.IPCSTS.bit.IPC30 == 1)\n    {\n        status = 1;\n        IpcRegs.IPCACK.bit.IPC30 = 1;\n    }\n    else\n        status = 0;\n\n    return status;\n}\n\nboolean_T checkSlaveCPUReadyToRunApplication(uint32_t slaveCpuId)\n{\n    return (IpcRegs.IPCSTS.bit.IPC29 == 1);\n}\n\nvoid sendRunApplicationCmdToAllSlaveCPUs(void)\n{\n    if (IpcRegs.IPCFLG.bit.IPC29 != 1)\n        IpcRegs.IPCSET.bit.IPC29 = 1;\n}\n\n/* Slave functions */\nvoid notifySlaveCPUReadyToBoot(uint32_t masterCpuId, uint32_t slaveCpuId)\n{\n    /* Boot status is handled during power reset and\n       CPU2 is automatically sets Bootstatus to C2_BOOTROM_BOOTSTS_SYSTEM_READY */\n    (void)masterCpuId;\n    (void)slaveCpuId;\n}\n\nvoid waitForBootCommandFromMasterCPU(uint32_t masterCpuId, uint32_t slaveCpuId)\n{\n    /* Boot status is handled during power reset and\n       CPU2 is automatically sets Bootstatus to C2_BOOTROM_BOOTSTS_SYSTEM_READY */\n    (void)masterCpuId;\n    (void)slaveCpuId;\n}\n\nvoid waitForModelInitCmdFromMasterCPU(uint32_t masterCpuId, uint32_t slaveCpuId)\n{\n    while (IpcRegs.IPCSTS.bit.IPC30 == 0);\n}\n\nvoid sendAckForStartModelInitCmdToMasterCPU(uint32_t masterCpuId, uint32_t slaveCpuId)\n{\n    IpcRegs.IPCACK.bit.IPC30 = 1;\n}\n\nvoid sendEndModelInitCmdToMasterCPU(uint32_t masterCpuId, uint32_t slaveCpuId)\n{\n    IpcRegs.IPCSET.bit.IPC30 = 1;\n}\n\nvoid sendReadyToRunApplicationToMasterCPU(uint32_t slaveCpuId)\n{\n    if (IpcRegs.IPCFLG.bit.IPC29 != 1)\n        IpcRegs.IPCSET.bit.IPC29 = 1;\n}\n\nboolean_T checkRunApplicationCmdFromMaster(uint32_t slaveCpuId)\n{\n    return (IpcRegs.IPCSTS.bit.IPC29 == 1);\n}\n\n#else\n/* Master CPU functions */\nvoid waitUntilAllSlaveCPUsReadyToBoot(void)\n{\n    \n}\n\nvoid sendStartBootCmdToSlaveCPU(uint32_t slaveCpuId)\n{\n    (void)slaveCpuId;\n}\n\nvoid sendStartModelInitCmdToSlaveCPU(uint32_t slaveCpuId)\n{\n    (void)slaveCpuId;\n}\n\nvoid waitForAckForStartModelInitCmdFromSlaveCPU(uint32_t slaveCpuId)\n{\n    (void)slaveCpuId;\n}\n\nboolean_T receiveEndModelInitCmdFromSlaveCPU(uint32_t slaveCpuId)\n{\n    (void)slaveCpuId;\n    return 1;\n}\n\nboolean_T checkSlaveCPUReadyToRunApplication(uint32_t slaveCpuId)\n{\n    (void)slaveCpuId;\n    return 1;\n}\n\nvoid sendRunApplicationCmdToAllSlaveCPUs(void)\n{\n    \n}\n\n/* Slave functions */\nvoid notifySlaveCPUReadyToBoot(uint32_t masterCpuId, uint32_t slaveCpuId)\n{\n    /* Boot status is handled during power reset and\n       CPU2 is automatically sets Bootstatus to C2_BOOTROM_BOOTSTS_SYSTEM_READY */\n    (void)masterCpuId;\n    (void)slaveCpuId;\n}\n\nvoid waitForBootCommandFromMasterCPU(uint32_t masterCpuId, uint32_t slaveCpuId)\n{\n    /* Boot status is handled during power reset and\n       CPU2 is automatically sets Bootstatus to C2_BOOTROM_BOOTSTS_SYSTEM_READY */\n    (void)masterCpuId;\n    (void)slaveCpuId;\n}\n\nvoid waitForModelInitCmdFromMasterCPU(uint32_t masterCpuId, uint32_t slaveCpuId)\n{\n    (void)masterCpuId;\n    (void)slaveCpuId;\n}\n\nvoid sendAckForStartModelInitCmdToMasterCPU(uint32_t masterCpuId, uint32_t slaveCpuId)\n{\n    (void)masterCpuId;\n    (void)slaveCpuId;\n}\n\nvoid sendEndModelInitCmdToMasterCPU(uint32_t masterCpuId, uint32_t slaveCpuId)\n{\n    (void)masterCpuId;\n    (void)slaveCpuId;\n}\n\nvoid sendReadyToRunApplicationToMasterCPU(uint32_t slaveCpuId)\n{\n    (void)slaveCpuId;\n}\n\nboolean_T checkRunApplicationCmdFromMaster(uint32_t slaveCpuId)\n{\n    (void)slaveCpuId;\n    return (boolean_T)1;\n}\n#endif\n\n\nvoid allotADCPeripheralModuleToCPU(uint16_t moduleID,uint32_t cpuId)\n{\n    #ifdef CPU1\n    /* Allot to c28xCPU1 */\n    if (1 == cpuId)\n    {\n        EALLOW;\n        DevCfgRegs.CPUSEL11.all &= ~(0x01UL << moduleID);\n        EDIS;\n    }\n    /* Allot to c28xCPU2 */\n    else\n    {\n        EALLOW;\n        DevCfgRegs.CPUSEL11.all |= (0x01UL << moduleID);\n        EDIS;\n    }\n    #endif\n}\n\nvoid allotPWMPeripheralModuleToCPU(uint16_t moduleID,uint32_t cpuId)\n{\n    #ifdef CPU1\n    /* Allot to c28xCPU1 */\n    if (1 == cpuId)\n    {\n        EALLOW;\n        DevCfgRegs.CPUSEL0.all &= ~(0x01UL << moduleID);\n        EDIS;\n    }\n    /* Allot to c28xCPU2 */\n    else\n    {\n        EALLOW;\n        DevCfgRegs.CPUSEL0.all |= (0x01UL << moduleID);\n        EDIS;\n    }\n    #endif\n}\nvoid allotSerialForExtModeToCPU(uint32_t cpuId)\n{\n    #ifdef CPU1\n    /* Allot to c28xCPU1 */\n    if (1 == cpuId)\n    {\n        EALLOW;\n        #if MW_EXTMODE_SCIMODULE == 0\n        DevCfgRegs.CPUSEL5.bit.SCI_A = 0;\n        #elif MW_EXTMODE_SCIMODULE == 1\n        DevCfgRegs.CPUSEL5.bit.SCI_B = 0;\n        #elif MW_EXTMODE_SCIMODULE == 2\n        DevCfgRegs.CPUSEL5.bit.SCI_C = 0;\n        #elif MW_EXTMODE_SCIMODULE == 3\n        DevCfgRegs.CPUSEL5.bit.SCI_D = 0;\n        #endif\n        EDIS;\n    }\n    /* Allot to c28xCPU2 */\n    else if(2 == cpuId)\n    {\n        EALLOW;\n        #if MW_EXTMODE_SCIMODULE == 0\n        DevCfgRegs.CPUSEL5.bit.SCI_A = 1;\n        #elif MW_EXTMODE_SCIMODULE == 1\n        DevCfgRegs.CPUSEL5.bit.SCI_B = 1;\n        #elif MW_EXTMODE_SCIMODULE == 2\n        DevCfgRegs.CPUSEL5.bit.SCI_C = 1;\n        #elif MW_EXTMODE_SCIMODULE == 3\n        DevCfgRegs.CPUSEL5.bit.SCI_D = 1;\n        #endif\n        EDIS;\n    }\n    else /* for ARM*/\n    {\n    }\n    #endif\n}\n/* LocalWords:  IPC usec Bootstatus BOOTROM BOOTSTS\n */\n"},{"name":"c2837xDSchedulerTimer0.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\c2b\\tic2000_shared\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2015-2021 The MathWorks, Inc. */\n\n#include \"MW_f2837xD_includes.h\"\n#include \"MW_c28xx_pie.h\"\n\nextern void rt_OneStep(void);\nextern uint32_t mwInitStart;\nextern uint32_t mwInitEnd;\n\ninterrupt void TINT0_isr(void)\n{\n      #ifdef PIEMASK0\n        volatile unsigned int PIEIER1_stack_save = PieCtrlRegs.PIEIER1.all;\n      #endif\n      #ifdef PIEMASK1\n        volatile unsigned int PIEIER2_stack_save  = PieCtrlRegs.PIEIER2.all;\n      #endif\n      #ifdef PIEMASK2\n        volatile unsigned int PIEIER3_stack_save  = PieCtrlRegs.PIEIER3.all;\n      #endif\n      #ifdef PIEMASK3\n        volatile unsigned int PIEIER4_stack_save  = PieCtrlRegs.PIEIER4.all;\n      #endif\n      #ifdef PIEMASK4\n        volatile unsigned int PIEIER5_stack_save  = PieCtrlRegs.PIEIER5.all;\n      #endif\n      #ifdef PIEMASK5\n        volatile unsigned int PIEIER6_stack_save  = PieCtrlRegs.PIEIER6.all;\n      #endif\n      #ifdef PIEMASK6\n        volatile unsigned int PIEIER7_stack_save  = PieCtrlRegs.PIEIER7.all;\n      #endif\n      #ifdef PIEMASK7\n        volatile unsigned int PIEIER8_stack_save  = PieCtrlRegs.PIEIER8.all;\n      #endif\n      #ifdef PIEMASK8\n        volatile unsigned int PIEIER9_stack_save  = PieCtrlRegs.PIEIER9.all;\n      #endif\n      #ifdef PIEMASK9\n        volatile unsigned int PIEIER10_stack_save = PieCtrlRegs.PIEIER10.all;\n      #endif\n      #ifdef PIEMASK10\n        volatile unsigned int PIEIER11_stack_save = PieCtrlRegs.PIEIER11.all;\n      #endif\n      #ifdef PIEMASK11\n        volatile unsigned int PIEIER12_stack_save = PieCtrlRegs.PIEIER12.all;\n      #endif\n\n      #ifdef PIEMASK0\n        PieCtrlRegs.PIEIER1.all &= ~PIEMASK0;      /* disable group1 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK1\n        PieCtrlRegs.PIEIER2.all &= ~PIEMASK1;      /* disable group2 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK2\n        PieCtrlRegs.PIEIER3.all &= ~PIEMASK2;      /* disable group3 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK3\n        PieCtrlRegs.PIEIER4.all &= ~PIEMASK3;      /* disable group4 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK4\n        PieCtrlRegs.PIEIER5.all &= ~PIEMASK4;      /* disable group5 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK5\n        PieCtrlRegs.PIEIER6.all &= ~PIEMASK5;      /* disable group6 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK6\n        PieCtrlRegs.PIEIER7.all &= ~PIEMASK6;      /* disable group7 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK7\n        PieCtrlRegs.PIEIER8.all &= ~PIEMASK7;      /* disable group8 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK8\n        PieCtrlRegs.PIEIER9.all &= ~PIEMASK8;      /* disable group9 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK9\n        PieCtrlRegs.PIEIER10.all &= ~PIEMASK9;     /* disable group10 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK10\n        PieCtrlRegs.PIEIER11.all &= ~PIEMASK10;    /* disable group11 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK11\n        PieCtrlRegs.PIEIER12.all &= ~PIEMASK11;    /* disable group12 lower/equal priority interrupts */\n      #endif\n\t  #ifdef PIEMASK12\n\t\tIER &= ~(M_INT13);\n      #endif\n\t  #ifdef PIEMASK13\n\t\tIER &= ~(M_INT14);\n      #endif\n\t  \n      asm(\" RPT #5 || NOP\");               /* wait 5 cycles */\n      IFR &= ~IFRMASK;                           /* eventually disable lower/equal priority pending interrupts */\n      PieCtrlRegs.PIEACK.all = IFRMASK;          /* ACK to allow other interrupts from the same group to fire */\n      IER |= 1;\n      EINT;                                /* global interrupt enable */\n      rt_OneStep();\n      DINT;                                /* disable global interrupts during context switch, CPU will enable global interrupts after exiting ISR */\n      #ifdef PIEMASK0\n        PieCtrlRegs.PIEIER1.all = PIEIER1_stack_save;/*restore PIEIER register that was modified */\n      #endif  \n      #ifdef PIEMASK1\n        PieCtrlRegs.PIEIER2.all = PIEIER2_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK2\n        PieCtrlRegs.PIEIER3.all = PIEIER3_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK3\n        PieCtrlRegs.PIEIER4.all = PIEIER4_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK4\n        PieCtrlRegs.PIEIER5.all = PIEIER5_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK5\n        PieCtrlRegs.PIEIER6.all = PIEIER6_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK6\n        PieCtrlRegs.PIEIER7.all = PIEIER7_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK7\n        PieCtrlRegs.PIEIER8.all = PIEIER8_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK8\n        PieCtrlRegs.PIEIER9.all = PIEIER9_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK9\n        PieCtrlRegs.PIEIER10.all= PIEIER10_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK10\n        PieCtrlRegs.PIEIER11.all= PIEIER11_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK11\n        PieCtrlRegs.PIEIER12.all= PIEIER12_stack_save;/*restore PIEIER register that was modified */\n      #endif\n\t  #ifdef PIEMASK12\n\t\tIER |= M_INT13;\n      #endif\n\t  #ifdef PIEMASK13\n\t\tIER |= M_INT14;\n      #endif\n}\n\nvoid configureTimer0(float baseRate, float systemClock)\n{\n  #ifndef TIC2000_SOC_BASEPRODUCT\n    #ifdef CPU1\n        EINT;\n        uint32_t ipcCountVar = 0;\n        if (0x425 == mwInitStart)\n        {\n            /* Wait until completion of CPU2 GPIO initialization */\n            while ((0x36E != mwInitEnd))\n            {\n                ipcCountVar++;\n            }\n        }\n        DINT;\n    #else\n\t      uint32_t *pulMsgRam;\n\t      pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n        IPCLiteLtoRDataWrite(IPC_FLAG0, pulMsgRam[2], 0x36E,\n                         IPC_LENGTH_32_BITS, IPC_FLAG31);\n    #endif\n  #endif\n    \n    /* InitCpuTimers() - CPU Timers are initialized in \n     * MW_c28xx_board.c in the generated code.\n     */\n\n\t/* Configure CPU-Timer 0 to interrupt every base rate. */\n\t/* Parameters:  Timer Pointer, CPU Freq in MHz, Period in usec. */\n\tConfigCpuTimer(&CpuTimer0, systemClock, baseRate * 1000000);\n\tStartCpuTimer0();\n\n    #ifdef TIC2000_SOC_BASEPRODUCT\n\tPieCtrlRegs.PIEIFR1.bit.INTx7 = 1;   /* Set Pending interrupt for TINT0. TINT0 will trigger as soon as the its interrupt is enabled*/\n    #endif\n    \n\tEALLOW;\n\tPieVectTable.TIMER0_INT = &TINT0_isr;     /* Hook interrupt to the ISR*/\n\tEDIS;\n\n\tPieCtrlRegs.PIEIER1.bit.INTx7 = 1;   /* Enable interrupt TINT0 */\n\tIER |= M_INT1;\n}\n\nvoid stopTimer0(void)\n{\n    StopCpuTimer0();\n}\nvoid enableTimer0Interrupt(void)\n{\n\tasm(\" SETC INTM\"); /* Disable Interrupt Global Enable Bit - set it to 1 */\n\tEALLOW;\n\tPieCtrlRegs.PIEIER1.all |= (1 << 6); /* Enable PIER bit for timer 0 */\n\tEDIS;\n\tasm(\" CLRC INTM\"); /* Enable Interrupt Global Enable Bit - set it to 0 */\n}\n\nbool disableTimer0Interrupt(void)\n{\n    bool isrEnabled = false;\n\t\n    asm(\" SETC INTM\"); /* Disable Interrupt Global Enable Bit - set it to 1 */\n    \n    isrEnabled = PieCtrlRegs.PIEIER1.all & (1 << 6) ;\n\tEALLOW;\n\tPieCtrlRegs.PIEIER1.all &= ~(1 << 6); /* Disable PIER bit for timer 0 */\n\tasm(\" RPT #5 || NOP\");\n\tIFR &= 0xFFFE;\n\tPieCtrlRegs.PIEACK.all = 0x1;\n\tEDIS;\n\tasm(\" CLRC INTM\"); /* Enable Interrupt Global Enable Bit - set it to 0 */\n    \n    return isrEnabled;\n}\n\nvoid restoreTimer0Interrupt(bool isrStatus){\n    if(isrStatus)\n        enableTimer0Interrupt();\n    else\n        disableTimer0Interrupt();\n}\n"},{"name":"clb.c","type":"source","group":"legacy","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_02_00_00\\driverlib\\f2837xd\\driverlib","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   clb.c\n//\n// TITLE:  C28x CLB driver.\n//\n//###########################################################################\n// $Copyright:\n// Copyright (C) 2022 Texas Instruments Incorporated - http://www.ti.com\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n#include \"clb.h\"\n\n//*****************************************************************************\n//\n// CLB_configCounterLoadMatch\n//\n//*****************************************************************************\nvoid CLB_configCounterLoadMatch(uint32_t base, CLB_Counters counterID,\n                               uint32_t load, uint32_t match1, uint32_t match2)\n{\n    ASSERT(CLB_isBaseValid(base));\n\n    EALLOW;\n    switch(counterID)\n    {\n        case CLB_CTR0:\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_0_LOAD, load);\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_0_MATCH1, match1);\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_0_MATCH2, match2);\n            break;\n\n        case CLB_CTR1:\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_1_LOAD, load);\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_1_MATCH1, match1);\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_1_MATCH2, match2);\n            break;\n\n        case CLB_CTR2:\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_2_LOAD, load);\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_2_MATCH1, match1);\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_2_MATCH2, match2);\n            break;\n\n        default:\n            //\n            // Invalid counterID value\n            //\n            break;\n    }\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// CLB_clearFIFOs\n//\n//*****************************************************************************\nvoid CLB_clearFIFOs(uint32_t base)\n{\n    uint16_t i;\n\n    ASSERT(CLB_isBaseValid(base));\n\n    for(i = 0U; i < CLB_FIFO_SIZE; i++)\n    {\n        HWREG(base + CLB_DATAEXCH + CLB_O_PULL(i)) = 0U;\n    }\n\n    HWREG(base + CLB_LOGICCTL + CLB_O_BUF_PTR) = 0U;\n}\n\n//*****************************************************************************\n//\n// CLB_writeFIFOs\n//\n//*****************************************************************************\nvoid CLB_writeFIFOs(uint32_t base , const uint32_t pullData[])\n{\n    ASSERT(CLB_isBaseValid(base));\n\n    //\n    // Clear the FIFO and pointer\n    //\n    CLB_clearFIFOs(base);\n\n    //\n    // Write data into the FIFO.\n    //\n    HWREG(base + CLB_DATAEXCH + CLB_O_PULL(0U)) = pullData[0U];\n    HWREG(base + CLB_DATAEXCH + CLB_O_PULL(1U)) = pullData[1U];\n    HWREG(base + CLB_DATAEXCH + CLB_O_PULL(2U)) = pullData[2U];\n    HWREG(base + CLB_DATAEXCH + CLB_O_PULL(3U)) = pullData[3U];\n}\n\n//*****************************************************************************\n//\n// CLB_readFIFOs\n//\n//*****************************************************************************\nvoid CLB_readFIFOs(uint32_t base , uint32_t pushData[])\n{\n    ASSERT(CLB_isBaseValid(base));\n\n    //\n    // Read data from the FIFO.\n    //\n    pushData[0U] = HWREG(base + CLB_DATAEXCH + CLB_O_PUSH(0U)) ;\n    pushData[1U] = HWREG(base + CLB_DATAEXCH + CLB_O_PUSH(1U)) ;\n    pushData[2U] = HWREG(base + CLB_DATAEXCH + CLB_O_PUSH(2U)) ;\n    pushData[3U] = HWREG(base + CLB_DATAEXCH + CLB_O_PUSH(3U)) ;\n}\n\n\n"},{"name":"dma.c","type":"source","group":"legacy","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_02_00_00\\driverlib\\f2837xd\\driverlib","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   dma.c\n//\n// TITLE:  C28x DMA driver.\n//\n//###########################################################################\n// $Copyright:\n// Copyright (C) 2022 Texas Instruments Incorporated - http://www.ti.com\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n#include \"dma.h\"\n\n//*****************************************************************************\n//\n// DMA_configAddresses\n//\n//*****************************************************************************\nvoid DMA_configAddresses(uint32_t base, const void *destAddr,\n                         const void *srcAddr)\n{\n    //\n    // Check the arguments.\n    //\n    ASSERT(DMA_isBaseValid(base));\n\n    EALLOW;\n\n    //\n    // Set up SOURCE address.\n    //\n    HWREG(base + DMA_O_SRC_BEG_ADDR_SHADOW) = (uint32_t)srcAddr;\n    HWREG(base + DMA_O_SRC_ADDR_SHADOW)     = (uint32_t)srcAddr;\n\n    //\n    // Set up DESTINATION address.\n    //\n    HWREG(base + DMA_O_DST_BEG_ADDR_SHADOW) = (uint32_t)destAddr;\n    HWREG(base + DMA_O_DST_ADDR_SHADOW)     = (uint32_t)destAddr;\n\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// DMA_configBurst\n//\n//*****************************************************************************\nvoid DMA_configBurst(uint32_t base, uint16_t size, int16_t srcStep,\n                     int16_t destStep)\n{\n    //\n    // Check the arguments.\n    //\n    ASSERT(DMA_isBaseValid(base));\n    ASSERT((size >= 1U) && (size <= 32U));\n    ASSERT(((srcStep >= -4096) && (srcStep <= 4095)) &&\n           ((destStep >= -4096) && (destStep <= 4095)));\n\n    EALLOW;\n\n    //\n    // Set up BURST registers.\n    //\n    HWREGH(base + DMA_O_BURST_SIZE)     = size - 1U;\n    HWREGH(base + DMA_O_SRC_BURST_STEP) = srcStep;\n    HWREGH(base + DMA_O_DST_BURST_STEP) = destStep;\n\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// DMA_configTransfer\n//\n//*****************************************************************************\nvoid DMA_configTransfer(uint32_t base, uint32_t transferSize, int16_t srcStep,\n                        int16_t destStep)\n{\n    //\n    // Check the arguments.\n    //\n    ASSERT(DMA_isBaseValid(base));\n    ASSERT(transferSize <= 0x10000U);\n    ASSERT(((srcStep >= -4096) && (srcStep <= 4095)) &&\n           ((destStep >= -4096) && (destStep <= 4095)));\n\n    EALLOW;\n\n    //\n    // Set up TRANSFER registers.\n    //\n    HWREGH(base + DMA_O_TRANSFER_SIZE)     = (uint16_t)(transferSize - 1U);\n    HWREGH(base + DMA_O_SRC_TRANSFER_STEP) = srcStep;\n    HWREGH(base + DMA_O_DST_TRANSFER_STEP) = destStep;\n\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// DMA_configWrap\n//\n//*****************************************************************************\nvoid DMA_configWrap(uint32_t base, uint32_t srcWrapSize, int16_t srcStep,\n                    uint32_t destWrapSize, int16_t destStep)\n{\n    //\n    // Check the arguments.\n    //\n    ASSERT(DMA_isBaseValid(base));\n    ASSERT((srcWrapSize <= 0x10000U) || (destWrapSize <= 0x10000U));\n    ASSERT(((srcStep >= -4096) && (srcStep <= 4095)) &&\n           ((destStep >= -4096) && (destStep <= 4095)));\n\n    EALLOW;\n\n    //\n    // Set up WRAP registers.\n    //\n    HWREGH(base + DMA_O_SRC_WRAP_SIZE) = (uint16_t)(srcWrapSize - 1U);\n    HWREGH(base + DMA_O_SRC_WRAP_STEP) = srcStep;\n\n    HWREGH(base + DMA_O_DST_WRAP_SIZE) = (uint16_t)(destWrapSize - 1U);\n    HWREGH(base + DMA_O_DST_WRAP_STEP) = destStep;\n\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// DMA_configMode\n//\n//*****************************************************************************\nvoid DMA_configMode(uint32_t base, DMA_Trigger trigger, uint32_t config)\n{\n    //\n    // Check the arguments.\n    //\n    ASSERT(DMA_isBaseValid(base));\n\n    EALLOW;\n\n    //\n    // Set up trigger selection in the CMA/CLA trigger source selection\n    // registers. These are considered part of system control.\n    //\n    switch(base)\n    {\n        case DMA_CH1_BASE:\n            //\n            // Channel 1\n            //\n            HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) =\n                (HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) &\n                 ~((uint32_t)SYSCTL_DMACHSRCSEL1_CH1_M)) |\n                ((uint32_t)trigger << SYSCTL_DMACHSRCSEL1_CH1_S);\n\n            //\n            // Set peripheral interrupt select bits to the channel number.\n            //\n            HWREGH(DMA_CH1_BASE + DMA_O_MODE) =\n               (HWREGH(DMA_CH1_BASE + DMA_O_MODE) & ~DMA_MODE_PERINTSEL_M) | 1U;\n            break;\n\n        case DMA_CH2_BASE:\n            //\n            // Channel 2\n            //\n            HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) =\n                (HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) &\n                 ~((uint32_t)SYSCTL_DMACHSRCSEL1_CH2_M)) |\n                ((uint32_t)trigger << SYSCTL_DMACHSRCSEL1_CH2_S);\n\n            //\n            // Set peripheral interrupt select bits to the channel number.\n            //\n            HWREGH(DMA_CH2_BASE + DMA_O_MODE) =\n               (HWREGH(DMA_CH2_BASE + DMA_O_MODE) & ~DMA_MODE_PERINTSEL_M) | 2U;\n            break;\n\n        case DMA_CH3_BASE:\n            //\n            // Channel 3\n            //\n            HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) =\n                (HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) &\n                 ~((uint32_t)SYSCTL_DMACHSRCSEL1_CH3_M)) |\n                ((uint32_t)trigger << SYSCTL_DMACHSRCSEL1_CH3_S);\n\n            //\n            // Set peripheral interrupt select bits to the channel number.\n            //\n            HWREGH(DMA_CH3_BASE + DMA_O_MODE) =\n               (HWREGH(DMA_CH3_BASE + DMA_O_MODE) & ~DMA_MODE_PERINTSEL_M) | 3U;\n            break;\n\n        case DMA_CH4_BASE:\n            //\n            // Channel 4\n            //\n            HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) =\n                (HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) &\n                 ~((uint32_t)SYSCTL_DMACHSRCSEL1_CH4_M)) |\n                ((uint32_t)trigger << SYSCTL_DMACHSRCSEL1_CH4_S);\n\n            //\n            // Set peripheral interrupt select bits to the channel number.\n            //\n            HWREGH(DMA_CH4_BASE + DMA_O_MODE) =\n               (HWREGH(DMA_CH4_BASE + DMA_O_MODE) & ~DMA_MODE_PERINTSEL_M) | 4U;\n            break;\n\n        case DMA_CH5_BASE:\n            //\n            // Channel 5\n            //\n            HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL2) =\n                (HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL2) &\n                 ~((uint32_t)SYSCTL_DMACHSRCSEL2_CH5_M)) |\n                ((uint32_t)trigger << SYSCTL_DMACHSRCSEL2_CH5_S);\n\n            //\n            // Set peripheral interrupt select bits to the channel number.\n            //\n            HWREGH(DMA_CH5_BASE + DMA_O_MODE) =\n               (HWREGH(DMA_CH5_BASE + DMA_O_MODE) & ~DMA_MODE_PERINTSEL_M) | 5U;\n            break;\n\n        case DMA_CH6_BASE:\n            //\n            // Channel 6\n            //\n            HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL2) =\n                (HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL2) &\n                 ~((uint32_t)SYSCTL_DMACHSRCSEL2_CH6_M)) |\n                ((uint32_t)trigger << SYSCTL_DMACHSRCSEL2_CH6_S);\n\n            //\n            // Set peripheral interrupt select bits to the channel number.\n            //\n            HWREGH(DMA_CH6_BASE + DMA_O_MODE) =\n               (HWREGH(DMA_CH6_BASE + DMA_O_MODE) & ~DMA_MODE_PERINTSEL_M) | 6U;\n            break;\n\n        default:\n            //\n            // Invalid base.\n            //\n            break;\n    }\n\n    //\n    // Write the configuration to the mode register.\n    //\n    HWREGH(base + DMA_O_MODE) &= ~(DMA_MODE_DATASIZE | DMA_MODE_CONTINUOUS |\n                                   DMA_MODE_ONESHOT);\n    HWREGH(base + DMA_O_MODE) |= config;\n\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// DMA_configChannel\n//\n//*****************************************************************************\nvoid DMA_configChannel(uint32_t base, const DMA_ConfigParams *transfParams)\n{\n    //\n    // Check the arguments.\n    //\n    ASSERT(DMA_isBaseValid(base));\n    ASSERT(((transfParams->configSize == DMA_CFG_SIZE_16BIT) ||\n            (transfParams->configSize == DMA_CFG_SIZE_32BIT)) &&\n           ((transfParams->transferMode == DMA_CFG_ONESHOT_DISABLE) ||\n            (transfParams->transferMode == DMA_CFG_ONESHOT_ENABLE)) &&\n           ((transfParams->reinitMode == DMA_CFG_CONTINUOUS_DISABLE) ||\n            (transfParams->reinitMode == DMA_CFG_CONTINUOUS_ENABLE)));\n\n    //\n    // Configure DMA Channel\n    //\n    DMA_configAddresses(base, (const void *)transfParams->destAddr,\n                        (const void *)transfParams->srcAddr);\n\n    //\n    // Configure the size of each burst and the address step size\n    //\n    DMA_configBurst(base, transfParams->burstSize, transfParams->srcBurstStep,\n                    transfParams->destBurstStep);\n\n    //\n    // Configure the transfer size and the address step that is\n    // made after each burst.\n    //\n    DMA_configTransfer(base, transfParams->transferSize,\n                       transfParams->srcTransferStep,\n                       transfParams->destTransferStep);\n\n    //\n    // Configure the DMA channel's wrap settings\n    //\n    DMA_configWrap(base, transfParams->srcWrapSize, transfParams->srcWrapStep,\n                   transfParams->destWrapSize, transfParams->destWrapStep);\n\n    //\n    // Configure the DMA channel's trigger and mode\n    //\n    DMA_configMode(base, transfParams->transferTrigger,\n                   transfParams->transferMode | transfParams->reinitMode |\n                   transfParams->configSize);\n\n    //\n    // Enable the selected peripheral trigger to start a DMA transfer\n    //\n    DMA_enableTrigger(base);\n\n    if(transfParams->enableInterrupt)\n    {\n        //\n        // Set the channel interrupt mode\n        //\n        DMA_setInterruptMode(base, transfParams->interruptMode);\n\n        //\n        // Enable the indicated DMA channel interrupt source\n        //\n        DMA_enableInterrupt(base);\n    }\n    else\n    {\n        //\n        // Disable the indicated DMA channel interrupt source\n        //\n        DMA_disableInterrupt(base);\n    }\n}\n\n"},{"name":"memcpy_fast.asm","type":"other","group":"legacy","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_02_00_00\\libraries\\dsp\\FPU\\c28\\source\\fpu32\\utility","tag":"","groupDisplay":"Other files","code":";;#############################################################################\n;;! \\file source/vector/memcpy_fast.asm\n;;!\n;;! \\brief Optimized memory copy, src->dest.\n;;! \\author David M. Alter\n;;! \\date   07/06/11\n;;\n;;\n;; HISTORY:\n;;   07/06/11 - original (D. Alter)\n;;   10/23/14 - Added note about non-interruptibility and no support for\n;;              above 22 bit address. (D. Alter)\n;;\n;; DESCRIPTION: Optimized memory copy, src->dest.\n;;\n;; FUNCTION: \n;;   extern void memcpy_fast(void* dst, const void* src, Uint16 N);\n;;\n;; USAGE:       memcpy_fast(dst, src, N);\n;;\n;; PARAMETERS:  void* dst = pointer to destination\n;;              const void* src = pointer to source\n;;              N = number of 16-bit words to copy\n;;\n;; RETURNS:     none\n;;\n;; BENCHMARK:   1 cycle per copy + ~20 cycles of overhead (including\n;;   the call and return).  This assumes src and dst are located in\n;;   different internal RAM blocks.\n;;\n;; NOTES:\n;;   1) The function checks for the case of N=0 and just returns if true.\n;;   2) This function is not interruptible.  Use memcpy_fast_far instead for \n;;      interruptibility.\n;;   3) This function does not support memory above 22 bits address.\n;;      For input data above 22 bits address, use memcpy_fast_far instead.\n;;\n;;#############################################################################\n;;!\n;;! Copyright: Copyright (C) 2023 Texas Instruments Incorporated -\n;;!\tAll rights reserved not granted herein.\n;;!\tLimited License.\n;;!\n;;! Texas Instruments Incorporated grants a world-wide, royalty-free,\n;;! non-exclusive license under copyrights and patents it now or hereafter\n;;! owns or controls to make, have made, use, import, offer to sell and sell\n;;! (\"Utilize\") this software subject to the terms herein. With respect to the\n;;! foregoing patent license, such license is granted solely to the extent that\n;;! any such patent is necessary to Utilize the software alone. The patent\n;;! license shall not apply to any combinations which include this software,\n;;! other than combinations with devices manufactured by or for TI \n;;! (\"TI Devices\").\n;;! No hardware patent is licensed hereunder.\n;;!\n;;! Redistributions must preserve existing copyright notices and reproduce this\n;;! license (including the above copyright notice and the disclaimer and\n;;! (if applicable) source code license limitations below) in the documentation\n;;!  and/or other materials provided with the distribution.\n;;!\n;;! Redistribution and use in binary form, without modification, are permitted\n;;! provided that the following conditions are met:\n;;!\n;;! * No reverse engineering, decompilation, or disassembly of this software is \n;;! permitted with respect to any software provided in binary form.\n;;! * Any redistribution and use are licensed by TI for use only \n;;!   with TI Devices.\n;;! * Nothing shall obligate TI to provide you with source code for the \n;;!   software licensed and provided to you in object code.\n;;!\n;;! If software source code is provided to you, modification and redistribution\n;;! of the source code are permitted provided that the following conditions \n;;! are met:\n;;!\n;;! * any redistribution and use of the source code, including any resulting\n;;!   derivative works, are licensed by TI for use only with TI Devices.\n;;! * any redistribution and use of any object code compiled from the source\n;;!   code and any resulting derivative works, are licensed by TI for use \n;;!   only with TI Devices.\n;;!\n;;! Neither the name of Texas Instruments Incorporated nor the names of its\n;;! suppliers may be used to endorse or promote products derived from this \n;;! software without specific prior written permission.\n;;#############################################################################\n        .if __TI_EABI__\n        .asg memcpy_fast, _memcpy_fast\n        .endif\n    \n        .global _memcpy_fast\n        .text\n\n_memcpy_fast:\n        ADDB    AL, #-1                ;Repeat \"N-1\" times\n        BF      done, NC               ;Branch if N was zero\n        MOVL    XAR7, XAR5             ;XAR7 = XAR5 = dst\n        RPT     @AL\n    ||  PREAD   *XAR4++, *XAR7         ;Do the copy\n\n;Finish up\ndone:\n        LRETR                          ;return\n\n;end of function memcpy_fast()\n;*********************************************************************\n\n       .end\n;;#############################################################################\n;;  End of File\n;;#############################################################################\n"},{"name":"mw_soc_c2000_ipc.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2024b\\toolbox\\c2b\\tic2000_soc\\src","tag":"","groupDisplay":"Other files","code":"/* mw_soc_c2000_ipc.c\n*\n* Copyright 2020-2024 The MathWorks, Inc.\n*\n*/\n#ifdef IPC_BLOCK_INCLUDED\n#include \"mw_soc_c2000_ipc.h\"\n\n#define DEBUG 0  /* Debugging info 1:on 0:off */\n#if DEBUG\n#include <stdlib.h> /* For printf. */\n#endif\n#ifndef __TMS320C28XX_CLA__\n#include <string.h> /* For memcpy. */\n#endif /* __TMS320C28XX_CLA__ */\n\n#define ADDRESS_GRANULARITY (2)\n\n#ifndef __TMS320C28XX_CLA__\n#if defined(MW_F2838X) || defined(MW_F28P65X)\n    #if defined(CPU1)\n    volatile uint32_T *setReg = &(Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCSET.all);\n    volatile uint32_T *stsReg = &(Cpu1toCpu2IpcRegs.CPU2TOCPU1IPCSTS.all);\n    volatile uint32_T *ackReg = &(Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.all);\n    volatile uint32_T *clrReg = &(Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCCLR.all);\n    volatile uint32_T *flgReg = &(Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCFLG.all);\n    #elif defined (CPU2)\n    volatile uint32_T *setReg = &(Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCSET.all);\n    volatile uint32_T *stsReg = &(Cpu2toCpu1IpcRegs.CPU1TOCPU2IPCSTS.all);\n    volatile uint32_T *ackReg = &(Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.all);\n    volatile uint32_T *clrReg = &(Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCCLR.all);\n    volatile uint32_T *flgReg = &(Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCFLG.all);\n    #elif defined (CM)\n    volatile IPC_Flag_Ctr_Reg_t  *IPC_CMTOCPU1_FlagReg = (volatile IPC_Flag_Ctr_Reg_t *) IPC_CMTOCPU1_BASE;\n    volatile IPC_Flag_Ctr_Reg_t  *IPC_CMTOCPU2_FlagReg = (volatile IPC_Flag_Ctr_Reg_t *) IPC_CMTOCPU2_BASE;\n    #endif\n#else\n    volatile uint32_T *setReg = &(IpcRegs.IPCSET.all);\n    volatile uint32_T *stsReg = &(IpcRegs.IPCSTS.all);\n    volatile uint32_T *ackReg = &(IpcRegs.IPCACK.all);\n    volatile uint32_T *clrReg = &(IpcRegs.IPCCLR.all);\n    volatile uint32_T *flgReg = &(IpcRegs.IPCFLG.all);\n#endif\n\n/* The IPC data is stored in the respective RAMs (see mw_soc_c2000_ipc.h for more information).\n* The structure of the IPC data is broken down into:\n*      IPC channel information that contains the pointer information of IPCChannelStruct_T and is stored for all 32 channels.\n*      IPC buffer data is configured as per the required channel buffer sizes.\n* For example,\n*      Channel 0 - head\n*      Channel 0 - tail\n*      ...\n*      Channel 0 - bufferStartAdd\n*      Channel 1 - head\n*      ...\n*      Channel 32 - bufferStartAdd\n*      Channel 0 - buffer data\n*      Channel 1 - buffer data\n* The only exception is for C28x-CM IPC where an additional pointer is required per channel, as part of the channel information, due to the different views.\n*/\n#define MW_NUM_IPC_CHANNELS_TOTAL 32 /* This macro is used to determine the offset where the IPC data is stored and is not used while allocating handles. */\n\n/* The IPC channel information is stored at the start of the RAM, for all 32 channels.\n* The information stored per channel is:\n*      CPU1_CPU2_IPC, CPU1_CLA_IPC and CPU2_CLA_IPC: A total of 8 uint16_T and 1 CLA_PTR is stored.\n*             These are the head, tail, full, mutex, overwrite, lastReadStatus, bufferLength, dataTypeInBytes (8 uint16_T) and the bufferStartAdd (1 CLA_PTR).\n*      CPU1_CM_IPC and CPU2_CM_IPC: A total of 8 uint16_T and 2 CLA_PTR is stored.\n*             These are the head, tail, full, mutex, overwrite, lastReadStatus, bufferLength, dataTypeInBytes (8 uint16_T) bufferStartAdd and the bufferStartAdd + 1 (2 CLA_PTR).\n*             The bufferStartAdd and bufferStartAdd + 1 double pointers are required to store the two memory views - C28x view and CM view.\n*/\n#define MW_SIZE_IPC_CHANNELS_INFO (8*sizeof(uint16_T) + sizeof(CLA_PTR))\n#define MW_SIZE_IPC_CHANNELS_INFO_C28xCM (8*sizeof(uint16_T) + 2*sizeof(CLA_PTR))\n\n#if defined(CPU1_CPU2_IPC)\n    #if defined(CPU1)\n    uint16_T isInitialized = 0U; /* Boolean to initialize GS RAM R/W access. */\n    #endif\n\nvolatile uint32_T buffCPUOffsetInWords = 0; /* Cumulative sum of required buffer sizes. */\n\n/* TO DO: The lists may be used for further optimizations. */\n// const uint16_T ipcChannelCPUList[] = MW_IPC_CHANNELS_CPU_LIST;\n// volatile IPC_CPUHandle_T ipcHandleForCPU[MW_NUM_IPC_CHANNELS_CPU];\n#endif\n\n#if defined(CPU1_CM_IPC)\n    #if defined(CPU1)\n    volatile uint32_T buffCPU1CMOffsetInWords = MW_NUM_IPC_CHANNELS_TOTAL * MW_SIZE_IPC_CHANNELS_INFO_C28xCM; /* Cumulative sum of required buffer sizes. */\n    #elif defined(CM)\n    volatile uint32_T buffCPU1CMOffsetInBytes = MW_NUM_IPC_CHANNELS_TOTAL * MW_SIZE_IPC_CHANNELS_INFO_C28xCM; /* Cumulative sum of required buffer sizes. */\n    #endif\n\n/* TO DO: The lists may be used for further optimizations. */\n// const uint16_T ipcChannelCPU1CMList[] = MW_IPC_CHANNELS_CPU1CM_LIST;\n// volatile IPC_CPUHandle_T ipcHandleForCPU1CM[MW_NUM_IPC_CHANNELS_CPU1CM];\n#endif\n\n#if defined(CPU2_CM_IPC)\n    #if defined(CPU2)\n    volatile uint32_T buffCPU2CMOffsetInWords = MW_NUM_IPC_CHANNELS_TOTAL * MW_SIZE_IPC_CHANNELS_INFO_C28xCM; /* Cumulative sum of required buffer sizes. */\n    #elif defined(CM)\n    volatile uint32_T buffCPU2CMOffsetInBytes = MW_NUM_IPC_CHANNELS_TOTAL * MW_SIZE_IPC_CHANNELS_INFO_C28xCM; /* Cumulative sum of required buffer sizes. */\n    #endif\n\n/* TO DO: The lists may be used for further optimizations. */\n// const uint16_T ipcChannelCPU2CMList[] = MW_IPC_CHANNELS_CPU2CM_LIST;\n// volatile IPC_CPUHandle_T ipcHandleForCPU2CM[MW_NUM_IPC_CHANNELS_CPU2CM];\n#endif\n\n#if defined(CPU1_CLA_IPC) || defined(CPU2_CLA_IPC)\nvolatile uint32_T buffCPUCLAOffsetInWords = MW_NUM_IPC_CHANNELS_TOTAL * MW_SIZE_IPC_CHANNELS_INFO;\nconst uint16_T ipcChannelCPUCLAList[] = MW_IPC_CHANNELS_CPUCLA_LIST;\n#pragma DATA_SECTION(ipcHandleForCPUCLA, \"Cla1DataRam0\");\nvolatile IPC_CPUHandle_T ipcHandleForCPUCLA[MW_NUM_IPC_CHANNELS_CPUCLA];\n#endif\n\nuint16_T MW_bSearch_IPC_Channels(const uint16_T sorted_array[], uint16_T size, uint16_T target) {\n    uint16_T left = 0;\n    uint16_T right = size - 1;\n\n    while (left <= right) {\n        uint16_T mid = left + ((right - left) >> 1); /* Right shift operator for division by 2. */\n\n        if (sorted_array[mid] == target)\n        {\n            return mid; /* Found the target index. */\n        }\n        else if (sorted_array[mid] < target)\n        {\n            left = mid + 1; /* Continue searching in the right half. */\n        }\n        else\n        {\n            right = mid - 1; /* Continue searching in the left half. */\n        }\n    }\n\n    return 0U; /* Target index not found. */\n}\n\nMW_IPC_Handle MW_IPC_Init(MW_IPC_Params_T *IpcParams)\n{\n    uint32_T ipcflag = 0x00000001, ipcflag1;\n    /* Reset the IPC status flags. */\n    ipcflag1 = ipcflag << IpcParams->ChNum;\n    #if defined(CPU1) || defined(CPU2)\n    (*clrReg) |= ipcflag1;\n    #elif defined(CM)\n    IPC_CMTOCPU1_FlagReg->IPC_ACK |= ipcflag1;\n    IPC_CMTOCPU2_FlagReg->IPC_ACK |= ipcflag1;\n    #endif\n\n    IPC_CPUHandle_T ipcHandle; /* Local IPC handle which is returned by value to the global variable in the generated code. */\n\n    uint32_T sharedAddressPU1toPU2; /* Shared memory address for H_PU1 to H_PU2. */\n    uint32_T sharedAddressPU2toPU1; /* Buffer memory address for H_PU2 to H_PU1. */\n\n    #if (defined(CPU1_CPU2_IPC) && defined(CPU1)) || \\\n        (defined(CPU1_CM_IPC) && defined(CPU1)) || \\\n        (defined(CPU2_CM_IPC) && defined(CPU2)) || \\\n        (defined(CPU1_CLA_IPC) && defined(CPU1)) || \\\n        (defined(CPU2_CLA_IPC) && defined(CPU2))\n    uint32_T bufferAddressPU1toPU2; /* Buffer memory address for H_PU1 to H_PU2. */\n    #endif\n\n    #if (defined(CPU1_CPU2_IPC) && defined(CPU2)) || \\\n        (defined(CPU1_CM_IPC) && defined(CM)) || \\\n        (defined(CPU2_CM_IPC) && defined(CM)) || \\\n        (defined(CPU1_CLA_IPC) && defined(CPU1)) || \\\n        (defined(CPU2_CLA_IPC) && defined(CPU2))\n    uint32_T bufferAddressPU2toPU1; /* Buffer memory address for H_PU2 to H_PU1. */\n    #endif\n\n    #if (defined(CPU1_CM_IPC) && defined(CPU1)) || \\\n        (defined(CPU2_CM_IPC) && defined(CPU2))\n    uint32_T bufferAddressPU1toPU2_CM; /* Buffer memory address for H_PU1 to H_PU2 in the CM view. */\n    #endif\n\n    #if (defined(CPU1_CM_IPC) && defined(CM)) || \\\n        (defined(CPU2_CM_IPC) && defined(CM))\n    uint32_T bufferAddressPU2toPU1_CM; /* Buffer memory address for H_PU2 to H_PU1 in the CM view. */\n    #endif\n\n    uint16_T isH_PU1 = 0U; /* Boolean to check if current PU is H_PU1 or H_PU2. */\n\n    /* Find the addresses and processing unit information for the current IPC handle. */\n    switch (IpcParams->IPCBetween)\n    {\n        case IPC_CPU1CPU2:\n            #if defined(CPU1_CPU2_IPC)\n                #if defined(CPU1) || defined(CPU2)\n                sharedAddressPU1toPU2 = CPU1TOCPU2_RAMMSG_IPC_START + (IpcParams->ChNum * MW_SIZE_IPC_CHANNELS_INFO);\n                sharedAddressPU2toPU1 = CPU2TOCPU1_RAMMSG_IPC_START + (IpcParams->ChNum * MW_SIZE_IPC_CHANNELS_INFO);\n                #endif\n                #if defined(CPU1)\n                bufferAddressPU1toPU2 = CPU1TOCPU2_RAMGS_IPC_START + buffCPUOffsetInWords;\n                isH_PU1 = 1U;\n                #elif defined(CPU2)\n                bufferAddressPU2toPU1 = CPU2TOCPU1_RAMGS_IPC_START + buffCPUOffsetInWords;\n                isH_PU1 = 0U;\n                #endif\n            #endif\n            break;\n        case IPC_CPU1CM:\n            #if defined(CPU1_CM_IPC)\n                #if defined(CPU1)\n                sharedAddressPU1toPU2 = CPUTOCM_RAMMSG_IPC_START_C28XVIEW + (IpcParams->ChNum * MW_SIZE_IPC_CHANNELS_INFO_C28xCM);\n                sharedAddressPU2toPU1 = CMTOCPU_RAMMSG_IPC_START_C28XVIEW + (IpcParams->ChNum * MW_SIZE_IPC_CHANNELS_INFO_C28xCM);\n                bufferAddressPU1toPU2 = CPUTOCM_RAMMSG_IPC_START_C28XVIEW + buffCPU1CMOffsetInWords;\n                bufferAddressPU1toPU2_CM = CPU1TOCM_RAMMSG_IPC_START_CMVIEW + (buffCPU1CMOffsetInWords * 2);\n                isH_PU1 = 1U;\n                #elif defined(CM)\n                sharedAddressPU1toPU2 = CPU1TOCM_RAMMSG_IPC_START_CMVIEW + (IpcParams->ChNum * MW_SIZE_IPC_CHANNELS_INFO_C28xCM);\n                sharedAddressPU2toPU1 = CMTOCPU1_RAMMSG_IPC_START_CMVIEW + (IpcParams->ChNum * MW_SIZE_IPC_CHANNELS_INFO_C28xCM);\n                bufferAddressPU2toPU1 = CMTOCPU_RAMMSG_IPC_START_C28XVIEW + (buffCPU1CMOffsetInBytes / 2);\n                bufferAddressPU2toPU1_CM = CMTOCPU1_RAMMSG_IPC_START_CMVIEW + buffCPU1CMOffsetInBytes;\n                isH_PU1 = 0U;\n                #endif\n            #endif\n            break;\n        case IPC_CPU2CM:\n            #if defined(CPU2_CM_IPC)\n                #if defined(CPU2)\n                sharedAddressPU1toPU2 = CPUTOCM_RAMMSG_IPC_START_C28XVIEW + (IpcParams->ChNum * MW_SIZE_IPC_CHANNELS_INFO_C28xCM);\n                sharedAddressPU2toPU1 = CMTOCPU_RAMMSG_IPC_START_C28XVIEW + (IpcParams->ChNum * MW_SIZE_IPC_CHANNELS_INFO_C28xCM);\n                bufferAddressPU1toPU2 = CPUTOCM_RAMMSG_IPC_START_C28XVIEW + buffCPU2CMOffsetInWords;\n                bufferAddressPU1toPU2_CM = CPU2TOCM_RAMMSG_IPC_START_CMVIEW + (buffCPU2CMOffsetInWords * 2);\n                isH_PU1 = 1U;\n                #elif defined(CM)\n                sharedAddressPU1toPU2 = CPU2TOCM_RAMMSG_IPC_START_CMVIEW + (IpcParams->ChNum * MW_SIZE_IPC_CHANNELS_INFO_C28xCM);\n                sharedAddressPU2toPU1 = CMTOCPU2_RAMMSG_IPC_START_CMVIEW + (IpcParams->ChNum * MW_SIZE_IPC_CHANNELS_INFO_C28xCM);\n                bufferAddressPU2toPU1 = CMTOCPU_RAMMSG_IPC_START_C28XVIEW + (buffCPU2CMOffsetInBytes / 2);\n                bufferAddressPU2toPU1_CM = CMTOCPU2_RAMMSG_IPC_START_CMVIEW + buffCPU2CMOffsetInBytes;\n                isH_PU1 = 0U;\n                #endif\n            #endif\n            break;\n        case IPC_CPU1CLA:\n        case IPC_CPU2CLA:\n            #if defined(CPU1_CLA_IPC) || defined(CPU2_CLA_IPC)\n                #if defined(CPU1) || defined(CPU2)\n                sharedAddressPU1toPU2 = CPUTOCLA_SHRD_MSG_RAM + (IpcParams->ChNum * MW_SIZE_IPC_CHANNELS_INFO);\n                sharedAddressPU2toPU1 = CLATOCPU_SHRD_MSG_RAM + (IpcParams->ChNum * MW_SIZE_IPC_CHANNELS_INFO);\n                bufferAddressPU1toPU2 = CPUTOCLA_SHRD_MSG_RAM + buffCPUCLAOffsetInWords;\n                bufferAddressPU2toPU1 = CLATOCPU_SHRD_MSG_RAM + buffCPUCLAOffsetInWords;\n                isH_PU1 = 1U;\n                #endif\n            #endif\n            break;\n    }\n\n    /* Initialize required GS RAM for each C28x core. */\n    #ifdef CPU1_CPU2_IPC\n    if (IpcParams->IPCBetween == IPC_CPU1CPU2)\n    {\n        #if defined(CPU1)\n        if (!isInitialized)\n        {\n            uint32_T i = 0;\n            uint32_T MemCfgRegVar = 0;\n\n            EALLOW;\n            #if defined(MW_F28P65X) /* Set access for GS RAMs that are 8K words each. */\n                /* Set access of GS RAM for CPU1. */\n                for (i = ((uint32_T)CPU1TOCPU2_RAMGS_IPC_START) >> 12; i < (((uint32_T)CPU1TOCPU2_RAMGS_IPC_LENGTH + (uint32_T)CPU1TOCPU2_RAMGS_IPC_START) >> 12); i = i + 2)\n                {\n                    MemCfgRegVar = MemCfgRegVar & (~(1UL << ((i - RAMGS_START) / 2)));\n                }\n                \n                /* Set access of GS RAM for CPU2. */\n                for (i = ((uint32_T)CPU2TOCPU1_RAMGS_IPC_START) >> 12; i < (((uint32_T)CPU2TOCPU1_RAMGS_IPC_LENGTH + (uint32_T)CPU2TOCPU1_RAMGS_IPC_START) >> 12); i = i + 2)\n                {\n                    MemCfgRegVar = MemCfgRegVar | (1UL << ((i - RAMGS_START) / 2));\n                }\n            #else /* Set access for GS RAMs that are 4K words each. */\n                /* Set access of GS RAM for CPU1. */\n                for (i = ((uint32_T)CPU1TOCPU2_RAMGS_IPC_START) >> 12; i < (((uint32_T)CPU1TOCPU2_RAMGS_IPC_LENGTH + (uint32_T)CPU1TOCPU2_RAMGS_IPC_START) >> 12); i++)\n                {\n                    MemCfgRegVar = MemCfgRegVar & (~(1UL << (i - RAMGS_START)));\n                }\n                \n                /* Set access of GS RAM for CPU2. */\n                for (i = ((uint32_T)CPU2TOCPU1_RAMGS_IPC_START) >> 12; i < (((uint32_T)CPU2TOCPU1_RAMGS_IPC_LENGTH + (uint32_T)CPU2TOCPU1_RAMGS_IPC_START) >> 12); i++)\n                {\n                    MemCfgRegVar = MemCfgRegVar | (1UL << (i - RAMGS_START));\n                }\n            #endif\n            MemCfgRegs.GSxMSEL.all = MemCfgRegs.GSxMSEL.all | MemCfgRegVar;\n            EDIS;\n            isInitialized = 1U;\n        }\n        #endif\n    }\n    #endif /* CPU1_CPU2_IPC */\n\n    /* Initialize the IPC handles. */\n    #if defined(CPU1_CPU2_IPC) || defined(CPU1_CM_IPC) || defined(CPU2_CM_IPC)\n    if (IpcParams->IPCBetween == IPC_CPU1CPU2 || IpcParams->IPCBetween == IPC_CPU1CM || IpcParams->IPCBetween == IPC_CPU2CM)\n    {\n        ipcHandle.H_PU1.numOfBuffers = IpcParams->NumOfBuffers;\n        ipcHandle.H_PU1.intEnable = IpcParams->IsIntEnabled;\n        ipcHandle.H_PU1.chNum = IpcParams->ChNum;\n\n        ipcHandle.H_PU1.head.ptr = (uint16_T *)sharedAddressPU1toPU2;\n        ipcHandle.H_PU1.tail.ptr = (uint16_T *)(sharedAddressPU1toPU2 + 1*sizeof(uint16_T));\n        ipcHandle.H_PU1.full.ptr = (uint16_T *)(sharedAddressPU1toPU2 + 2*sizeof(uint16_T));\n        ipcHandle.H_PU1.mutex.ptr = (uint16_T *)(sharedAddressPU1toPU2 + 3*sizeof(uint16_T));\n        ipcHandle.H_PU1.overwrite.ptr = (uint16_T *)(sharedAddressPU1toPU2 + 4*sizeof(uint16_T));\n        ipcHandle.H_PU1.lastReadStatus.ptr = (uint16_T *)(sharedAddressPU1toPU2 + 5*sizeof(uint16_T));\n        ipcHandle.H_PU1.bufferLength.ptr = (uint16_T *)(sharedAddressPU1toPU2 + 6*sizeof(uint16_T));\n        ipcHandle.H_PU1.dataTypeInBytes.ptr = (uint16_T *)(sharedAddressPU1toPU2 + 7*sizeof(uint16_T));\n        ipcHandle.H_PU1.bufferStartAdd.ptr = (CLA_PTR *)(sharedAddressPU1toPU2 + 8*sizeof(uint16_T));\n\n        ipcHandle.H_PU2.numOfBuffers = IpcParams->NumOfBuffers;\n        ipcHandle.H_PU2.intEnable = IpcParams->IsIntEnabled;\n        ipcHandle.H_PU2.chNum = IpcParams->ChNum;\n\n        ipcHandle.H_PU2.head.ptr = (uint16_T *)sharedAddressPU2toPU1;\n        ipcHandle.H_PU2.tail.ptr = (uint16_T *)(sharedAddressPU2toPU1 + 1*sizeof(uint16_T));\n        ipcHandle.H_PU2.full.ptr = (uint16_T *)(sharedAddressPU2toPU1 + 2*sizeof(uint16_T));\n        ipcHandle.H_PU2.mutex.ptr = (uint16_T *)(sharedAddressPU2toPU1 + 3*sizeof(uint16_T));\n        ipcHandle.H_PU2.overwrite.ptr = (uint16_T *)(sharedAddressPU2toPU1 + 4*sizeof(uint16_T));\n        ipcHandle.H_PU2.lastReadStatus.ptr = (uint16_T *)(sharedAddressPU2toPU1 + 5*sizeof(uint16_T));\n        ipcHandle.H_PU2.bufferLength.ptr = (uint16_T *)(sharedAddressPU2toPU1 + 6*sizeof(uint16_T));\n        ipcHandle.H_PU2.dataTypeInBytes.ptr = (uint16_T *)(sharedAddressPU2toPU1 + 7*sizeof(uint16_T));\n        ipcHandle.H_PU2.bufferStartAdd.ptr = (CLA_PTR *)(sharedAddressPU2toPU1 + 8*sizeof(uint16_T));\n\n        volatile IPCChannelStruct_T *ipcHandlePU; /* Temporary handle to select only the current processing unit. */\n\n        if (isH_PU1)\n        {\n            ipcHandlePU = &ipcHandle.H_PU1;\n        }\n        else\n        {\n            ipcHandlePU = &ipcHandle.H_PU2;\n        }\n\n        /* Initialize channel only for the current processing unit. */\n        *(ipcHandlePU->head.ptr) = 0;\n        *(ipcHandlePU->tail.ptr) = 0;\n        *(ipcHandlePU->full.ptr) = 0;\n        *(ipcHandlePU->mutex.ptr) = 0;\n        *(ipcHandlePU->overwrite.ptr) = 0;\n        *(ipcHandlePU->lastReadStatus.ptr) = 0;\n        *(ipcHandlePU->bufferLength.ptr) = IpcParams->BufferSize;\n        *(ipcHandlePU->dataTypeInBytes.ptr) = (ADDRESS_GRANULARITY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULARITY : IpcParams->DataTypeInBytes;\n\n        /* Initialize the buffer double pointer(s). */\n        switch (IpcParams->IPCBetween)\n        {\n            case IPC_CPU1CPU2:\n                #if defined(CPU1_CPU2_IPC)\n                    #if defined(CPU1)\n                    (*(ipcHandlePU->bufferStartAdd.ptr)).ptr = (uint16_T *)bufferAddressPU1toPU2;\n                    #elif defined(CPU2)\n                    (*(ipcHandlePU->bufferStartAdd.ptr)).ptr = (uint16_T *)bufferAddressPU2toPU1;\n                    #endif\n                #endif\n                break;\n            case IPC_CPU1CM:\n            case IPC_CPU2CM:\n                #if defined(CPU1_CM_IPC) || defined(CPU2_CM_IPC)\n                    #if defined(CPU1) || defined(CPU2)\n                    (*(ipcHandlePU->bufferStartAdd.ptr)).ptr = (uint16_T *)bufferAddressPU1toPU2;\n                    (*(ipcHandlePU->bufferStartAdd.ptr + 1)).ptr = (uint16_T *)bufferAddressPU1toPU2_CM;\n                    #elif defined(CM)\n                    (*(ipcHandlePU->bufferStartAdd.ptr)).ptr = (uint16_T *)bufferAddressPU2toPU1_CM;\n                    (*(ipcHandlePU->bufferStartAdd.ptr + 1)).ptr = (uint16_T *)bufferAddressPU2toPU1;\n                    #endif\n                #endif\n                break;\n        }\n\n        /* Update the offset for the buffer memory section.\n        * The offset required for each IPC channel buffer is the product of the buffer size, number of buffers and the data type.\n        * The smallest memory unit that can be used is set by ADDRESS_GRANULARITY, and hence this is compared with the data type.\n        * Separate offset variables required for CPU1_CM_IPC and CPU2_CM_IPC as CM has to keep track of both.\n        * For the C28x view, data is stored in words (2 bytes) and hence the data type in bytes is converted to words.\n        * For the CM view, data is stored in bytes and hence no conversion is necessary for the data type in bytes.\n        * \n        * For example consider an IPC channel that sends uint16_T var[10] with 2 buffers,\n        *      For C28x/CLA views: BufferSize = 10; NumOfBuffers = 2; DataTypeInBytes = 2; OffsetInWords = 10 * 2 * 2 / 2 = 20 words.\n        *      For CM view: BufferSize = 10; NumOfBuffers = 2; DataTypeInBytes = 2; OffsetInBytes = 10 * 2 * 2 = 40 bytes.\n        */\n        switch (IpcParams->IPCBetween)\n        {\n            case IPC_CPU1CPU2:\n                #if defined(CPU1_CPU2_IPC)\n                    #if defined(CPU1) || defined(CPU2)\n                    buffCPUOffsetInWords = buffCPUOffsetInWords + (IpcParams->BufferSize * IpcParams->NumOfBuffers * ((ADDRESS_GRANULARITY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULARITY : IpcParams->DataTypeInBytes) / 2);\n                    #endif\n                #endif\n                break;\n            case IPC_CPU1CM:\n                #if defined(CPU1_CM_IPC)\n                    #if defined(CPU1)\n                    buffCPU1CMOffsetInWords = buffCPU1CMOffsetInWords + (IpcParams->BufferSize * IpcParams->NumOfBuffers * ((ADDRESS_GRANULARITY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULARITY : IpcParams->DataTypeInBytes) / 2);\n                    #elif defined(CM)\n                    buffCPU1CMOffsetInBytes = buffCPU1CMOffsetInBytes + (IpcParams->BufferSize * IpcParams->NumOfBuffers * ((ADDRESS_GRANULARITY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULARITY : IpcParams->DataTypeInBytes));\n                    #endif\n                #endif\n                break;\n            case IPC_CPU2CM:\n                #if defined(CPU2_CM_IPC)\n                    #if defined(CPU2)\n                    buffCPU2CMOffsetInWords = buffCPU2CMOffsetInWords + (IpcParams->BufferSize * IpcParams->NumOfBuffers * ((ADDRESS_GRANULARITY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULARITY : IpcParams->DataTypeInBytes) / 2);\n                    #elif defined(CM)\n                    buffCPU2CMOffsetInBytes = buffCPU2CMOffsetInBytes + (IpcParams->BufferSize * IpcParams->NumOfBuffers * ((ADDRESS_GRANULARITY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULARITY : IpcParams->DataTypeInBytes));\n                    #endif\n                #endif\n                break;\n        }\n\n        /* Enable interrupts for the required IPC channel. */\n        if (ipcHandlePU->intEnable)\n        {\n            if (IpcParams->IPCBetween == IPC_CPU1CPU2)\n            {\n                #if defined(CPU1_CPU2_IPC)\n                    #if defined(CPU1)\n                    switch (ipcHandlePU->chNum)\n                    {\n                        case 0:\n                            #if defined(MW_F2838X) || defined(MW_F28P65X)\n                            Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.bit.IPC0 = 1U;\n                            #else\n                            IpcRegs.IPCACK.bit.IPC0 = 1U;\n                            #endif\n                            break;\n                        case 1:\n                            #if defined(MW_F2838X) || defined(MW_F28P65X)\n                            Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.bit.IPC1 = 1U;\n                            #else\n                            IpcRegs.IPCACK.bit.IPC1 = 1U;\n                            #endif\n                            break;\n                        case 2:\n                            #if defined(MW_F2838X) || defined(MW_F28P65X)\n                            Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.bit.IPC2 = 1U;\n                            #else\n                            IpcRegs.IPCACK.bit.IPC2 = 1U;\n                            #endif\n                            break;\n                        case 3:\n                            #if defined(MW_F2838X) || defined(MW_F28P65X)\n                            Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.bit.IPC3 = 1U;\n                            #else\n                            IpcRegs.IPCACK.bit.IPC3 = 1U;\n                            #endif\n                            break;\n                    }\n                    #elif defined(CPU2)\n                    switch (ipcHandlePU->chNum)\n                    {\n                        case 0:\n                            #if defined(MW_F2838X) || defined(MW_F28P65X)\n                            Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.bit.IPC0 = 1U;\n                            #else\n                            IpcRegs.IPCACK.bit.IPC0 = 1U;\n                            #endif\n                            break;\n                        case 1:\n                            #if defined(MW_F2838X) || defined(MW_F28P65X)\n                            Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.bit.IPC1 = 1U;\n                            #else\n                            IpcRegs.IPCACK.bit.IPC1 = 1U;\n                            #endif\n                            break;\n                        case 2:\n                            #if defined(MW_F2838X) || defined(MW_F28P65X)\n                            Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.bit.IPC2 = 1U;\n                            #else\n                            IpcRegs.IPCACK.bit.IPC2 = 1U;\n                            #endif\n                            break;\n                        case 3:\n                            #if defined(MW_F2838X) || defined(MW_F28P65X)\n                            Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.bit.IPC3 = 1U;\n                            #else\n                            IpcRegs.IPCACK.bit.IPC3 = 1U;\n                            #endif\n                            break;\n                    }\n                    #endif\n                #endif /* CPU1_CPU2_IPC */\n            }\n            else if (IpcParams->IPCBetween == IPC_CPU1CM)\n            {\n                #if defined(CPU1_CM_IPC)\n                    #if defined(CPU1)\n                    switch (ipcHandlePU->chNum)\n                    {\n                        case 0:\n                            #if defined(MW_F2838X) || defined(MW_F28P65X)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC0 = 1U;\n                            #else\n                            IpcRegs.IPCACK.bit.IPC0 = 1U;\n                            #endif\n                            break;\n                        case 1:\n                            #if defined(MW_F2838X) || defined(MW_F28P65X)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC1 = 1U;\n                            #else\n                            IpcRegs.IPCACK.bit.IPC1 = 1U;\n                            #endif\n                            break;\n                        case 2:\n                            #if defined(MW_F2838X) || defined(MW_F28P65X)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC2 = 1U;\n                            #else\n                            IpcRegs.IPCACK.bit.IPC2 = 1U;\n                            #endif\n                            break;\n                        case 3:\n                            #if defined(MW_F2838X) || defined(MW_F28P65X)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC3 = 1U;\n                            #else\n                            IpcRegs.IPCACK.bit.IPC3 = 1U;\n                            #endif\n                            break;\n                        case 4:\n                            #if defined(MW_F2838X)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC4 = 1U;\n                            #endif\n                            break;\n                        case 5:\n                            #if defined(MW_F2838X)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC5 = 1U;\n                            #endif\n                            break;\n                        case 6:\n                            #if defined(MW_F2838X)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC6 = 1U;\n                            #endif\n                            break;\n                        case 7:\n                            #if defined(MW_F2838X)\n                            Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC7 = 1U;\n                            #endif\n                            break;\n                    }\n                    #elif defined(CM)\n                    IPC_CMTOCPU1_FlagReg->IPC_ACK |= ipcflag1;\n                    #endif\n                #endif /* CPU1_CM_IPC */\n            }\n            else if (IpcParams->IPCBetween == IPC_CPU2CM)\n            {\n                #if defined(CPU2_CM_IPC)\n                    #if defined(CPU2)\n                    switch (ipcHandle.H_PU1.chNum)\n                    {\n                        case 0:\n                            #if defined(MW_F2838X) || defined(MW_F28P65X)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC0 = 1U;\n                            #else\n                            IpcRegs.IPCACK.bit.IPC0 = 1U;\n                            #endif\n                            break;\n                        case 1:\n                            #if defined(MW_F2838X) || defined(MW_F28P65X)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC1 = 1U;\n                            #else\n                            IpcRegs.IPCACK.bit.IPC1 = 1U;\n                            #endif\n                            break;\n                        case 2:\n                            #if defined(MW_F2838X) || defined(MW_F28P65X)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC2 = 1U;\n                            #else\n                            IpcRegs.IPCACK.bit.IPC2 = 1U;\n                            #endif\n                            break;\n                        case 3:\n                            #if defined(MW_F2838X) || defined(MW_F28P65X)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC3 = 1U;\n                            #else\n                            IpcRegs.IPCACK.bit.IPC3 = 1U;\n                            #endif\n                            break;\n                        case 4:\n                            #if defined(MW_F2838X)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC4 = 1U;\n                            #endif\n                            break;\n                        case 5:\n                            #if defined(MW_F2838X)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC5 = 1U;\n                            #endif\n                            break;\n                        case 6:\n                            #if defined(MW_F2838X)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC6 = 1U;\n                            #endif\n                            break;\n                        case 7:\n                            #if defined(MW_F2838X)\n                            Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC7 = 1U;\n                            #endif\n                            break;\n                    }\n                    #elif defined(CM)\n                    IPC_CMTOCPU2_FlagReg->IPC_ACK |= ipcflag1;\n                    #endif\n                #endif /* CPU2_CM_IPC */\n            }\n        }\n\n        ipcHandle.H_IPCBetween = IpcParams->IPCBetween;\n\n        return (MW_IPC_Handle) ipcHandle;\n    }\n    #endif /* CPU1_CPU2_IPC || CPU1_CM_IPC || CPU2_CM_IPC */\n\n    /* TO DO: This section will be merged with the previous logic. Keeping this section for now as CLA IPC initialization is done twice by CPU, and hence a global handle is required to keep track of which channels are done. */\n    #if defined(CPU1_CLA_IPC) || defined(CPU2_CLA_IPC)\n    if (IpcParams->IPCBetween == IPC_CPU1CLA || IpcParams->IPCBetween == IPC_CPU2CLA)\n    {\n        volatile uint32_T blkC1CLA1ChIndex = MW_bSearch_IPC_Channels(ipcChannelCPUCLAList, MW_NUM_IPC_CHANNELS_CPUCLA, IpcParams->ChNum);\n\n        if (ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.head.ptr == (uint16_T *)sharedAddressPU1toPU2)\n        {\n            return (MW_IPC_Handle) ipcHandleForCPUCLA[blkC1CLA1ChIndex];\n        }\n\n        /* CPU to CLA channel init. */\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.numOfBuffers = IpcParams->NumOfBuffers;\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.intEnable = IpcParams->IsIntEnabled;\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.chNum = IpcParams->ChNum;\n\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.head.ptr = (uint16_T *)sharedAddressPU1toPU2;\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.tail.ptr = (uint16_T *)(sharedAddressPU1toPU2 + 1*sizeof(uint16_T));\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.full.ptr = (uint16_T *)(sharedAddressPU1toPU2 + 2*sizeof(uint16_T));\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.mutex.ptr = (uint16_T *)(sharedAddressPU1toPU2 + 3*sizeof(uint16_T));\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.overwrite.ptr = (uint16_T *)(sharedAddressPU1toPU2 + 4*sizeof(uint16_T));\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.lastReadStatus.ptr = (uint16_T *)(sharedAddressPU1toPU2 + 5*sizeof(uint16_T));\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.bufferLength.ptr = (uint16_T *)(sharedAddressPU1toPU2 + 6*sizeof(uint16_T));\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.dataTypeInBytes.ptr = (uint16_T *)(sharedAddressPU1toPU2 + 7*sizeof(uint16_T));\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.bufferStartAdd.ptr = (CLA_PTR *)(sharedAddressPU1toPU2 + 8*sizeof(uint16_T));\n\n        *(ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.head.ptr) = 0U;\n        *(ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.tail.ptr) = 0U;\n        *(ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.full.ptr) = 0U;\n        *(ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.mutex.ptr) = 0U;\n        *(ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.overwrite.ptr) = 0U;\n        *(ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.lastReadStatus.ptr) = 0U;\n        *(ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.bufferLength.ptr) = IpcParams->BufferSize;\n        *(ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.dataTypeInBytes.ptr) = (ADDRESS_GRANULARITY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULARITY : IpcParams->DataTypeInBytes;\n        (*(ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU1.bufferStartAdd.ptr)).ptr = (uint16_T *)bufferAddressPU1toPU2;\n\n        /* CLA to CPU channel init. */\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU2.numOfBuffers = IpcParams->NumOfBuffers;\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU2.intEnable = IpcParams->IsIntEnabled;\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU2.chNum = IpcParams->ChNum;\n\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU2.head.ptr = (uint16_T *)sharedAddressPU2toPU1;\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU2.tail.ptr = (uint16_T *)(sharedAddressPU2toPU1 + 1*sizeof(uint16_T));\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU2.full.ptr = (uint16_T *)(sharedAddressPU2toPU1 + 2*sizeof(uint16_T));\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU2.mutex.ptr = (uint16_T *)(sharedAddressPU2toPU1 + 3*sizeof(uint16_T));\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU2.overwrite.ptr = (uint16_T *)(sharedAddressPU2toPU1 + 4*sizeof(uint16_T));\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU2.lastReadStatus.ptr = (uint16_T *)(sharedAddressPU2toPU1 + 5*sizeof(uint16_T));\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU2.bufferLength.ptr = (uint16_T *)(sharedAddressPU2toPU1 + 6*sizeof(uint16_T));\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU2.dataTypeInBytes.ptr = (uint16_T *)(sharedAddressPU2toPU1 + 7*sizeof(uint16_T));\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU2.bufferStartAdd.ptr = (CLA_PTR *)(sharedAddressPU2toPU1 + 8*sizeof(uint16_T));\n\n        *(ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU2.head.ptr) = 0U;\n        *(ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU2.tail.ptr) = 0U;\n        *(ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU2.full.ptr) = 0U;\n        *(ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU2.mutex.ptr) = 0U;\n        *(ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU2.overwrite.ptr) = 0U;\n        *(ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU2.lastReadStatus.ptr) = 0U;\n        *(ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU2.bufferLength.ptr) = IpcParams->BufferSize;\n        *(ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU2.dataTypeInBytes.ptr) = (ADDRESS_GRANULARITY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULARITY : IpcParams->DataTypeInBytes;\n        (*(ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_PU2.bufferStartAdd.ptr)).ptr = (uint16_T *)bufferAddressPU2toPU1;\n\n        buffCPUCLAOffsetInWords = buffCPUCLAOffsetInWords + (IpcParams->BufferSize * IpcParams->NumOfBuffers * ((ADDRESS_GRANULARITY > IpcParams->DataTypeInBytes) ? ADDRESS_GRANULARITY : IpcParams->DataTypeInBytes) / 2);\n\n        ipcHandleForCPUCLA[blkC1CLA1ChIndex].H_IPCBetween = IpcParams->IPCBetween;\n\n        return (MW_IPC_Handle) ipcHandleForCPUCLA[blkC1CLA1ChIndex];\n    }\n    #endif /* CPU1_CLA_IPC || CPU2_CLA_IPC */\n\n    return (MW_IPC_Handle) ipcHandle; /* Should be unreachable. Adding to suppress warning. */\n}\n\nvoid MW_IPC_Write(MW_IPC_Handle* ipcHandle, uint16_T CurrentPU, MW_Const_Void_Ptr_T dataToSend, MW_IPC_Diag_T *diagDataOut)\n{\n    #if defined(CPU1_CPU2_IPC) || defined(CPU1_CM_IPC) || defined(CPU2_CM_IPC) || defined(CPU1_CLA_IPC) || defined(CPU2_CLA_IPC)\n    volatile IPCChannelStruct_T *procUnit1; /* Writing core's info. */\n    volatile IPCChannelStruct_T *procUnit2; /* Reading core's info. */\n\n    if ((ipcHandle->H_IPCBetween == IPC_CPU1CPU2 && CurrentPU == IPC_c28xCPU1) ||\n        (ipcHandle->H_IPCBetween == IPC_CPU1CM && CurrentPU == IPC_c28xCPU1) ||\n        (ipcHandle->H_IPCBetween == IPC_CPU2CM && CurrentPU == IPC_c28xCPU2) ||\n        (ipcHandle->H_IPCBetween == IPC_CPU1CLA) ||\n        (ipcHandle->H_IPCBetween == IPC_CPU2CLA))\n    {\n        procUnit1 = &ipcHandle->H_PU1;\n        procUnit2 = &ipcHandle->H_PU2;\n    }\n    else\n    {\n        procUnit1 = &ipcHandle->H_PU2;\n        procUnit2 = &ipcHandle->H_PU1;\n    }\n\n    uint16_T head = *procUnit1->head.ptr;\n    uint16_T tail;\n    uint16_T dataInBytes;\n    uint16_T dataInWords; /* 16-bits int size is 1 word. */\n\n    dataInBytes = *procUnit1->bufferLength.ptr * (*procUnit1->dataTypeInBytes.ptr);\n    dataInWords = dataInBytes / 2;\n\n    while (*procUnit2->mutex.ptr)\n    {\n        continue;\n    }; /* Wait while reading CPU is updating its flags. */\n    *procUnit1->mutex.ptr = 1U; /* Lock the mutex. */\n\n    if ((head | 0xF0U) != (*procUnit2->tail.ptr & 0xFFU)) /* Tail of reading CPU is compared with head of writing CPU. */\n    {\n        *procUnit1->head.ptr = head | 0xF0U; /* Set writing in progress. */\n        /* If buffer is full and the reading CPU has not yet read the data - overwrite the contents at this buffer location.\n        * The full flag is updated at the end of this funciton. So at this point, we are looking at the full flag from the previous run.\n        * In case the reader has read data, the full flag is no longer indicating the correct status. To take care of such a condition, the lastReadStatus is used.\n        * The reader lastReadStatus is updated when ever the reader reads data and the writer full flag is set.\n        */\n        if (*procUnit1->full.ptr && *procUnit1->lastReadStatus.ptr == *procUnit2->lastReadStatus.ptr)\n        {\n            /* Update tail value in writer CPU. This is the correct position to read from next. The reading CPU will update its tail to match with this. */\n            tail = ((head + 1) >= procUnit1->numOfBuffers) ? 0 : (head + 1);\n            *procUnit1->tail.ptr = tail;\n            /* Increment overwrite.\n            * Writer overwrite flag is updated by counting up. The counter value is used by the reader CPU to decide whether the flag is outdated or not.\n            */\n            *procUnit1->overwrite.ptr = *procUnit2->overwrite.ptr + 1;\n            /* For diagnostics - update number of overwrites. */\n            diagDataOut->OverwriteDiag = diagDataOut->OverwriteDiag + 1;\n        }\n        else\n        {\n            *procUnit1->lastReadStatus.ptr = *procUnit2->lastReadStatus.ptr;\n            *procUnit1->tail.ptr = *procUnit2->tail.ptr;\n            *procUnit1->overwrite.ptr = 0;\n            tail = *procUnit2->tail.ptr;\n        }\n        *procUnit1->mutex.ptr = 0U; /* Unlock the mutex. */\n\n        #if defined(CM)\n        /* For the CM view, data is stored in bytes and hence the size to be copied is dataInBytes.\n        * CM writes to its own buffer, and hence the address at bufferStartAdd of the writer is used.\n        */\n        memcpy((*(procUnit1->bufferStartAdd.ptr)).ptr + (head * dataInWords), dataToSend, dataInBytes);\n        #else\n        /* For the C28x view, data is stored in words and hence the size to be copied is dataInWords.\n        * C28x writes to its own buffer, and hence the address at bufferStartAdd of the writer is used.\n        */\n        memcpy_fast((*(procUnit1->bufferStartAdd.ptr)).ptr + (head * dataInWords), dataToSend, dataInWords);\n        #endif\n\n        *procUnit1->head.ptr = ((head + 1) >= procUnit1->numOfBuffers) ? 0 : (head + 1);\n        *procUnit1->full.ptr = (*procUnit1->head.ptr == tail);\n    }\n    else /* If reading is in progress advance head. Head jumps the tail always. */\n    {\n        *procUnit1->head.ptr = (((head + 1) >= procUnit1->numOfBuffers) ? 0 : (head + 1)) | 0xF0U;\n        *procUnit1->mutex.ptr = 0U;\n\n        #if defined(CM)\n        /* For the CM view, data is stored in bytes and hence the size to be copied is dataInBytes.\n        * CM writes to its own buffer, and hence the address at bufferStartAdd of the writer is used.\n        */\n        memcpy((*(procUnit1->bufferStartAdd.ptr)).ptr + (((head + 1) >= procUnit1->numOfBuffers) ? 0 : (head + 1)) * dataInWords, dataToSend, dataInBytes);\n        #else\n        /* For the C28x view, data is stored in words and hence the size to be copied is dataInWords.\n        * C28x writes to its own buffer, and hence the address at bufferStartAdd of the writer is used.\n        */\n        memcpy_fast((*(procUnit1->bufferStartAdd.ptr)).ptr + (((head + 1) >= procUnit1->numOfBuffers) ? 0 : (head + 1)) * dataInWords, dataToSend, dataInWords);\n        #endif\n\n        *procUnit1->head.ptr = ((head + 2) >= procUnit1->numOfBuffers) ? 0 : (head + 2);\n        *procUnit1->full.ptr = (*procUnit1->head.ptr == tail);\n    }\n\n    /* Interrupts */\n    /* No need to handle interrupts if communicating with CLA. */\n    if (procUnit1->intEnable &&\n        !((ipcHandle->H_IPCBetween == IPC_CPU1CLA) || (ipcHandle->H_IPCBetween == IPC_CPU2CLA)))\n    {\n        #if defined(CPU1)\n        switch (procUnit1->chNum)\n        {\n            case 0:\n                #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if (ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                    {\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCSET.bit.IPC0 = 1U;\n                    }\n                    #if defined(MW_F2838X)\n                    else if (ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                    {\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC0 = 1U;\n                    }\n                    #endif\n                #else\n                    IpcRegs.IPCSET.bit.IPC0 = 1U;\n                #endif\n                break;\n            case 1:\n                #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if (ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                    {\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCSET.bit.IPC1 = 1U;\n                    }\n                    #if defined(MW_F2838X)\n                    else if (ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                    {\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC1 = 1U;\n                    }\n                    #endif\n                #else\n                    IpcRegs.IPCSET.bit.IPC1 = 1U;\n                #endif\n                break;\n            case 2:\n                #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if (ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                    {\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCSET.bit.IPC2 = 1U;\n                    }\n                    #if defined(MW_F2838X)\n                    else if (ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                    {\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC2 = 1U;\n                    }\n                    #endif\n                #else\n                    IpcRegs.IPCSET.bit.IPC2 = 1U;\n                #endif\n                break;\n            case 3:\n                #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if (ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                    {\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCSET.bit.IPC3 = 1U;\n                    }\n                    #if defined(MW_F2838X)\n                    else if (ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                    {\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC3 = 1U;\n                    }\n                    #endif\n                #else\n                    IpcRegs.IPCSET.bit.IPC3 = 1U;\n                #endif\n                break;\n            case 4:\n                #if defined(MW_F2838X)\n                if (ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                {\n                    Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC4 = 1U;\n                }\n                #endif\n                break;\n            case 5:\n                #if defined(MW_F2838X)\n                if (ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                {\n                    Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC5 = 1U;\n                }\n                #endif\n                break;\n            case 6:\n                #if defined(MW_F2838X)\n                if (ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                {\n                    Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC6 = 1U;\n                }\n                #endif\n                break;\n            case 7:\n                #if defined(MW_F2838X)\n                if (ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                {\n                    Cpu1toCmIpcRegs.CPU1TOCMIPCSET.bit.IPC7 = 1U;\n                }\n                #endif\n                break;\n        }\n        #elif defined(CPU2)\n        switch (procUnit1->chNum)\n        {\n            case 0:\n                #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if (ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                    {\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCSET.bit.IPC0 = 1U;\n                    }\n                    #if defined(MW_F2838X)\n                    else if (ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                    {\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC0 = 1U;\n                    }\n                    #endif\n                #else\n                    IpcRegs.IPCSET.bit.IPC0 = 1U;\n                #endif\n                break;\n            case 1:\n                #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if (ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                    {\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCSET.bit.IPC1 = 1U;\n                    }\n                    #if defined(MW_F2838X)\n                    else if (ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                    {\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC1 = 1U;\n                    }\n                    #endif\n                #else\n                    IpcRegs.IPCSET.bit.IPC1 = 1U;\n                #endif\n                break;\n            case 2:\n                #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if (ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                    {\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCSET.bit.IPC2 = 1U;\n                    }\n                    #if defined(MW_F2838X)\n                    else if (ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                    {\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC2 = 1U;\n                    }\n                    #endif\n                #else\n                    IpcRegs.IPCSET.bit.IPC2 = 1U;\n                #endif\n                break;\n            case 3:\n                #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if (ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                    {\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCSET.bit.IPC3 = 1U;\n                    }\n                    #if defined(MW_F2838X)\n                    else if (ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                    {\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC3 = 1U;\n                    }\n                    #endif\n                #else\n                    IpcRegs.IPCSET.bit.IPC3 = 1U;\n                #endif\n                break;\n            case 4:\n                #if defined(MW_F2838X)\n                if (ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                {\n                    Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC4 = 1U;\n                }\n                #endif\n                break;\n            case 5:\n                #if defined(MW_F2838X)\n                if (ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                {\n                    Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC5 = 1U;\n                }\n                #endif\n                break;\n            case 6:\n                #if defined(MW_F2838X)\n                if (ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                {\n                    Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC6 = 1U;\n                }\n                #endif\n                break;\n            case 7:\n                #if defined(MW_F2838X)\n                if (ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                {\n                    Cpu2toCmIpcRegs.CPU2TOCMIPCSET.bit.IPC7 = 1U;\n                }\n                #endif\n                break;\n        }\n        #elif defined(CM)\n        uint32_T ipcflag = 0x00000001, ipcflag1;\n        ipcflag1 = ipcflag << procUnit1->chNum;\n        if (ipcHandle->H_IPCBetween == IPC_CPU1CM)\n        {\n            IPC_CMTOCPU1_FlagReg->IPC_SET |= ipcflag1;\n        }\n        else if (ipcHandle->H_IPCBetween == IPC_CPU2CM)\n        {\n            IPC_CMTOCPU2_FlagReg->IPC_SET |= ipcflag1;\n        }\n        #endif\n    }\n\n    /* For diagnostics - calculate number of buffers used. */\n    if (*procUnit1->full.ptr == 1U)\n    {\n        diagDataOut->NumBuffUsedDiag = procUnit1->numOfBuffers;\n    }\n    else\n    {\n        if (head >= tail)\n        {\n            diagDataOut->NumBuffUsedDiag = (head - tail) + 1;\n        }\n        else\n        {\n            diagDataOut->NumBuffUsedDiag = ((head + procUnit1->numOfBuffers) - tail);\n        }\n    }\n    #endif\n}\n\nvoid MW_IPC_Read(MW_IPC_Handle* ipcHandle, uint16_T CurrentPU, MW_Void_Ptr_T dataTobeRead, int8_T* status)\n{\n    /*  Do all status should be update in both CPU1 & CPU2 & CLA.\n    * 0 - No errors.\n    * 1 - Data not available.\n    * 2 - Data type mismatch => uint16_T dataInBytes = *procUnit1->bufferLength.ptr * (*procUnit1->dataTypeInBytes.ptr).\n    * 4 - Data length mismatch => *procUnit2->bufferLength.ptr should be checked against *procUnit1->bufferLength.ptr.\n    * 6 - Data type and data length mismatch.\n    */\n\n    #if defined(CPU1_CPU2_IPC) || defined(CPU1_CM_IPC) || defined(CPU2_CM_IPC) || defined(CPU1_CLA_IPC) || defined(CPU2_CLA_IPC)\n    *status = 0;\n\n    volatile IPCChannelStruct_T *procUnit1; /* Reading core's info. */\n    volatile IPCChannelStruct_T *procUnit2; /* Writing core's info. */\n\n    if ((ipcHandle->H_IPCBetween == IPC_CPU1CPU2 && CurrentPU == IPC_c28xCPU1) ||\n        (ipcHandle->H_IPCBetween == IPC_CPU1CM && CurrentPU == IPC_c28xCPU1) ||\n        (ipcHandle->H_IPCBetween == IPC_CPU2CM && CurrentPU == IPC_c28xCPU2) ||\n        (ipcHandle->H_IPCBetween == IPC_CPU1CLA) ||\n        (ipcHandle->H_IPCBetween == IPC_CPU2CLA))\n    {\n        procUnit1 = &ipcHandle->H_PU1;\n        procUnit2 = &ipcHandle->H_PU2;\n    }\n    else\n    {\n        procUnit1 = &ipcHandle->H_PU2;\n        procUnit2 = &ipcHandle->H_PU1;\n    }\n\n    uint16_T tail;\n    uint16_T dataInBytes;\n    uint16_T dataInWords; /* 16-bits int size is 1 word. */\n\n    dataInBytes = *procUnit1->bufferLength.ptr * (*procUnit1->dataTypeInBytes.ptr);\n    dataInWords = dataInBytes / 2;\n\n    if ( ((*procUnit1->dataTypeInBytes.ptr) != (*procUnit2->dataTypeInBytes.ptr)) && (*procUnit2->bufferLength.ptr != *procUnit1->bufferLength.ptr))\n    {\n        *status = 6;\n    }\n    else if ((*procUnit1->dataTypeInBytes.ptr) != (*procUnit2->dataTypeInBytes.ptr))\n    {\n        *status = 2;\n    }\n    else if (*procUnit1->bufferLength.ptr != *procUnit2->bufferLength.ptr)\n    {\n        *status = 4;\n    }\n\n    while (*procUnit2->mutex.ptr)\n    {\n        continue;\n    }; /* Wait while writing CPU is updating its flags. */\n    *procUnit1->mutex.ptr = 1U; /* Lock the mutex. */\n\n    if ((*procUnit1->tail.ptr | 0xF0) != (*procUnit2->head.ptr & 0xFF))\n    {\n        if (*procUnit2->full.ptr)\n        {\n            *procUnit1->lastReadStatus.ptr = *procUnit1->lastReadStatus.ptr + 1;\n        }\n        /* Buffer is condidered to be empty if (writer head == reader tail) and (writer indicates that buffer is not full) => buffer is empty.\n        * This is negation of that condition i.e. there is data in the buffer.\n        */\n        if (!((*procUnit1->tail.ptr == *procUnit2->head.ptr) && (*procUnit2->full.ptr == 0)))\n        {\n            /* If writer CPU indicates an overwrite, update tail to read the earliest data in the buffer. */\n            if (*procUnit2->overwrite.ptr)\n            {\n                /* Writer overwrite flag may not have been updated. So reader also maintains an overwrite flag (*procUnit1->overwrite.ptr) that checks against this condition.\n                * Tail is not updated in case the writer overwrite flag is outdated.\n                * More on the logic:\n                *      *procUnit1->overwrite.ptr is 0 when the reader CPU is reading for the first time after overwrite flag is set in the writer CPU.\n                *      The second time this condition is encountered -\n                *          1) BEFORE the writer CPU runs again, *procUnit1->overwrite.ptr == *procUnit2->overwrite.ptr. Flag is outdated.\n                *          2) AFTER the writer CPU runs and sets its overwrite flag again, *procUnit1->overwrite.ptr != *procUnit2->overwrite.ptr. Flag NOT outdated.\n                */\n                if ((*procUnit1->overwrite.ptr == 0U) || ((*procUnit1->overwrite.ptr != 0U) && (*procUnit1->overwrite.ptr != *procUnit2->overwrite.ptr)))\n                {\n                    *procUnit1->tail.ptr = *procUnit2->tail.ptr;\n                }\n                *procUnit1->overwrite.ptr = *procUnit2->overwrite.ptr;\n            }\n            else\n            {\n                *procUnit1->overwrite.ptr = 0U;\n            }\n            tail = *procUnit1->tail.ptr;\n            *procUnit1->tail.ptr = *procUnit1->tail.ptr | 0xF0;\n            *procUnit1->mutex.ptr = 0U;\n\n            #if defined(CM)\n            /* For the CM view, data is stored in bytes and hence the size to be copied is dataInBytes.\n            * CM reads from the writer's buffer, and hence the address at bufferStartAdd + 1 of the writer is used.\n            */\n            memcpy(dataTobeRead, (*(procUnit2->bufferStartAdd.ptr + 1)).ptr + (tail * dataInWords), dataInBytes);\n            #else\n            /* For the C28x view, data is stored in words and hence the size to be copied is dataInWords. */\n            if (ipcHandle->H_IPCBetween == IPC_CPU1CM || ipcHandle->H_IPCBetween == IPC_CPU2CM)\n            {\n                /* C28x reads from the writer's buffer, and hence the address at bufferStartAdd + 1 of the writer is used, for CPU1_CM_IPC and CPU2_CM_IPC. */\n                memcpy_fast(dataTobeRead, (*(procUnit2->bufferStartAdd.ptr + 1)).ptr + (tail * dataInWords), dataInWords);\n            }\n            else\n            {\n                /* C28x reads from the writer's buffer, and hence the address at bufferStartAdd of the writer is used. */\n                memcpy_fast(dataTobeRead, (*(procUnit2->bufferStartAdd.ptr)).ptr + (tail * dataInWords), dataInWords);\n            }\n            #endif\n\n            *procUnit1->tail.ptr = ((tail + 1) >= procUnit1->numOfBuffers) ? 0 : (tail + 1);\n        }\n        else /* No data or buff empty. Then output the last read index (read old data again). */\n        {\n            *status = 1;\n            /* Remove data from last read index (old data). */\n            if (*procUnit1->tail.ptr) /* if tail is positive value*/\n            {\n                *procUnit1->tail.ptr = *procUnit1->tail.ptr - 1;\n            }\n            else /* If tail is zero, return to end of buffer index to read. */\n            {\n                *procUnit1->tail.ptr = procUnit2->numOfBuffers - 1;\n            }\n            tail = *procUnit1->tail.ptr;\n            *procUnit1->tail.ptr = *procUnit1->tail.ptr | 0xF0;\n            *procUnit1->mutex.ptr = 0;\n\n            #if defined(CM)\n            /* For the CM view, data is stored in bytes and hence the size to be copied is dataInBytes.\n            * CM reads from the writer's buffer, and hence the address at bufferStartAdd + 1 of the writer is used.\n            */\n            memcpy(dataTobeRead, (*(procUnit2->bufferStartAdd.ptr + 1)).ptr + (tail * dataInWords), dataInBytes);\n            #else\n            /* For the C28x view, data is stored in words and hence the size to be copied is dataInWords. */\n            if (ipcHandle->H_IPCBetween == IPC_CPU1CM || ipcHandle->H_IPCBetween == IPC_CPU2CM)\n            {\n                /* C28x reads from the writer's buffer, and hence the address at bufferStartAdd + 1 of the writer is used, for CPU1_CM_IPC and CPU2_CM_IPC. */\n                memcpy_fast(dataTobeRead, (*(procUnit2->bufferStartAdd.ptr + 1)).ptr + (tail * dataInWords), dataInWords);\n            }\n            else\n            {\n                /* C28x reads from the writer's buffer, and hence the address at bufferStartAdd of the writer is used. */\n                memcpy_fast(dataTobeRead, (*(procUnit2->bufferStartAdd.ptr)).ptr + (tail * dataInWords), dataInWords);\n            }\n            #endif\n\n            *procUnit1->tail.ptr = ((tail + 1) >= procUnit1->numOfBuffers) ? 0 : (tail + 1);\n        }\n    }\n    else /* If writing in progress, jump to next location and check if buffer is empty. */\n    {\n        /* If buffer is full, then read old data. */\n        if (*procUnit2->full.ptr && (*procUnit2->head.ptr == *procUnit1->tail.ptr))\n        {\n            tail = *procUnit1->tail.ptr;\n            *procUnit1->tail.ptr = (((tail + 1) >= procUnit1->numOfBuffers) ? 0 : (tail + 1)) | 0xF0;\n            *procUnit1->mutex.ptr = 0;\n\n            #if defined(CM)\n            /* For the CM view, data is stored in bytes and hence the size to be copied is dataInBytes.\n            * CM reads from the writer's buffer, and hence the address at bufferStartAdd + 1 is used.\n            */\n            memcpy(dataTobeRead, (*(procUnit2->bufferStartAdd.ptr + 1)).ptr + ((((tail + 1) >= procUnit2->numOfBuffers) ? 0 : (tail + 1)) * dataInWords), dataInBytes);\n            #else\n            /* For the C28x view, data is stored in words and hence the size to be copied is dataInWords. */\n            if (ipcHandle->H_IPCBetween == IPC_CPU1CM || ipcHandle->H_IPCBetween == IPC_CPU2CM)\n            {\n                /* C28x reads from the writer's buffer, and hence the address at bufferStartAdd + 1 of the writer is used, for CPU1_CM_IPC and CPU2_CM_IPC. */\n                memcpy_fast(dataTobeRead, (*(procUnit2->bufferStartAdd.ptr + 1)).ptr + ((((tail + 1) >= procUnit2->numOfBuffers) ? 0 : (tail + 1)) * dataInWords), dataInWords);\n            }\n            else\n            {\n                /* C28x reads from the writer's buffer, and hence the address at bufferStartAdd of the writer is used. */\n                memcpy_fast(dataTobeRead, (*(procUnit2->bufferStartAdd.ptr)).ptr + ((((tail + 1) >= procUnit2->numOfBuffers) ? 0 : (tail + 1)) * dataInWords), dataInWords);\n            }\n            #endif\n\n            *procUnit1->tail.ptr = ((tail + 2) >= procUnit1->numOfBuffers) ? 0 : (tail + 2);\n        }\n        else /* No data or buff empty. Then output the last read index. */\n        {\n            *status = 1;\n            /* Remove data from last read index (old data). */\n            if (*procUnit1->tail.ptr)\n            {\n                *procUnit1->tail.ptr = *procUnit1->tail.ptr - 1;\n            }\n            else\n            {\n                *procUnit1->tail.ptr = procUnit2->numOfBuffers - 1;\n            }\n            tail = *procUnit1->tail.ptr;\n            *procUnit1->tail.ptr = *procUnit1->tail.ptr | 0xF0;\n            *procUnit1->mutex.ptr = 0;\n\n            #if defined(CM)\n            /* For the CM view, data is stored in bytes and hence the size to be copied is dataInBytes.\n            * CM reads from the writer's buffer, and hence the address at bufferStartAdd + 1 is used.\n            */\n            memcpy(dataTobeRead, (*(procUnit2->bufferStartAdd.ptr + 1)).ptr + (tail * dataInWords), dataInBytes);\n            #else\n            /* For the C28x view, data is stored in words and hence the size to be copied is dataInWords. */\n            if (ipcHandle->H_IPCBetween == IPC_CPU1CM || ipcHandle->H_IPCBetween == IPC_CPU2CM)\n            {\n                /* C28x reads from the writer's buffer, and hence the address at bufferStartAdd + 1 of the writer is used, for CPU1_CM_IPC and CPU2_CM_IPC. */\n                memcpy_fast(dataTobeRead, (*(procUnit2->bufferStartAdd.ptr + 1)).ptr + (tail * dataInWords), dataInWords);\n            }\n            else\n            {\n                /* C28x reads from the writer's buffer, and hence the address at bufferStartAdd of the writer is used. */\n                memcpy_fast(dataTobeRead, (*(procUnit2->bufferStartAdd.ptr)).ptr + (tail * dataInWords), dataInWords);\n            }\n            #endif\n\n            *procUnit1->tail.ptr = ((tail + 1) >= procUnit1->numOfBuffers) ? 0 : (tail + 1);\n        }\n    }\n\n    /* Interrupts */\n    /* No need to handle interrupts if communicating with CLA. */\n    if (procUnit1->intEnable &&\n        !((ipcHandle->H_IPCBetween == IPC_CPU1CLA) || (ipcHandle->H_IPCBetween == IPC_CPU2CLA)))\n    {\n        #if defined(CPU1)\n        switch (procUnit1->chNum)\n        {\n            case 0:\n                #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if (ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                    {\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.bit.IPC0 = 1U;\n                    }\n                    #if defined(MW_F2838X)\n                    else if (ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                    {\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC0 = 1U;\n                    }\n                    #endif\n                #else\n                    IpcRegs.IPCACK.bit.IPC0 = 1U;\n                #endif\n                break;\n            case 1:\n                #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if (ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                    {\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.bit.IPC1 = 1U;\n                    }\n                    #if defined(MW_F2838X)\n                    else if (ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                    {\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC1 = 1U;\n                    }\n                    #endif\n                #else\n                    IpcRegs.IPCACK.bit.IPC1 = 1U;\n                #endif\n                break;\n            case 2:\n                #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if (ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                    {\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.bit.IPC2 = 1U;\n                    }\n                    #if defined(MW_F2838X)\n                    else if (ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                    {\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC2 = 1U;\n                    }\n                    #endif\n                #else\n                    IpcRegs.IPCACK.bit.IPC2 = 1U;\n                #endif\n                break;\n            case 3:\n                #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if (ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                    {\n                        Cpu1toCpu2IpcRegs.CPU1TOCPU2IPCACK.bit.IPC3 = 1U;\n                    }\n                    #if defined(MW_F2838X)\n                    else if (ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                    {\n                        Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC3 = 1U;\n                    }\n                    #endif\n                #else\n                    IpcRegs.IPCACK.bit.IPC3 = 1U;\n                #endif\n                break;\n            case 4:\n                #if defined(MW_F2838X)\n                if (ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                {\n                    Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC4 = 1U;\n                }\n                #endif\n                break;\n            case 5:\n                #if defined(MW_F2838X)\n                if (ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                {\n                    Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC5 = 1U;\n                }\n                #endif\n                break;\n            case 6:\n                #if defined(MW_F2838X)\n                if (ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                {\n                    Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC6 = 1U;\n                }\n                #endif\n                break;\n            case 7:\n                #if defined(MW_F2838X)\n                if (ipcHandle->H_IPCBetween == IPC_CPU1CM)\n                {\n                    Cpu1toCmIpcRegs.CPU1TOCMIPCACK.bit.IPC7 = 1U;\n                }\n                #endif\n                break;\n        }\n        #elif defined(CPU2)\n        switch (procUnit1->chNum)\n        {\n            case 0:\n                #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if (ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                    {\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.bit.IPC0 = 1U;\n                    }\n                    #if defined(MW_F2838X)\n                    else if (ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                    {\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC0 = 1U;\n                    }\n                    #endif\n                #else\n                    IpcRegs.IPCACK.bit.IPC0 = 1U;\n                #endif\n                break;\n            case 1:\n                #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if (ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                    {\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.bit.IPC1 = 1U;\n                    }\n                    #if defined(MW_F2838X)\n                    else if (ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                    {\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC1 = 1U;\n                    }\n                    #endif\n                #else\n                    IpcRegs.IPCACK.bit.IPC1 = 1U;\n                #endif\n                break;\n            case 2:\n                #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if (ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                    {\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.bit.IPC2 = 1U;\n                    }\n                    #if defined(MW_F2838X)\n                    else if (ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                    {\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC2 = 1U;\n                    }\n                    #endif\n                #else\n                    IpcRegs.IPCACK.bit.IPC2 = 1U;\n                #endif\n                break;\n            case 3:\n                #if defined(MW_F2838X) || defined(MW_F28P65X)\n                    if (ipcHandle->H_IPCBetween == IPC_CPU1CPU2)\n                    {\n                        Cpu2toCpu1IpcRegs.CPU2TOCPU1IPCACK.bit.IPC3 = 1U;\n                    }\n                    #if defined(MW_F2838X)\n                    else if (ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                    {\n                        Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC3 = 1U;\n                    }\n                    #endif\n                #else\n                    IpcRegs.IPCACK.bit.IPC3 = 1U;\n                #endif\n                break;\n            case 4:\n                #if defined(MW_F2838X)\n                if (ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                {\n                    Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC4 = 1U;\n                }\n                #endif\n                break;\n            case 5:\n                #if defined(MW_F2838X)\n                if (ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                {\n                    Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC5 = 1U;\n                }\n                #endif\n                break;\n            case 6:\n                #if defined(MW_F2838X)\n                if (ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                {\n                    Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC6 = 1U;\n                }\n                #endif\n                break;\n            case 7:\n                #if defined(MW_F2838X)\n                if (ipcHandle->H_IPCBetween == IPC_CPU2CM)\n                {\n                    Cpu2toCmIpcRegs.CPU2TOCMIPCACK.bit.IPC7 = 1U;\n                }\n                #endif\n                break;\n        }\n        #elif defined(CM)\n        uint32_T ipcflag = 0x00000001, ipcflag1;\n        ipcflag1 = ipcflag << procUnit1->chNum;\n        if (ipcHandle->H_IPCBetween == IPC_CPU1CM)\n        {\n            IPC_CMTOCPU1_FlagReg->IPC_ACK |= ipcflag1;\n        }\n        else if (ipcHandle->H_IPCBetween == IPC_CPU2CM)\n        {\n            IPC_CMTOCPU2_FlagReg->IPC_ACK |= ipcflag1;\n        }\n        #endif\n    }\n    #endif\n}\n\nvoid MW_IPC_Terminate(MW_IPC_Handle ipcHandle)\n{\n    /* Add later. */\n}\n#endif /* __TMS320C28XX_CLA__ */\n\n#ifdef __TMS320C28XX_CLA__\nvoid MW_IPC_Write_CLA(MW_IPC_Handle* ipcHandle, uint16_T CurrentPU, MW_Const_Void_Ptr_T dataToSend)\n{\n    volatile IPCChannelStruct_T *procUnit1 = &ipcHandle->H_PU2; /* Writing core's info - CLA. */\n    volatile IPCChannelStruct_T *procUnit2 = &ipcHandle->H_PU1; /* Reading core's info - C28x. */\n\n    uint16_T head = *procUnit1->head.ptr;\n    uint16_T tail;\n    uint16_T dataInBytes;\n    uint16_T dataInWords; /* 16-bits int size is 1 word. */\n\n    dataInBytes = *procUnit1->bufferLength.ptr * (*procUnit1->dataTypeInBytes.ptr);\n    dataInWords = dataInBytes / 2;\n\n    while (*procUnit2->mutex.ptr); /* Wait while reading CPU is updating its flags. */\n    *procUnit1->mutex.ptr = 1U; /* Lock the mutex. */\n\n    if ((head | 0xF0U) != (*procUnit2->tail.ptr & 0xFFU)) /* Tail of reading CPU is compared with head of writing CLA. */\n    {\n        *procUnit1->head.ptr = head | 0xF0U; /* Set writing in progress */\n        /* If buffer is full and the reading CPU has not yet read the data - overwrite the contents at this buffer location.\n        * The full flag is updated at the end of this funciton. So at this point, we are looking at the full flag from the previous run.\n        * In case the reader has read data, the full flag is no longer indicating the correct status. To take care of such a condition, the lastReadStatus is used.\n        * The reader lastReadStatus is updated when ever the reader reads data and the writer full flag is set.\n        */\n        if (*procUnit1->full.ptr && *procUnit1->lastReadStatus.ptr == *procUnit2->lastReadStatus.ptr)\n        {\n            /* Update tail value in writer CLA. This is the correct position to read from next. The reading CPU will update its tail to match with this. */\n            tail = ((uint16_T)(head + 1) >= (uint16_T)procUnit1->numOfBuffers) ? 0 : (uint16_T)(head + 1);\n            *procUnit1->tail.ptr = tail;\n            /* Increment overwrite.\n            * Writer overwrite flag is updated by counting up. The counter value is used by the reader CPU to decide whether the flag is outdated or not.\n            */\n            *procUnit1->overwrite.ptr = *procUnit2->overwrite.ptr + 1;\n        }\n        else\n        {\n            *procUnit1->lastReadStatus.ptr = *procUnit2->lastReadStatus.ptr;\n            *procUnit1->tail.ptr = *procUnit2->tail.ptr;\n            *procUnit1->overwrite.ptr = 0;\n            tail = *procUnit2->tail.ptr;\n        }\n        *procUnit1->mutex.ptr = 0; /* Unlock the mutex. */\n\n        /* For the CLA view, data is stored in words and hence the size to be copied is dataInWords.\n        * CLA writes to its own buffer, and hence the address at bufferStartAdd of the writer is used.\n        */\n        memcpy_cla((*(procUnit1->bufferStartAdd.ptr)).ptr + (head * dataInWords), dataToSend, dataInWords);\n\n        *procUnit1->head.ptr = ((uint16_T)(head + 1) >= (uint16_T)procUnit1->numOfBuffers) ? 0 : (head + 1);\n        *procUnit1->full.ptr = (*procUnit1->head.ptr == tail);\n    }\n    else /* If reading is in progress advance head. Head jumps the tail always. */\n    {\n        *procUnit1->head.ptr = ( ((uint16_T)(head + 1) >= (uint16_T)procUnit1->numOfBuffers) ? 0 : (head + 1) ) | 0xF0U;\n        *procUnit1->mutex.ptr = 0;\n\n        /* For the CLA view, data is stored in words and hence the size to be copied is dataInWords.\n        * CLA writes to its own buffer, and hence the address at bufferStartAdd of the writer is used.\n        */\n        memcpy_cla((*(procUnit1->bufferStartAdd.ptr)).ptr + (((uint16_T)(head + 1) >= (uint16_T)procUnit1->numOfBuffers) ? 0 : (head + 1)) * dataInWords, dataToSend, dataInWords);\n\n        *procUnit1->head.ptr = ((uint16_T)(head + 2) >= (uint16_T)procUnit1->numOfBuffers) ? 0 : (head + 2);\n        *procUnit1->full.ptr = (*procUnit1->head.ptr == tail);\n    }\n}\n\nvoid MW_IPC_Read_CLA(MW_IPC_Handle* ipcHandle, uint16_T CurrentPU, MW_Void_Ptr_T dataTobeRead, int8_T* status)\n{\n    *status = 0;\n\n    volatile IPCChannelStruct_T *procUnit1 = &ipcHandle->H_PU2; /* Reading core's info - CLA. */\n    volatile IPCChannelStruct_T *procUnit2 = &ipcHandle->H_PU1; /* Writing core's info - C28x. */\n\n    uint16_T tail;\n    uint16_T dataInBytes;\n    uint16_T dataInWords; /* 16-bits int size is 1 word. */\n\n    dataInBytes = *procUnit1->bufferLength.ptr * (*procUnit1->dataTypeInBytes.ptr);\n    dataInWords = dataInBytes / 2;\n\n    if (((*procUnit1->dataTypeInBytes.ptr) != (*procUnit2->dataTypeInBytes.ptr)) && (*procUnit2->bufferLength.ptr != *procUnit1->bufferLength.ptr))\n    {\n        *status = 6;\n    }\n    else if ((*procUnit1->dataTypeInBytes.ptr) != (*procUnit2->dataTypeInBytes.ptr))\n    {\n        *status = 2;\n    }\n    else if (*procUnit1->bufferLength.ptr != *procUnit2->bufferLength.ptr)\n    {\n        *status = 4;\n    }\n\n    while (*procUnit2->mutex.ptr); /* Wait while writing CPU is updating its flags. */\n    *procUnit1->mutex.ptr = 1; /* Lock the mutex. */\n\n    if ((*procUnit1->tail.ptr | 0xF0) != (*procUnit2->head.ptr & 0xFF))\n    {\n        if (*procUnit2->full.ptr)\n            *procUnit1->lastReadStatus.ptr = *procUnit1->lastReadStatus.ptr + 1;\n        /* Buffer is condidered to be empty if (writer head == reader tail) and (writer indicates that buffer is not full) => buffer is empty.\n        * This is negation of that condition i.e. there is data in the buffer.\n        */\n        if (!((*procUnit1->tail.ptr == *procUnit2->head.ptr) && (*procUnit2->full.ptr == 0)))\n        {\n            /* If writer CPU indicates an overwrite, update tail to read the earliest data in the buffer. */\n            if (*procUnit2->overwrite.ptr)\n            {\n                /* Writer overwrite flag may not have been updated. So reader also maintains an overwrite flag (*procUnit1->overwrite.ptr) that checks against this condition.\n                * Tail is not updated in case the writer overwrite flag is outdated.\n                * More on the logic:\n                *      *procUnit1->overwrite.ptr is 0 when the reader CLA is reading for the first time after overwrite flag is set in the writer CPU.\n                *      The second time this condition is encountered -\n                *          1) BEFORE the writer CPU runs again, *procUnit1->overwrite.ptr == *procUnit2->overwrite.ptr. Flag is outdated.\n                *          2) AFTER the writer CPU runs and sets its overwrite flag again, *procUnit1->overwrite.ptr != *procUnit2->overwrite.ptr. Flag NOT outdated.\n                */\n                if ((*procUnit1->overwrite.ptr == 0) || ((*procUnit1->overwrite.ptr != 0) && (*procUnit1->overwrite.ptr != *procUnit2->overwrite.ptr)))\n                {\n                    *procUnit1->tail.ptr = *procUnit2->tail.ptr;\n                }\n                *procUnit1->overwrite.ptr = *procUnit2->overwrite.ptr;\n            }\n            else\n            {\n                *procUnit1->overwrite.ptr = 0;\n            }\n            tail = *procUnit1->tail.ptr;\n            *procUnit1->tail.ptr = *procUnit1->tail.ptr | 0xF0;\n            *procUnit1->mutex.ptr = 0;\n\n            /* For the CLA view, data is stored in words and hence the size to be copied is dataInWords.\n            * CLA reads from the writer's buffer, and hence the address at bufferStartAdd of the writer is used.\n            */\n            memcpy_cla(dataTobeRead, (*(procUnit2->bufferStartAdd.ptr)).ptr + (tail * dataInWords), dataInWords);\n\n            *procUnit1->tail.ptr = ((uint16_T)(tail + 1) >= (uint16_T)procUnit1->numOfBuffers) ? 0 : (tail + 1);\n        }\n        else /* No data or buff empty. Then output the last read index (read old data again). */\n        {\n            *status = 1;\n            /* Remove data from last read index (old data). */\n            if (*procUnit1->tail.ptr) /* If tail is positive value. */\n            {\n                *procUnit1->tail.ptr = *procUnit1->tail.ptr - 1;\n            }\n            else /* If tail is zero, return to end of buffer index to read. */\n            {\n                *procUnit1->tail.ptr = procUnit2->numOfBuffers - 1;\n            }\n            tail = *procUnit1->tail.ptr;\n            *procUnit1->tail.ptr = *procUnit1->tail.ptr | 0xF0;\n            *procUnit1->mutex.ptr = 0;\n\n            /* For the CLA view, data is stored in words and hence the size to be copied is dataInWords.\n            * CLA reads from the writer's buffer, and hence the address at bufferStartAdd of the writer is used.\n            */\n            memcpy_cla(dataTobeRead, (*(procUnit2->bufferStartAdd.ptr)).ptr + (tail * dataInWords), dataInWords);\n\n            *procUnit1->tail.ptr = ((uint16_T)(tail + 1) >= (uint16_T)procUnit1->numOfBuffers) ? 0 : (tail + 1);\n        }\n    }\n    else /* If writing in progress, jump to next location and check if buffer is empty. */\n    {\n        /* If buffer is full, then read old data. */\n        if (*procUnit2->full.ptr && (*procUnit2->head.ptr == *procUnit1->tail.ptr))\n        {\n            tail = *procUnit1->tail.ptr;\n            *procUnit1->tail.ptr = (((uint16_T)(tail + 1) >= (uint16_T)procUnit1->numOfBuffers) ? 0 : (tail + 1)) | 0xF0;\n            *procUnit1->mutex.ptr = 0;\n\n            /* For the CLA view, data is stored in words and hence the size to be copied is dataInWords.\n            * CLA reads from the writer's buffer, and hence the address at bufferStartAdd of the writer is used.\n            */\n            memcpy_cla(dataTobeRead, (*(procUnit2->bufferStartAdd.ptr)).ptr + ((((uint16_T)(tail + 1) >= (uint16_T)procUnit2->numOfBuffers) ? 0 : (tail + 1)) * dataInWords), dataInWords);\n\n            *procUnit1->tail.ptr = ((uint16_T)(tail + 2) >= (uint16_T)procUnit1->numOfBuffers) ? 0 : (tail + 2);\n        }\n        else /* No data or buff empty. Then output the last read index.*/\n        {\n            *status = 1;\n            /* Remove data from last read index (old data). */\n            if (*procUnit1->tail.ptr)\n            {\n                *procUnit1->tail.ptr = *procUnit1->tail.ptr - 1;\n            }\n            else\n            {\n                *procUnit1->tail.ptr = procUnit2->numOfBuffers - 1;\n            }\n            tail = *procUnit1->tail.ptr;\n            *procUnit1->tail.ptr = *procUnit1->tail.ptr | 0xF0;\n            *procUnit1->mutex.ptr = 0;\n\n            /* For the CLA view, data is stored in words and hence the size to be copied is dataInWords.\n            * CLA reads from the writer's buffer, and hence the address at bufferStartAdd of the writer is used.\n            */\n            memcpy_cla(dataTobeRead, (*(procUnit2->bufferStartAdd.ptr)).ptr + (tail * dataInWords), dataInWords);\n\n            *procUnit1->tail.ptr = ((uint16_T)(tail + 1) >= (uint16_T)procUnit1->numOfBuffers) ? 0 : (tail + 1);\n        }\n    }\n}\n\nvoid memcpy_cla(MW_Void_Ptr_T dst, MW_Const_Void_Ptr_T src, uint16_T N)\n{\n    const char_T *csrc = (const char_T *)src;\n    char_T *cdst = (char_T *)dst;\n    uint16_T i = 0;\n    for (; i < N; ++i)\n    {\n        cdst[i] = csrc[i];\n    }\n}\n#endif /* __TMS320C28XX_CLA__ */\n\n#endif /* IPC_BLOCK_INCLUDED */\n"},{"name":"sysctl.c","type":"source","group":"legacy","path":"C:\\Users\\awear\\my_projects\\pmsm\\deployment\\pi_foc_qep\\mcb_pmsm_foc_qep_f28379d_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_5_02_00_00\\driverlib\\f2837xd\\driverlib","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   sysctl.c\n//\n// TITLE:  C28x system control driver.\n//\n//###########################################################################\n// $Copyright:\n// Copyright (C) 2022 Texas Instruments Incorporated - http://www.ti.com\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n#include \"cputimer.h\"\n#include \"sysctl.h\"\n\n//\n// Define to isolate inline assembly\n//\n#define SYSCTL_DELAY        __asm(\" .if __TI_EABI__\\n\"                         \\\n                                  \" .asg    SysCtl_delay    , _SysCtl_delay\\n\" \\\n                                  \" .endif\\n\"                                  \\\n                                  \" .def _SysCtl_delay\\n\"                      \\\n                                  \" .sect \\\".TI.ramfunc\\\"\\n\"                   \\\n                                  \" .global  _SysCtl_delay\\n\"                  \\\n                                  \"_SysCtl_delay:\\n\"                           \\\n                                  \" SUB    ACC,#1\\n\"                           \\\n                                  \" BF     _SysCtl_delay, GEQ\\n\"               \\\n                                  \" LRETR\\n\")\n#define SYSCTL_CLRC_DBGM    __asm(\" CLRC DBGM\")\n\n//\n// Define Timer1 and Timer2 seed values\n//\n#define TMR1SYSCLKCTR       0xF0000000U\n#define TMR2INPCLKCTR       0x800U\n\n#define XTAL_CPUTIMER_PERIOD 1023U\n\n//*****************************************************************************\n//\n// SysCtl_delay()\n//\n//*****************************************************************************\nSYSCTL_DELAY;\n\n\nstatic void\nSysCtl_pollCpuTimer(void)\n{\n    //\n    // Delay for 1 ms while the XTAL powers up\n    //\n    // 2000 loops, 5 cycles per loop + 9 cycles overhead = 10009 cycles\n    //\n    SysCtl_delay(2000);\n\n    //\n    // Wait for cpu timer 2 to overflow\n    //\n    while(CPUTimer_getTimerOverflowStatus(CPUTIMER2_BASE) == false);\n    {\n        //\n        // If your application is stuck in this loop, please check if the\n        // input clock source is valid.\n        //\n    }\n\n    //\n    // Clear cpu timer 2 overflow flag\n    //\n    CPUTimer_clearOverflowFlag(CPUTIMER2_BASE);\n}\n\n//*****************************************************************************\n//\n// SysCtl_getClock()\n//\n//*****************************************************************************\nuint32_t\nSysCtl_getClock(uint32_t clockInHz)\n{\n    uint32_t temp;\n    uint32_t oscSource;\n    uint32_t clockOut;\n\n    //\n    // Don't proceed if an MCD failure is detected.\n    //\n    if(SysCtl_isMCDClockFailureDetected())\n    {\n        //\n        // OSCCLKSRC2 failure detected. Returning the INTOSC1 rate. You need\n        // to handle the MCD and clear the failure.\n        //\n        clockOut = SYSCTL_DEFAULT_OSC_FREQ;\n    }\n    else\n    {\n        //\n        // If one of the internal oscillators is being used, start from the\n        // known default frequency.  Otherwise, use clockInHz parameter.\n        //\n        oscSource = HWREG(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &\n                    (uint32_t)SYSCTL_CLKSRCCTL1_OSCCLKSRCSEL_M;\n\n        if((oscSource == (SYSCTL_OSCSRC_OSC2 >> SYSCTL_OSCSRC_S)) ||\n           (oscSource == (SYSCTL_OSCSRC_OSC1 >> SYSCTL_OSCSRC_S)))\n        {\n            clockOut = SYSCTL_DEFAULT_OSC_FREQ;\n        }\n        else\n        {\n            clockOut = clockInHz;\n        }\n\n        //\n        // If the PLL is enabled calculate its effect on the clock\n        //\n        if((HWREG(CLKCFG_BASE + SYSCTL_O_SYSPLLCTL1) &\n            (SYSCTL_SYSPLLCTL1_PLLEN | SYSCTL_SYSPLLCTL1_PLLCLKEN)) == 3U)\n        {\n            //\n            // Calculate portion from fractional multiplier\n            //\n            temp = (clockInHz * ((HWREG(CLKCFG_BASE + SYSCTL_O_SYSPLLMULT) &\n                                  SYSCTL_SYSPLLMULT_FMULT_M) >>\n                                 SYSCTL_SYSPLLMULT_FMULT_S)) / 4U;\n\n            //\n            // Calculate integer multiplier and fixed divide by 2\n            //\n            clockOut = clockOut * ((HWREG(CLKCFG_BASE + SYSCTL_O_SYSPLLMULT) &\n                                    SYSCTL_SYSPLLMULT_IMULT_M) >>\n                                   SYSCTL_SYSPLLMULT_IMULT_S);\n\n            //\n            // Add in fractional portion\n            //\n            clockOut += temp;\n        }\n\n        if((HWREG(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) &\n            SYSCTL_SYSCLKDIVSEL_PLLSYSCLKDIV_M) != 0U)\n        {\n            clockOut /= (2U * (HWREG(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) &\n                               SYSCTL_SYSCLKDIVSEL_PLLSYSCLKDIV_M));\n        }\n    }\n\n    return(clockOut);\n}\n\n//*****************************************************************************\n//\n// SysCtl_getAuxClock()\n//\n//*****************************************************************************\nuint32_t SysCtl_getAuxClock(uint32_t clockInHz)\n{\n    uint32_t temp;\n    uint32_t oscSource;\n    uint32_t clockOut;\n\n    oscSource = HWREG(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL2) &\n                (uint32_t)SYSCTL_CLKSRCCTL2_AUXOSCCLKSRCSEL_M;\n\n    //\n    // If one of the internal oscillators is being used, start from the\n    // known default frequency.  Otherwise, use clockInHz parameter.\n    //\n    if(oscSource == (SYSCTL_AUXPLL_OSCSRC_OSC2 >> SYSCTL_OSCSRC_S))\n    {\n        //\n        // 10MHz Internal Clock\n        //\n        clockOut = SYSCTL_DEFAULT_OSC_FREQ;\n    }\n    else\n    {\n        clockOut = clockInHz;\n    }\n\n    //\n    // If the PLL is enabled calculate its effect on the clock\n    //\n    if((HWREG(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) &\n        (SYSCTL_AUXPLLCTL1_PLLEN | SYSCTL_AUXPLLCTL1_PLLCLKEN)) == 3U)\n    {\n        //\n        // Calculate portion from fractional multiplier\n        //\n        temp = (clockInHz * ((HWREG(CLKCFG_BASE + SYSCTL_O_AUXPLLMULT) &\n                              SYSCTL_AUXPLLMULT_FMULT_M) >>\n                             SYSCTL_AUXPLLMULT_FMULT_S)) / 4U;\n\n        //\n        // Calculate integer multiplier\n        //\n        clockOut = clockOut * ((HWREG(CLKCFG_BASE + SYSCTL_O_AUXPLLMULT) &\n                                SYSCTL_AUXPLLMULT_IMULT_M) >>\n                               SYSCTL_AUXPLLMULT_IMULT_S);\n\n        //\n        // Add in fractional portion\n        //\n        clockOut += temp;\n    }\n\n    clockOut /= (1U << (HWREG(CLKCFG_BASE + SYSCTL_O_AUXCLKDIVSEL) &\n                        SYSCTL_AUXCLKDIVSEL_AUXPLLDIV_M));\n\n    return(clockOut);\n}\n\n//*****************************************************************************\n//\n// SysCtl_setClock()\n//\n//*****************************************************************************\nbool\nSysCtl_setClock(uint32_t config)\n{\n    uint16_t divSel;\n    uint16_t iMult = 0U, fMult = 0U, pllMult = 0U, div;\n    bool status, sysclkInvalidFreq = true;\n    uint16_t i, tempSCSR, tempWDCR, tempWDWCR, intStatus;\n    uint16_t t1TCR, t1TPR, t1TPRH, t2TCR, t2TPR, t2TPRH, t2CLKCTL;\n    uint32_t t1PRD, t2PRD, ctr1;\n    float32_t sysclkToInClkError, mult;\n\n    //\n    // Check the arguments.\n    //\n    ASSERT((config & SYSCTL_OSCSRC_M) != SYSCTL_OSCSRC_M); // 3 is not valid\n\n    //\n    // Don't proceed to the PLL initialization if an MCD failure is detected.\n    //\n    if(SysCtl_isMCDClockFailureDetected())\n    {\n        //\n        // OSCCLKSRC2 failure detected. Returning false. You'll need to clear\n        // the MCD error.\n        //\n        status = false;\n    }\n    else\n    {\n        //\n        // Configure oscillator source\n        //\n        SysCtl_selectOscSource(config & SYSCTL_OSCSRC_M);\n\n        //\n        // Bypass PLL\n        //\n        EALLOW;\n        HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLCTL1) &=\n            ~SYSCTL_SYSPLLCTL1_PLLCLKEN;\n        EDIS;\n\n        //\n        // Delay of at least 120 OSCCLK cycles required post PLL bypass\n        //\n        SysCtl_delay(23U);\n\n        //\n        // Configure PLL if enabled\n        //\n        EALLOW;\n        if((config & SYSCTL_PLL_ENABLE) == SYSCTL_PLL_ENABLE)\n        {\n            if((HWREGH(DEVCFG_BASE + SYSCTL_O_SYSDBGCTL) &\n                SYSCTL_SYSDBGCTL_BIT_0) != 0U)\n            {\n                //\n                // The user can optionally insert handler code here. This will\n                // only be executed if a watchdog reset occurred after a failed\n                // system PLL initialization. See your device user's guide for\n                // more information.\n                //\n                // If the application has a watchdog reset handler, this bit\n                // should be checked to determine if the watchdog reset\n                // occurred because of the PLL.\n                //\n                // No action here will continue with retrying the PLL as\n                // normal.\n                //\n            }\n\n            //\n            // Set dividers to /1\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) = 0U;\n\n            //\n            // Get the PLL multiplier settings from config\n            //\n            iMult |= (uint16_t)(config & SYSCTL_IMULT_M);\n            fMult |= (uint16_t)((config & SYSCTL_FMULT_M) >> SYSCTL_FMULT_S);\n            pllMult |= (iMult << SYSCTL_SYSPLLMULT_IMULT_S) |\n                       (fMult << SYSCTL_SYSPLLMULT_FMULT_S);\n\n            //\n            // Lock the PLL five times. This helps ensure a successful start.\n            // Five is the minimum recommended number. The user can increase\n            // this number according to allotted system initialization time.\n            //\n            for(i = 0U; i < 5U; i++)\n            {\n                //\n                // Turn off PLL\n                //\n                HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLCTL1) &=\n                    ~SYSCTL_SYSPLLCTL1_PLLEN;\n\n                asm(\" RPT #60 || NOP\");\n\n                //\n                // Write multiplier, which automatically turns on the PLL\n                //\n                HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLMULT) = pllMult;\n\n                //\n                // Wait for the SYSPLL lock counter\n                //\n                while((HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLSTS) &\n                       SYSCTL_SYSPLLSTS_LOCKS) == 0U)\n                {\n                    //\n                    // Consider to servicing the watchdog using\n                    // SysCtl_serviceWatchdog()\n                    //\n                }\n            }\n        }\n\n        //\n        // Configure Dividers. Set divider to produce slower output frequency\n        // to limit current increase.\n        //\n        divSel = (uint16_t)(config & SYSCTL_SYSDIV_M) >> SYSCTL_SYSDIV_S;\n\n        if(divSel != (126U / 2U))\n        {\n            HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) =\n                (HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) &\n                ~(uint16_t)SYSCTL_SYSCLKDIVSEL_PLLSYSCLKDIV_M) | (divSel + 1U);\n        }\n        else\n        {\n            HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) =\n                (HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) &\n                 ~(uint16_t)SYSCTL_SYSCLKDIVSEL_PLLSYSCLKDIV_M) | divSel;\n        }\n\n        //\n        //      *CAUTION*\n        // It is recommended to use the following watchdog code to monitor the\n        // PLLstartup sequence. If your application has already cleared the\n        // watchdog SCRS[WDOVERRIDE] bit this cannot be done. It is recommended\n        // not to clear this bit until after the PLL has been initiated.\n        //\n\n        //\n        // Backup User Watchdog\n        //\n        tempSCSR = HWREGH(WD_BASE + SYSCTL_O_SCSR);\n        tempWDCR = HWREGH(WD_BASE + SYSCTL_O_WDCR);\n        tempWDWCR = HWREGH(WD_BASE + SYSCTL_O_WDWCR);\n\n        //\n        // Disable windowed functionality, reset counter\n        //\n        HWREGH(WD_BASE + SYSCTL_O_WDWCR) = 0x0U;\n        SysCtl_serviceWatchdog();\n\n        //\n        // Disable global interrupts\n        //\n        intStatus = __disable_interrupts();\n\n        //\n        // Configure for watchdog reset and to run at max frequency\n        //\n        EALLOW;\n        HWREGH(WD_BASE + SYSCTL_O_SCSR) = 0x0U;\n        HWREGH(WD_BASE + SYSCTL_O_WDCR) = SYSCTL_WD_CHKBITS;\n\n        //\n        // This bit is reset only by power-on-reset (POR) and will not be\n        // cleared by a WD reset\n        //\n        HWREGH(DEVCFG_BASE + SYSCTL_O_SYSDBGCTL) |= SYSCTL_SYSDBGCTL_BIT_0;\n\n        //\n        // Enable PLLSYSCLK is fed from system PLL clock\n        //\n        HWREGH(CLKCFG_BASE +\n               SYSCTL_O_SYSPLLCTL1) |= SYSCTL_SYSPLLCTL1_PLLCLKEN;\n\n        EDIS;\n\n        //\n        // Delay to ensure system is clocking from PLL prior to clearing\n        // status bit\n        //\n        SysCtl_delay(3U);\n\n        //\n        // Slip Bit Monitor and SYSCLK Frequency Check using timers\n        // Re-lock routine for SLIP condition or if SYSCLK and CLKSRC timer\n        // counts are off by +/- 10%. At a minimum, SYSCLK check is performed.\n        // Re-lock attempt is carried out if SLIPS bit is set.\n        // This while loop is monitored by watchdog.\n        // In the event that the PLL does not successfully lock, the loop will\n        // be aborted by watchdog reset.\n        //\n        while(((config & SYSCTL_PLL_ENABLE) == SYSCTL_PLL_ENABLE) &&\n              (sysclkInvalidFreq == true))\n        {\n            EALLOW;\n\n            //\n            // Perform PLL re-lock only if SLIPS bit is set, otherwise monitor\n            // SYSCLK frequency with timers\n            //\n            if((HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLSTS) &\n                SYSCTL_SYSPLLSTS_SLIPS) == 1U)\n            {\n                //\n                // Bypass PLL\n                //\n                HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLCTL1) &=\n                    ~SYSCTL_SYSPLLCTL1_PLLCLKEN;\n\n                //\n                // Delay of at least 120 OSCCLK cycles required post PLL bypass\n                //\n                SysCtl_delay(23U);\n\n                //\n                // Turn off PLL\n                //\n                HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLCTL1) &=\n                    ~SYSCTL_SYSPLLCTL1_PLLEN;\n\n                SysCtl_delay(12U);\n\n                //\n                // Write multiplier, which automatically turns on the PLL\n                //\n                HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLMULT) |= pllMult;\n\n                //\n                // Wait for the SYSPLL lock counter\n                //\n                while((HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLSTS) &\n                        SYSCTL_SYSPLLSTS_LOCKS) == 0U)\n                {\n                    ;\n                }\n\n                //\n                // Enable PLLSYSCLK is fed from system PLL clock\n                //\n                HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLCTL1) |=\n                    SYSCTL_SYSPLLCTL1_PLLCLKEN;\n\n                //\n                // Delay to ensure system is clocking from PLL prior to\n                // clearing status bit\n                //\n                SysCtl_delay(12U);\n            }\n\n            //\n            // Backup timer1 and timer2 settings\n            //\n            t1TCR = HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR);\n            t1PRD = HWREG(CPUTIMER1_BASE + CPUTIMER_O_PRD);\n            t1TPR = HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TPR);\n            t1TPRH = HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TPRH);\n            t2CLKCTL = HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL);\n            t2TCR = HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR);\n            t2PRD = HWREG(CPUTIMER2_BASE + CPUTIMER_O_PRD);\n            t2TPR = HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPR);\n            t2TPRH = HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPRH);\n\n            //\n            // Set up timers 1 and 2\n            // Configure timer1 to count SYSCLK cycles\n            //\n\n            //\n            // Stop timer 1\n            // Seed timer1 counter\n            // Set sysclock divider\n            // Reload timer with value in PRD\n            // Clear interrupt flag\n            // Enable interrupt\n            //\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TSS;\n            HWREG(CPUTIMER1_BASE + CPUTIMER_O_PRD) = (uint32_t)TMR1SYSCLKCTR;\n            HWREG(CPUTIMER1_BASE + CPUTIMER_O_TPR) = 0U;\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TRB;\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TIF;\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TIE;\n\n            //\n            // Configure timer2 to count Input clock cycles\n            //\n            switch (config & SYSCTL_OSCSRC_M)\n            {\n                case SYSCTL_OSCSRC_OSC1:\n                    //\n                    // Clk Src = INT_OSC1\n                    //\n                    HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL) =\n                            (HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL) &\n                             ~SYSCTL_TMR2CLKCTL_TMR2CLKSRCSEL_M) | 1U;\n                    break;\n\n                case SYSCTL_OSCSRC_OSC2:\n                    //\n                    // Clk Src = INT_OSC2\n                    //\n                    HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL) =\n                            (HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL) &\n                             ~SYSCTL_TMR2CLKCTL_TMR2CLKSRCSEL_M) | 2U;\n                    break;\n\n                case SYSCTL_OSCSRC_XTAL:\n                    //\n                    // Clk Src = XTAL\n                    //\n                    HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL) =\n                            (HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL) &\n                             ~SYSCTL_TMR2CLKCTL_TMR2CLKSRCSEL_M) | 3U;\n                    break;\n\n                default:\n                    //\n                    // Do nothing. Not a valid clock source value.\n                    //\n                    break;\n            }\n\n            //\n            // Clear interrupt flag\n            // Enable interrupt\n            // Stop timer 2\n            // Seed timer2 counter\n            // Set sysclock divider\n            // Reload timer with value in PRD\n            //\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TIF;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TIE;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TSS;\n            HWREG(CPUTIMER2_BASE + CPUTIMER_O_PRD) = (uint32_t)TMR2INPCLKCTR;\n            HWREG(CPUTIMER2_BASE + CPUTIMER_O_TPR) = 0U;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TRB;\n\n            //\n            // Stop/Start timer counters\n            //\n\n            //\n            // Stop timer 1\n            // Stop timer 2\n            // Reload timer1 with value in PRD\n            // Reload timer2 with value in PRD\n            // Clear timer2 interrupt flag\n            // Start timer2\n            // Start timer1\n            //\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TSS;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TSS;\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TRB;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TRB;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TIF;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) &= ~CPUTIMER_TCR_TSS;\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR) &= ~CPUTIMER_TCR_TSS;\n\n            //\n            // Wait for Timers - Stop if either timer overflows\n            //\n            while(((HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) &\n                   CPUTIMER_TCR_TIF) == 0U)  &&\n                  ((HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR) &\n                   CPUTIMER_TCR_TIF) == 0U))\n            {\n                ;\n            }\n\n            //\n            // Stop timer 1 and 2\n            //\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TSS;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TSS;\n\n            //\n            // Calculate elapsed counts on timer1\n            //\n            ctr1 = (uint32_t)TMR1SYSCLKCTR - HWREG(CPUTIMER1_BASE +\n                                                   CPUTIMER_O_TIM);\n\n            //\n            // Restore timer settings\n            //\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TCR) = t1TCR;\n            HWREG(CPUTIMER1_BASE + CPUTIMER_O_PRD) = t1PRD;\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TPR) = t1TPR;\n            HWREGH(CPUTIMER1_BASE + CPUTIMER_O_TPRH) = t1TPRH;\n            HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL) = t2CLKCTL;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) = t2TCR;\n            HWREG(CPUTIMER2_BASE + CPUTIMER_O_PRD) = t2PRD;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPR) = t2TPR;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPRH) = t2TPRH;\n\n            //\n            // Calculate Clock Error:\n            // Error = (mult/div) - (timer1 count/timer2 count)\n            //\n            mult = (float32_t)iMult + ((float32_t)fMult / 4.0F);\n\n            if((HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) & 0x3FU) == 0U)\n            {\n                div = 1U;\n            }\n            else\n            {\n                div = (HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) &\n                       0x3FU) << 1;\n            }\n\n            sysclkToInClkError = (mult / (float32_t)div) -\n                                 ((float32_t)ctr1 / (float32_t)TMR2INPCLKCTR);\n\n            //\n            // sysclkInvalidFreq will be set to true if sysclkToInClkError is\n            // off by 10%\n            //\n            sysclkInvalidFreq = ((sysclkToInClkError > 0.10F) ||\n                                 (sysclkToInClkError < -0.10F));\n\n            EDIS;\n        }\n\n        //\n        // Clear bit\n        //\n        EALLOW;\n        HWREGH(DEVCFG_BASE + SYSCTL_O_SYSDBGCTL) &= ~SYSCTL_SYSDBGCTL_BIT_0;\n        EDIS;\n\n        //\n        // Restore user watchdog, first resetting counter\n        //\n        SysCtl_serviceWatchdog();\n\n        //\n        // Set the KEY bits and make sure not to set the WDOVERRIDE bit\n        //\n        EALLOW;\n        HWREGH(WD_BASE + SYSCTL_O_WDCR) = tempWDCR | SYSCTL_WD_CHKBITS;\n        HWREGH(WD_BASE + SYSCTL_O_WDWCR) = tempWDWCR;\n        HWREGH(WD_BASE + SYSCTL_O_SCSR) = tempSCSR & ~SYSCTL_SCSR_WDOVERRIDE;\n        EDIS;\n\n        //\n        // Restore state of ST1[INTM]. This was set by the\n        // __disable_interrupts() intrinsic previously.\n        //\n        if((intStatus & 0x1U) == 0U)\n        {\n            EINT;\n        }\n\n        //\n        // Restore state of ST1[DBGM]. This was set by the\n        // __disable_interrupts() intrinsic previously.\n        //\n        if((intStatus & 0x2U) == 0U)\n        {\n            SYSCTL_CLRC_DBGM;\n        }\n\n        //\n        // ~200 PLLSYSCLK delay to allow voltage regulator to stabilize prior\n        // to increasing entire system clock frequency.\n        //\n        SysCtl_delay(40U);\n\n        //\n        // Set the divider to user value\n        //\n        EALLOW;\n        HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) =\n            (HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) &\n             ~SYSCTL_SYSCLKDIVSEL_PLLSYSCLKDIV_M) | divSel;\n        SYSCTL_REGWRITE_DELAY;\n        EDIS;\n\n        status = true;\n    }\n\n    return(status);\n}\n//*****************************************************************************\n//\n// SysCtl_setAuxClock()\n//\n//*****************************************************************************\nvoid SysCtl_setAuxClock(uint32_t config)\n{\n    uint16_t pllMult = 0U;\n    uint16_t counter = 0U, started = 0U, attempts = 0U;\n    uint16_t mult;\n    uint16_t i, t2TCR, t2TPR, t2TPRH, t2CLKCTL;\n    uint32_t t2PRD;\n\n    //\n    // Check the arguments\n    //\n    ASSERT((config & SYSCTL_OSCSRC_M) != SYSCTL_OSCSRC_M); // 3 is not valid\n\n    //\n    // Bypass PLL\n    //\n    EALLOW;\n    HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) &= ~SYSCTL_AUXPLLCTL1_PLLCLKEN;\n    EDIS;\n\n    //\n    // Delay of at least 120 OSCCLK cycles required post PLL bypass\n    //\n    SysCtl_delay(23U);\n\n    //\n    // Configure oscillator source\n    //\n    SysCtl_selectOscSourceAuxPLL(config & SYSCTL_OSCSRC_M);\n\n    //\n    // Get the PLL multiplier settings from config\n    //\n    pllMult |= (uint16_t)((config & SYSCTL_IMULT_M) <<\n                          SYSCTL_AUXPLLMULT_IMULT_S);\n    pllMult |= (uint16_t)(((config & SYSCTL_FMULT_M) >> SYSCTL_FMULT_S) <<\n                          SYSCTL_AUXPLLMULT_FMULT_S);\n\n    //\n    // Get the PLL multipliers currently programmed\n    //\n    mult  = (uint16_t)((HWREG(CLKCFG_BASE + SYSCTL_O_AUXPLLMULT) &\n                        (uint32_t)SYSCTL_AUXPLLMULT_IMULT_M) >>\n                       (uint32_t)SYSCTL_AUXPLLMULT_IMULT_S);\n    mult |= (uint16_t)(HWREG(CLKCFG_BASE + SYSCTL_O_AUXPLLMULT) &\n                             SYSCTL_AUXPLLMULT_FMULT_M);\n\n    //\n    // Lock PLL only if the multipliers need update\n    //\n    if(mult !=  pllMult)\n    {\n\n        //\n        // Configure PLL if enabled\n        //\n        if((config & SYSCTL_AUXPLL_ENABLE) == SYSCTL_AUXPLL_ENABLE)\n        {\n            //\n            // Backup Timer 2 settings\n            //\n            t2CLKCTL = HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL);\n            t2TCR = HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR);\n            t2PRD = HWREG(CPUTIMER2_BASE + CPUTIMER_O_PRD);\n            t2TPR = HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPR);\n            t2TPRH = HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPRH);\n\n            //\n            // Configure Timer 2 for AUXPLL as source in known configuration\n            // - Clock source to AUXPLL\n            // - Clock divider to divide by 1\n            // - Small period to detect overflow\n            // - Interrupt disabled\n            //\n            EALLOW;\n            HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL) = 6U;\n\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TSS;\n\n            HWREG(CPUTIMER2_BASE + CPUTIMER_O_PRD) = 10U;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPR) = 0U;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPRH) = 0U;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) &= ~CPUTIMER_TCR_TIE;\n\n            //\n            // Set AUX Divide by 8 to ensure that AUXPLLCLK <= SYSCLK / 2\n            // while using Timer 2\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_AUXCLKDIVSEL) = 0x3U;\n            SYSCTL_REGWRITE_DELAY;\n            EDIS;\n\n            //\n            // Lock the PLL up to five times.\n            //CPU Timer 2 will monitor a successful\n            // lock and break out of the loop earlier if detected.\n            //\n            while((counter < 5U) && (started == 0U))\n            {\n                EALLOW;\n\n                //\n                // Turn off AUXPLL and delay for it to power down.\n                //\n                HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) &=\n                    ~SYSCTL_AUXPLLCTL1_PLLEN;\n                SysCtl_delay(3U);\n\n                //\n                // Set integer and fractional multiplier, which automatically\n                // turns on the PLL\n                //\n                HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLMULT) |= pllMult;\n                SYSCTL_REGWRITE_DELAY;\n\n                //\n                // Enable AUXPLL\n                //\n                HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) |=\n                    SYSCTL_AUXPLLCTL1_PLLEN;\n                EDIS;\n\n                //\n                // Wait for the AUXPLL lock counter\n                //\n\n                while((HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLSTS) &\n                       SYSCTL_AUXPLLSTS_LOCKS) != 1U)\n                {\n                    //\n                    // Consider to servicing the watchdog using\n                    // SysCtl_serviceWatchdog()\n                    //\n                }\n\n\n                //\n                // Enable AUXPLLCLK to be fed from AUXPLL\n                //\n                EALLOW;\n                HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) |=\n                    SYSCTL_AUXPLLCTL1_PLLCLKEN;\n                SysCtl_delay(3U);\n\n                //\n                // CPU Timer 2 will now be setup to be clocked from AUXPLLCLK.\n                // This is used to test that the PLL has successfully started.\n                //\n                // Reload and start the timer\n                //\n                HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TRB;\n                HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) &= ~CPUTIMER_TCR_TSS;\n\n                //\n                // Check to see timer is counting properly\n                //\n                for(i = 0U; i < 1000U; i++)\n                {\n                    //\n                    // Check overflow flag\n                    //\n                    if((HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) &\n                        CPUTIMER_TCR_TIF) != 0U)\n                    {\n                        //\n                        // Clear overflow flag\n                        //\n                        HWREGH(CPUTIMER2_BASE +\n                               CPUTIMER_O_TCR) |= CPUTIMER_TCR_TIF;\n\n                        //\n                        // Set flag to indicate PLL started and break out of\n                        // for-loop\n                        //\n                        started = 1U;\n                        break;\n                    }\n                }\n\n                //\n                // Stop timer\n                //\n                HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TSS;\n                counter++;\n                EDIS;\n            }\n\n            if(started == 0U)\n            {\n                //\n                // AUX PLL may not have started. Reset multiplier to 0 (bypass\n                // PLL).\n                //\n                EALLOW;\n                HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLMULT) = 0U;\n                EDIS;\n\n                //\n                // The user should put some handler code here based on how\n                // this condition should be handled in their application.\n                //\n                ESTOP0;\n            }\n\n            //\n            // Restore Timer 2 configuration\n            //\n            EALLOW;\n            HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL) = t2CLKCTL;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) = t2TCR;\n            HWREG(CPUTIMER2_BASE + CPUTIMER_O_PRD) = t2PRD;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPR) = t2TPR;\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPRH) = t2TPRH;\n\n            //\n            // Reload period value\n            //\n            HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TRB;\n            EDIS;\n        }\n    }\n    else\n    {\n        //\n        // Enable AUXPLLCLK to be fed from AUXPLL\n        //\n        EALLOW;\n        HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) |= SYSCTL_AUXPLLCTL1_PLLCLKEN;\n        SysCtl_delay(3U);\n        EDIS;\n    }\n\n    //\n    // Slip Bit Monitor\n    // Re-lock routine for SLIP condition\n    //\n    while(((HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLSTS) &\n            SYSCTL_AUXPLLSTS_SLIPS) != 0U) && (attempts < 10U) &&\n          ((config & SYSCTL_AUXPLL_ENABLE) == SYSCTL_AUXPLL_ENABLE))\n    {\n        EALLOW;\n\n        //\n        // Bypass AUXPLL\n        //\n        HWREGH(CLKCFG_BASE +\n               SYSCTL_O_AUXPLLCTL1) &= ~SYSCTL_AUXPLLCTL1_PLLCLKEN;\n\n        //\n        // Delay of at least 120 OSCCLK cycles required post PLL bypass\n        //\n        SysCtl_delay(23U);\n\n        //\n        // Turn off AUXPLL\n        //\n        HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) &= ~SYSCTL_AUXPLLCTL1_PLLEN;\n        SysCtl_delay(3U);\n\n        //\n        // Set integer and fractional multiplier, which automatically turns\n        // on the PLL\n        //\n        HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLMULT) |= pllMult;\n\n        //\n        // Enable AUXPLL\n        //\n        HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) |= SYSCTL_AUXPLLCTL1_PLLEN;\n\n        //\n        // Wait for the AUXPLL lock counter\n        //\n        while((HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLSTS) &\n               SYSCTL_AUXPLLSTS_LOCKS) != 1U)\n        {\n            //\n            // Consider to servicing the watchdog using\n            // SysCtl_serviceWatchdog()\n            //\n        }\n\n        //\n        // Enable AUXPLLCLK to be fed from AUXPLL\n        //\n        HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) |= SYSCTL_AUXPLLCTL1_PLLCLKEN;\n\n        SysCtl_delay(3U);\n\n        attempts++;\n\n        EDIS;\n    }\n\n    //\n    // Set divider to desired value\n    //\n    EALLOW;\n    HWREGH(CLKCFG_BASE + SYSCTL_O_AUXCLKDIVSEL) =\n        (uint16_t)(config & SYSCTL_SYSDIV_M) >> SYSCTL_SYSDIV_S;\n    SYSCTL_REGWRITE_DELAY;\n    EDIS;\n\n}\n\n\n//*****************************************************************************\n//\n// SysCtl_selectXTAL()\n//\n//*****************************************************************************\nvoid\nSysCtl_selectXTAL(void)\n{\n    uint16_t t2TCR, t2TPR, t2TPRH, t2CLKCTL;\n    uint32_t t2PRD;\n\n    //\n    // Backup CPU timer2 settings\n    //\n    t2CLKCTL = HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL);\n    t2TCR = HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR);\n    t2PRD = HWREG(CPUTIMER2_BASE + CPUTIMER_O_PRD);\n    t2TPR = HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPR);\n    t2TPRH = HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPRH);\n\n    //\n    // Backup AUX clock settings\n    //\n    uint16_t clksrcctl2 = HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL2);\n    uint16_t auxpllctl1 = HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1);\n    uint16_t auxclkdivsel = HWREGH(CLKCFG_BASE + SYSCTL_O_AUXCLKDIVSEL);\n\n    //\n    // Set AUX clock source to XTAL, bypass mode.\n    // AUXCLK is used as the CPUTimer Clock source. SYSCLK frequency must be\n    // atleast twice the frequency of AUXCLK. SYSCLK = INTOSC2(10MHz)\n    // Set the AUX divider to 8. The above condition will be met for XTAL\n    // frequencies up to 40MHz\n    //\n    EALLOW;\n    HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL2) =\n            (HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL2) &\n             ~(SYSCTL_CLKSRCCTL2_AUXOSCCLKSRCSEL_M)) |\n            (1U << SYSCTL_CLKSRCCTL2_AUXOSCCLKSRCSEL_S);\n    HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) = 0x0U;\n    HWREGH(CLKCFG_BASE + SYSCTL_O_AUXCLKDIVSEL) = SYSCTL_AUXPLLCLK_DIV_8;\n    SYSCTL_REGWRITE_DELAY;\n\n\n    //\n    // Disable cpu timer 2 interrupt\n    //\n    CPUTimer_disableInterrupt(CPUTIMER2_BASE);\n\n    //\n    // Stop cpu timer 2 if running\n    //\n    CPUTimer_stopTimer(CPUTIMER2_BASE);\n\n    //\n    // Initialize cpu timer 2 period\n    //\n    CPUTimer_setPeriod(CPUTIMER2_BASE, XTAL_CPUTIMER_PERIOD);\n\n    //\n    // Set cpu timer 2 clock source to XTAL\n    //\n    CPUTimer_selectClockSource(CPUTIMER2_BASE, CPUTIMER_CLOCK_SOURCE_AUX,\n                               CPUTIMER_CLOCK_PRESCALER_1);\n\n    //\n    // Clear cpu timer 2 overflow flag\n    //\n    CPUTimer_clearOverflowFlag(CPUTIMER2_BASE);\n\n    //\n    // Start cpu timer 2\n    //\n    CPUTimer_startTimer(CPUTIMER2_BASE);\n\n    EALLOW;\n    //\n    // Turn on XTAL\n    //\n    HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &= ~SYSCTL_CLKSRCCTL1_XTALOFF;\n    EDIS;\n\n    //\n    // Wait for the X1 clock to overflow cpu timer 2\n    //\n    SysCtl_pollCpuTimer();\n\n    //\n    // Select XTAL as the oscillator source\n    //\n    EALLOW;\n    HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) =\n    ((HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &\n      (~SYSCTL_CLKSRCCTL1_OSCCLKSRCSEL_M)) |\n     (SYSCTL_OSCSRC_XTAL >> SYSCTL_OSCSRC_S));\n    EDIS;\n\n    //\n    // If a missing clock failure was detected, try waiting for the cpu timer 2\n    // to overflow again.\n    //\n    while(SysCtl_isMCDClockFailureDetected())\n    {\n        //\n        // Clear the MCD failure\n        //\n        SysCtl_resetMCD();\n\n        //\n        // Wait for the X1 clock to overflow cpu timer 2\n        //\n        SysCtl_pollCpuTimer();\n\n        //\n        // Select XTAL as the oscillator source\n        //\n        EALLOW;\n        HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) =\n        ((HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &\n          (~SYSCTL_CLKSRCCTL1_OSCCLKSRCSEL_M)) |\n         (SYSCTL_OSCSRC_XTAL >> SYSCTL_OSCSRC_S));\n        EDIS;\n    }\n\n    //\n    // Stop cpu timer 2\n    //\n    CPUTimer_stopTimer(CPUTIMER2_BASE);\n\n    //\n    // Restore Timer 2 configuration\n    //\n    EALLOW;\n    HWREGH(CPUSYS_BASE + SYSCTL_O_TMR2CLKCTL) = t2CLKCTL;\n    HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) = t2TCR;\n    HWREG(CPUTIMER2_BASE + CPUTIMER_O_PRD) = t2PRD;\n    HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPR) = t2TPR;\n    HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TPRH) = t2TPRH;\n    HWREGH(CPUTIMER2_BASE + CPUTIMER_O_TCR) |= CPUTIMER_TCR_TRB;\n\n    //\n    // Restore AUX clock settings\n    //\n    HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL2) = clksrcctl2;\n    HWREGH(CLKCFG_BASE + SYSCTL_O_AUXPLLCTL1) = auxpllctl1;\n    HWREGH(CLKCFG_BASE + SYSCTL_O_AUXCLKDIVSEL) = auxclkdivsel;\n    SYSCTL_REGWRITE_DELAY;\n    EDIS;\n\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// SysCtl_selectOscSource()\n//\n//*****************************************************************************\nvoid\nSysCtl_selectOscSource(uint32_t oscSource)\n{\n    ASSERT((oscSource == SYSCTL_OSCSRC_OSC1) ||\n           (oscSource == SYSCTL_OSCSRC_OSC2) ||\n           (oscSource == SYSCTL_OSCSRC_XTAL));\n\n    //\n    // Select the specified source.\n    //\n    EALLOW;\n    switch(oscSource)\n    {\n        case SYSCTL_OSCSRC_OSC2:\n            //\n            // Turn on INTOSC2\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &=\n                ~SYSCTL_CLKSRCCTL1_INTOSC2OFF;\n\n            SYSCTL_CLKSRCCTL_DELAY;\n\n            //\n            // Clk Src = INTOSC2\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &=\n                ~SYSCTL_CLKSRCCTL1_OSCCLKSRCSEL_M;\n\n            SYSCTL_CLKSRCCTL_DELAY;\n\n            //\n            // Turn off XTALOSC\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) |=\n                SYSCTL_CLKSRCCTL1_XTALOFF;\n\n            break;\n\n        case SYSCTL_OSCSRC_XTAL:\n            //\n            // Select XTAL in crystal mode and wait for it to power up\n            //\n            SysCtl_selectXTAL();\n            break;\n\n        case SYSCTL_OSCSRC_OSC1:\n            //\n            // Clk Src = INTOSC1\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) =\n                   (HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &\n                    ~SYSCTL_CLKSRCCTL1_OSCCLKSRCSEL_M) |\n                   (SYSCTL_OSCSRC_OSC1 >> SYSCTL_OSCSRC_S);\n\n            SYSCTL_CLKSRCCTL_DELAY;\n\n            //\n            //Turn off XTALOSC\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) |=\n                SYSCTL_CLKSRCCTL1_XTALOFF;\n\n            break;\n\n        default:\n            //\n            // Do nothing. Not a valid oscSource value.\n            //\n            break;\n    }\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// SysCtl_selectOscSourceAuxPLL()\n//\n//*****************************************************************************\nvoid\nSysCtl_selectOscSourceAuxPLL(uint32_t oscSource)\n{\n    bool status = false;\n\n    EALLOW;\n\n    switch(oscSource)\n    {\n        case SYSCTL_AUXPLL_OSCSRC_OSC2:\n            //\n            // Turn on INTOSC2\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &=\n                    ~(SYSCTL_CLKSRCCTL1_INTOSC2OFF);\n            SYSCTL_CLKSRCCTL_DELAY;\n\n            //\n            // Clk Src = INTOSC2\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL2) &=\n                    ~(SYSCTL_CLKSRCCTL2_AUXOSCCLKSRCSEL_M);\n            break;\n\n        case SYSCTL_AUXPLL_OSCSRC_XTAL:\n            //\n            // Turn on XTALOSC\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &=\n                   ~(SYSCTL_CLKSRCCTL1_XTALOFF);\n            SYSCTL_CLKSRCCTL_DELAY;\n\n            //\n            // Clk Src = XTAL\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL2) =\n                    (HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL2) &\n                     ~(SYSCTL_CLKSRCCTL2_AUXOSCCLKSRCSEL_M)) |\n                    (1U << SYSCTL_CLKSRCCTL2_AUXOSCCLKSRCSEL_S);\n            break;\n\n        case SYSCTL_AUXPLL_OSCSRC_AUXCLKIN:\n            //\n            // Clk Src = AUXCLKIN\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL2) =\n                    (HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL2) &\n                     ~(SYSCTL_CLKSRCCTL2_AUXOSCCLKSRCSEL_M)) |\n                    (2U << SYSCTL_CLKSRCCTL2_AUXOSCCLKSRCSEL_S);\n            SYSCTL_CLKSRCCTL_DELAY;\n            break;\n\n        default:\n            //\n            // Do nothing. Not a valid clock source value.\n            //\n            break;\n    }\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// SysCtl_getLowSpeedClock()\n//\n//*****************************************************************************\nuint32_t\nSysCtl_getLowSpeedClock(uint32_t clockInHz)\n{\n    uint32_t clockOut;\n\n    //\n    // Get the main system clock\n    //\n    clockOut = SysCtl_getClock(clockInHz);\n\n    //\n    // Apply the divider to the main clock\n    //\n    if((HWREG(CLKCFG_BASE + SYSCTL_O_LOSPCP) &\n        SYSCTL_LOSPCP_LSPCLKDIV_M) != 0U)\n    {\n        clockOut /= (2U * (HWREG(CLKCFG_BASE + SYSCTL_O_LOSPCP) &\n                            SYSCTL_LOSPCP_LSPCLKDIV_M));\n    }\n\n    return(clockOut);\n}\n\n//*****************************************************************************\n//\n// SysCtl_getDeviceParametric()\n//\n//*****************************************************************************\nuint16_t\nSysCtl_getDeviceParametric(SysCtl_DeviceParametric parametric)\n{\n    uint32_t value;\n\n    //\n    // Get requested parametric value\n    //\n    switch(parametric)\n    {\n        case SYSCTL_DEVICE_QUAL:\n            //\n            // Qualification Status\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDL) &\n                      SYSCTL_PARTIDL_QUAL_M) >> SYSCTL_PARTIDL_QUAL_S);\n            break;\n\n        case SYSCTL_DEVICE_PINCOUNT:\n            //\n            // Pin Count\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDL) &\n                      SYSCTL_PARTIDL_PIN_COUNT_M) >>\n                     SYSCTL_PARTIDL_PIN_COUNT_S);\n            break;\n\n        case SYSCTL_DEVICE_INSTASPIN:\n            //\n            // InstaSPIN Feature Set\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDL) &\n                      SYSCTL_PARTIDL_INSTASPIN_M) >>\n                     SYSCTL_PARTIDL_INSTASPIN_S);\n            break;\n\n        case SYSCTL_DEVICE_FLASH:\n            //\n            // Flash Size (KB)\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDL) &\n                      SYSCTL_PARTIDL_FLASH_SIZE_M) >>\n                     SYSCTL_PARTIDL_FLASH_SIZE_S);\n            break;\n\n        case SYSCTL_DEVICE_PARTID:\n            //\n            // PARTID Format Revision\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDL) &\n                      SYSCTL_PARTIDL_PARTID_FORMAT_REVISION_M) >>\n                     SYSCTL_PARTIDL_PARTID_FORMAT_REVISION_S);\n            break;\n\n        case SYSCTL_DEVICE_FAMILY:\n            //\n            // Device Family\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDH) &\n                      SYSCTL_PARTIDH_FAMILY_M) >> SYSCTL_PARTIDH_FAMILY_S);\n            break;\n\n        case SYSCTL_DEVICE_PARTNO:\n            //\n            // Part Number\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDH) &\n                      SYSCTL_PARTIDH_PARTNO_M) >> SYSCTL_PARTIDH_PARTNO_S);\n            break;\n\n        case SYSCTL_DEVICE_CLASSID:\n            //\n            // Class ID\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDH) &\n                      SYSCTL_PARTIDH_DEVICE_CLASS_ID_M) >>\n                     SYSCTL_PARTIDH_DEVICE_CLASS_ID_S);\n            break;\n\n        default:\n            //\n            // Not a valid value for PARTID register\n            //\n            value = 0U;\n            break;\n    }\n\n    return((uint16_t)value);\n}\n\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};